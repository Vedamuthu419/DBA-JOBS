USE [DBADB]
GO

/****** Object:  StoredProcedure [dbo].[asp_long_running_Regressing_Jobs_Alerts]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE [dbo].[asp_long_running_Regressing_Jobs_Alerts]
         @history_days int = 15,
         @avg_duration_multiplier float = 1.5,
         @ignore_zero_durations bit = 0
 
AS

SET NOCOUNT ON
BEGIN
 
        select sj.name,
               sja.start_execution_date,
               sja.stop_execution_date,
               ajt.min_run_duration,
               ajt.max_run_duration,
               ajt.avg_run_duration,
               datediff(ss, start_execution_date, getdate()) as cur_run_duration
        into #Regressing_Jobs
 
        from msdb..sysjobactivity sja
               left join
               (select job_id,
                       avg(dbo.udf_convert_int_time2ss(run_duration)) as avg_run_duration,
                       min(dbo.udf_convert_int_time2ss(run_duration)) as min_run_duration,
                       max(dbo.udf_convert_int_time2ss(run_duration)) as max_run_duration
                       from msdb..sysjobhistory
                       where step_id=0
                       and run_date >CONVERT(varchar(8),GETDATE() - @history_days,112)
                       and ((run_duration <> 0 or @ignore_zero_durations = 0))
                       group by job_id
               )ajt on sja.job_id=ajt.job_id
        join msdb..sysjobs sj on sj.job_id=sja.job_id
        where
               sja.session_id = (SELECT TOP 1 session_id
                                   FROM msdb.dbo.syssessions
                                  ORDER BY agent_start_date DESC)
               AND start_execution_date is not null
               and stop_execution_date is null
               and datediff(ss, start_execution_date, getdate()) >
                   ajt.avg_run_duration * @avg_duration_multiplier
				   and datediff(ss, start_execution_date, getdate()) > 360
 
        select name as JobName,
               start_execution_date,
               stop_execution_date,
               dateadd(second, min_run_duration, 0) as min_run_duration,
               dateadd(second, max_run_duration, 0) as max_run_duration,
               dateadd(second, avg_run_duration, 0) as avg_run_duration,
               dateadd(second, cur_run_duration, 0) as cur_run_duration
        from #Regressing_Jobs
     
END
 
GO

/****** Object:  StoredProcedure [dbo].[asp_long_running_Regressing_Jobs_Alerts1]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO





 
-- <begin stored procedure DDL/>
 
CREATE PROCEDURE [dbo].[asp_long_running_Regressing_Jobs_Alerts1]
         @history_days int = 15,
         @avg_duration_multiplier float = 2,
         @bEmail bit = 0,
         @bSaveToTable bit = 0,
         @RecipientsList Varchar(1000) = 'dbasupport@geopits.freshdesk.com',
         @ignore_zero_durations bit = 0
 
AS
/* example of usage:
   exec DBA_db..asp_long_running_Regressing_Jobs_Alerts
               @history_days = 45,
               @avg_duration_multiplier = 2,
               @bEmail = 0,
               @bSaveToTable = 0,
               @RecipientsList  = 'myName@myCoDomain.com;'   ,
               @ignore_zero_durations = 1
 
AUTHOR(s):
Vladimir Isaev;
-- + V.B., S.L;
-- contact@sqlexperts.org
*/      
 
/*PARAMETERS:
@history_days int          (how many days back we use for AVF run duration)
@avg_duration_multiplier   (how many times longer than AVG will qualify job 
                            for producing an alert)
@bEmail                    (send out Alert Email or just print the msg about Regressing jobs)
                           -- 'REGRESSION' is defined here by Duration only
*/
SET NOCOUNT ON
BEGIN
 
        select sj.name,
               sja.start_execution_date,
               sja.stop_execution_date,
               ajt.min_run_duration,
               ajt.max_run_duration,
               ajt.avg_run_duration,
               datediff(ss, start_execution_date, getdate()) as cur_run_duration
        into #Regressing_Jobs
 
        from msdb..sysjobactivity sja
               left join
               (select job_id,
                       avg(dbo.udf_convert_int_time2ss(run_duration)) as avg_run_duration,
                       min(dbo.udf_convert_int_time2ss(run_duration)) as min_run_duration,
                       max(dbo.udf_convert_int_time2ss(run_duration)) as max_run_duration
                       from msdb..sysjobhistory
                       where step_id=0
                       and run_date >CONVERT(varchar(8),GETDATE() - @history_days,112)
                       and ((run_duration <> 0 or @ignore_zero_durations = 0))
                       and run_duration < 240000
                       group by job_id
               )ajt on sja.job_id=ajt.job_id
        join msdb..sysjobs sj on sj.job_id=sja.job_id
        where
               sja.session_id = (SELECT TOP 1 session_id
                                   FROM msdb.dbo.syssessions
                                  ORDER BY agent_start_date DESC)
               AND start_execution_date is not null
               and stop_execution_date is null
               and datediff(ss, start_execution_date, getdate()) >
                   ajt.avg_run_duration * @avg_duration_multiplier
				  and datediff(ss, start_execution_date, getdate()) > 360
 
        select name as JobName,
               start_execution_date,
               stop_execution_date,
               dateadd(second, min_run_duration, 0) as min_run_duration,
               dateadd(second, max_run_duration, 0) as max_run_duration,
               dateadd(second, avg_run_duration, 0) as avg_run_duration,
               dateadd(second, cur_run_duration, 0) as cur_run_duration
        into #Regressing_Jobs_DurAsDate
        from #Regressing_Jobs
                                            --  waitfor delay '00:00:10'
        declare @sHtml varchar(max) = ''
 
        declare @tableHTML  nvarchar(max) =
               N'<H1>Job(s) taking longer than recent baseline duration
                (in descending avg duration order):</H1>' + Char(13)
               + N'    <table border="1">'           + Char(13)
               + N'    <tr bgcolor="#ddd">'          + Char(13)
               + N'           <th>Start Time</th>'   + Char(13)
               + N'           <th>Job Name</th>'     + Char(13)
               + N'           <th>Host Name</th>'    + Char(13)
               + N'           <th>History Days</th>' + Char(13)
               + N'           <th>Avg Dur Mul</th>'  + Char(13)
               + N'           <th>Min Dur</th>'      + Char(13)
               + N'           <th>Max Dur</th>'      + Char(13)
               + N'           <th>Avg Dur</th>'      + Char(13)
               + N'           <th>Cur Dur</th>'      + Char(13)
               + N'    </tr>'                        + Char(13)
 
        select @tableHTML =  @tableHTML
               + FORMATMESSAGE(
                       '<tr><td>%s</td>'       
                          + Char(13) --start_execution_date
                       + '<td>%s</td>'        + Char(13) --name
                       + '<td>%s</td>'        + Char(13) --@@SERVERNAME
                       + '<td style="text-align:center">%i</td>'  
                          + Char(13) --@history_days
                       + '<td style="text-align:center">%s</td>' 
                          + Char(13) --@avg_duration_multiplier
                       + '<td>%s</td>'        + Char(13) --Min Dur
                       + '<td>%s</td>'        + Char(13) --Max Dur
                       + '<td>%s</td>'        + Char(13) --Avg Dur
                       + '<td>%s</td>'        + Char(13),--Cur Dur
                               convert(varchar, start_execution_date, 120),
                               JobName,
                               @@SERVERNAME,
                               @history_days,
                               convert(varchar, @avg_duration_multiplier),
                               format(min_run_duration, N'HH\hmm\mss\s'),
                               format(max_run_duration, N'HH\hmm\mss\s'),
                               format(avg_run_duration, N'HH\hmm\mss\s'),
                               format(cur_run_duration, N'HH\hmm\mss\s')
                       )
          from #Regressing_Jobs_DurAsDate
		  --where cur_run_duration >'00h02m00s'
          order by avg_run_duration desc, JobName
 
               select @tableHTML = @tableHTML + '</tr></table>' + Char(13)
 
        select @sHtml = @tableHTML
        --select @sHtml
 
        declare @DateStr varchar(30) = convert(varchar,getdate(),121)
        IF @bEmail = 1 and (select count(*) from #Regressing_Jobs) > 0
         begin
              
               declare @sSubject varchar(250)
                   = @@SERVERNAME + ' Job(s) taking longer than recent baseline duration: '  
                     + @DateStr 
 
               EXEC msdb.dbo.sp_send_dbmail  @profile_name='DBA',
                                              @recipients= @RecipientsList,
                                              @subject=@sSubject, 
                                               @body=@sHtml,
                                              @body_format = 'HTML'
 
               print 'email sent: ' + CHAR(13) + @sHtml
        end
 
        IF @bSaveToTable = 1
          begin
               insert into RegressingJobs
         (
 CaptureDateTime,
 JobName,
 start_execution_date,
 HostName,
 history_days,
 avg_duration_multiplier,
                           min_run_duration,
 max_run_duration,
 avg_run_duration,
 cur_run_duration
 )
select         @DateStr,
JobName,
start_execution_date,
@@SERVERNAME,
@history_days,   
@avg_duration_multiplier,
min_run_duration,
max_run_duration,
avg_run_duration,
cur_run_duration
               from #Regressing_Jobs_DurAsDate
          end
 
        begin
 
         SELECT 'JOBS THAT ARE TAKING LONGER THAN USUAL:  '
         select  @DateStr as CaptureDateTime, JobName,  
            start_execution_date, @@SERVERNAME as 'Server',
                 @history_days as '@history_days',  
                    @avg_duration_multiplier as '@avg_duration_multiplier',
                 min_run_duration, max_run_duration, 
                    avg_run_duration, cur_run_duration
         from    #Regressing_Jobs_DurAsDate
 
        end
 
--all currently running jobs:
       begin
               SELECT ' ALL JOBS THAT ARE CURRENTLY RUNNING:  '
               SELECT
                 -- '',  -- CAST (ja.job_id AS VARCHAR(max)),
                       j.name AS job_name,
                  cast ( ja.start_execution_date as varchar) start_execution_time,  
                  cast ( ja.stop_execution_date  as varchar) stop_execution_time,  
                  -- ISNULL(last_executed_step_id,0)+1 AS current_executed_step_id,
                       Js.step_name step_name
               FROM msdb.dbo.sysjobactivity ja
               LEFT JOIN msdb.dbo.sysjobhistory jh
                       ON ja.job_history_id = jh.instance_id
               JOIN msdb.dbo.sysjobs j
                 ON ja.job_id = j.job_id
               JOIN msdb.dbo.sysjobsteps js
                 ON ja.job_id = js.job_id
                AND ISNULL(ja.last_executed_step_id,0)+1 = js.step_id
               WHERE j.name!='[DBA - Regressing_Jobs]' and    ja.session_id =
                    (SELECT TOP 1 session_id
               FROM msdb.dbo.syssessions
           ORDER BY agent_start_date DESC)
               AND start_execution_date is not null
               AND stop_execution_date  is null;
 
        end
END
 
GO

/****** Object:  StoredProcedure [dbo].[Check_LogShippingCopyStatus_SecondLatest]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[Check_LogShippingCopyStatus_SecondLatest]
AS
BEGIN
    SET NOCOUNT ON;

    ------------------------------------------------------
    -- VARIABLES
    ------------------------------------------------------
    DECLARE 
          @PrimaryFolder VARCHAR(500)   = 'G:\charbilogship\'
        , @SecondaryFolder VARCHAR(500) = '\\10.10.10.42\e\Tlogshare\Cahrbiblobcopy\'
        , @SecondLatestPrimary VARCHAR(255)
        , @LatestSecondary VARCHAR(255)
        , @FoundInSecondary VARCHAR(255)
        , @SecondLatestTimeUTC DATETIME
        , @SecondLatestTime DATETIME
        , @LatestSecondaryTimeUTC DATETIME
        , @LatestSecondaryTime DATETIME
        , @Message VARCHAR(MAX)
        , @ServerName VARCHAR(200) = @@SERVERNAME;

DECLARE @SubjectOpen  VARCHAR(300)  = 'OPEN ALERT - Log Shipping Copy Delay for charbi (' + @ServerName + ')';
DECLARE @SubjectClose VARCHAR(300)  = 'RESOLVED ALERT - Log Shipping Copy Issue for charbi (' + @ServerName + ')';

    -------------------------------------------------------
    -- PRIMARY SERVER LATEST & SECOND LATEST FILE
    -------------------------------------------------------
    CREATE TABLE #p (filename VARCHAR(255));
    INSERT #p EXEC master.dbo.xp_cmdshell 
        'dir /b /od "G:\charbilogship\*.trn"';
    DELETE FROM #p WHERE filename IS NULL OR filename NOT LIKE '%.trn';

    -- Latest file
    SELECT TOP 1 * INTO #LatestP FROM #p ORDER BY filename DESC;

    -- Second latest file
    SELECT TOP 1 @SecondLatestPrimary = filename
    FROM #p
    WHERE filename NOT IN (SELECT filename FROM #LatestP)
    ORDER BY filename DESC;

    -------------------------------------------------------
    -- Convert SECOND LATEST Primary timestamp (UTC → IST)
    -------------------------------------------------------
    DECLARE @dtStr VARCHAR(14);
    SET @dtStr = SUBSTRING(@SecondLatestPrimary, CHARINDEX('_', @SecondLatestPrimary)+1, 14);
    SELECT @SecondLatestTimeUTC =
        TRY_CONVERT(DATETIME, STUFF(STUFF(STUFF(@dtStr, 9, 0, ' '), 12, 0, ':'), 15, 0, ':'), 120);
    SELECT @SecondLatestTime = DATEADD(MINUTE, 330, @SecondLatestTimeUTC);

    -------------------------------------------------------
    -- SECONDARY SERVER LATEST FILE
    -------------------------------------------------------
    CREATE TABLE #s (filename VARCHAR(255));
    INSERT #s EXEC master.dbo.xp_cmdshell 
        'dir /b /od "\\10.10.10.42\e\Tlogshare\Cahrbiblobcopy\*.trn"';
    DELETE FROM #s WHERE filename IS NULL OR filename NOT LIKE '%.trn';
    SELECT TOP 1 @LatestSecondary = filename FROM #s ORDER BY filename DESC;

    -------------------------------------------------------
    -- Convert Secondary timestamp (UTC → IST)
    -------------------------------------------------------
    DECLARE @dtStr2 VARCHAR(14);
    SET @dtStr2 = SUBSTRING(@LatestSecondary, CHARINDEX('_', @LatestSecondary)+1, 14);
    SELECT @LatestSecondaryTimeUTC =
        TRY_CONVERT(DATETIME, STUFF(STUFF(STUFF(@dtStr2, 9, 0, ' '), 12, 0, ':'), 15, 0, ':'), 120);
    SELECT @LatestSecondaryTime = DATEADD(MINUTE, 330, @LatestSecondaryTimeUTC);

    -------------------------------------------------------
    -- CHECK IF SECOND LATEST FILE EXISTS IN SECONDARY
    -------------------------------------------------------
    SELECT @FoundInSecondary = filename 
    FROM #s
    WHERE filename = @SecondLatestPrimary;

    -------------------------------------------------------
    -- OPEN ALERT FOR MISSING FILE
    -------------------------------------------------------
    IF @FoundInSecondary IS NULL
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM dbo.LogShippingAlertTracker WHERE FileName=@SecondLatestPrimary)
        BEGIN
            INSERT INTO dbo.LogShippingAlertTracker(FileName, AlertStatus, OpenAlertTime)
            VALUES (@SecondLatestPrimary,'OPEN',GETDATE());

            SET @Message = '
            <html><body>
            <h2 style="color:red;">LOG SHIPPING COPY DELAY - OPEN ALERT</h2>
            <table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse;font-size:14px;">
                <tr style="background-color:#ffcccc;font-weight:bold;"><td>Parameter</td><td>Value</td></tr>
                <tr><td>Second Latest Primary File</td><td>' + @SecondLatestPrimary + '</td></tr>
                <tr><td>Primary Backup Time (IST)</td><td>' + ISNULL(CONVERT(VARCHAR(20), @SecondLatestTime, 120),'Unknown') + '</td></tr>
                <tr><td>Latest Secondary Copied File</td><td>' + ISNULL(@LatestSecondary,'NO FILE FOUND') + '</td></tr>
                <tr><td>Secondary Copied Time (IST)</td><td>' + ISNULL(CONVERT(VARCHAR(20), @LatestSecondaryTime, 120),'Unknown') + '</td></tr>
                <tr><td>Status</td><td><b style="color:red;">File NOT Copied</b></td></tr>
            </table>
            </body></html>';

            EXEC msdb.dbo.sp_send_dbmail
                @profile_name='DBA',
                @recipients='aruneswaran@geopits.com',
                @subject=@SubjectOpen,
                @body=@Message,
                @body_format='HTML';
        END
        RETURN;
    END;

    -------------------------------------------------------
    -- CREATE TEMP TABLE FOR RESOLVED FILES
    -------------------------------------------------------
    IF OBJECT_ID('tempdb..#ResolvedFiles') IS NOT NULL
        DROP TABLE #ResolvedFiles;

    CREATE TABLE #ResolvedFiles(FileName VARCHAR(255), ResolvedTime DATETIME);

    -------------------------------------------------------
    -- RESOLVED ALERT FOR ALL OPEN FILES THAT EXIST NOW
    -------------------------------------------------------
    INSERT INTO #ResolvedFiles(FileName, ResolvedTime)
    SELECT T.FileName, GETDATE()
    FROM dbo.LogShippingAlertTracker T
    INNER JOIN #s S ON S.filename=T.FileName
    WHERE T.AlertStatus='OPEN';

    -- UPDATE TRACKING TABLE
    UPDATE T
    SET AlertStatus='RESOLVED',
        ResolvedTime=R.ResolvedTime
    FROM dbo.LogShippingAlertTracker T
    INNER JOIN #ResolvedFiles R ON T.FileName=R.FileName;

    -- SEND EMAIL FOR EACH RESOLVED FILE
    DECLARE @FileName VARCHAR(255), @ResolvedTime DATETIME;
    DECLARE ResolvedCursor CURSOR FAST_FORWARD FOR
    SELECT FileName, ResolvedTime FROM #ResolvedFiles;

    OPEN ResolvedCursor;
    FETCH NEXT FROM ResolvedCursor INTO @FileName, @ResolvedTime;
    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @Message = '
        <html><body>
        <h2 style="color:green;">LOG SHIPPING ISSUE RESOLVED</h2>
        <table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse;font-size:14px;">
            <tr style="background-color:#ccffcc;font-weight:bold;"><td>Parameter</td><td>Value</td></tr>
            <tr><td>File Name</td><td>' + @FileName + '</td></tr>
            <tr><td>Resolved At (IST)</td><td>' + CONVERT(VARCHAR(20), DATEADD(MINUTE,0,@ResolvedTime), 120) + '</td></tr>
            <tr><td>Status</td><td><b style="color:green;">Copied Successfully</b></td></tr>
        </table>
        </body></html>';

        EXEC msdb.dbo.sp_send_dbmail
            @profile_name='DBA',
            @recipients='aruneswaran@geopits.com',
            @subject=@SubjectClose,
            @body=@Message,
            @body_format='HTML';

        FETCH NEXT FROM ResolvedCursor INTO @FileName, @ResolvedTime;
    END
    CLOSE ResolvedCursor;
    DEALLOCATE ResolvedCursor;

END
GO

/****** Object:  StoredProcedure [dbo].[Check_LogShippingCopyStatus_SecondLatest_V1]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[Check_LogShippingCopyStatus_SecondLatest_V1]
AS
BEGIN
    SET NOCOUNT ON;

    ------------------------------------------------------
    -- VARIABLES
    ------------------------------------------------------
    DECLARE 
          @PrimaryFolder VARCHAR(500)   = 'G:\charbilogship\'
        , @SecondaryFolder VARCHAR(500) = '\\10.10.10.42\e\Tlogshare\Cahrbiblobcopy\'
        , @SecondLatestPrimary VARCHAR(255)
        , @LatestSecondary VARCHAR(255)
        , @FoundInSecondary VARCHAR(255)
        , @SecondLatestTimeUTC DATETIME
        , @SecondLatestTime DATETIME
        , @LatestSecondaryTimeUTC DATETIME
        , @LatestSecondaryTime DATETIME
        , @Message VARCHAR(MAX)
        , @ServerName VARCHAR(200) = @@SERVERNAME
        , @AlertID INT
        , @TimeDiff INT;

    -- subjects templates (we will set final subject strings after we know ID)
    DECLARE @SubjectOpen  VARCHAR(400);
    DECLARE @SubjectClose VARCHAR(400);

    -------------------------------------------------------
    -- 1) PRIMARY SERVER - list files and pick second latest
    -------------------------------------------------------
    CREATE TABLE #p (filename VARCHAR(255));

    INSERT #p
    EXEC master.dbo.xp_cmdshell 
        'dir /b /od "G:\charbilogship\*.trn"';

    DELETE FROM #p WHERE filename IS NULL OR filename NOT LIKE '%.trn';

    -- Latest file (temporary table)
    SELECT TOP 1 * INTO #LatestP FROM #p ORDER BY filename DESC;

    -- Second latest file (the one we monitor)
    SELECT TOP 1 @SecondLatestPrimary = filename
    FROM #p
    WHERE filename NOT IN (SELECT filename FROM #LatestP)
    ORDER BY filename DESC;

    -------------------------------------------------------
    -- 2) Extract timestamp from second-latest filename (UTC) -> convert to IST
    -------------------------------------------------------
    IF @SecondLatestPrimary IS NOT NULL
    BEGIN
        DECLARE @dtStr VARCHAR(14);
        SET @dtStr = SUBSTRING(@SecondLatestPrimary, CHARINDEX('_', @SecondLatestPrimary)+1, 14);

        SELECT @SecondLatestTimeUTC =
            TRY_CONVERT(DATETIME, STUFF(STUFF(STUFF(@dtStr, 9, 0, ' '), 12, 0, ':'), 15, 0, ':'), 120);

        SELECT @SecondLatestTime = DATEADD(MINUTE, 330, @SecondLatestTimeUTC);
    END

    -------------------------------------------------------
    -- 3) SECONDARY SERVER - latest copied file + convert timestamp to IST
    -------------------------------------------------------
    CREATE TABLE #s (filename VARCHAR(255));

    INSERT #s
    EXEC master.dbo.xp_cmdshell 
        'dir /b /od "\\10.10.10.42\e\Tlogshare\Cahrbiblobcopy\*.trn"';

    DELETE FROM #s WHERE filename IS NULL OR filename NOT LIKE '%.trn';

    SELECT TOP 1 @LatestSecondary = filename FROM #s ORDER BY filename DESC;

    IF @LatestSecondary IS NOT NULL
    BEGIN
        DECLARE @dtStr2 VARCHAR(14);
        SET @dtStr2 = SUBSTRING(@LatestSecondary, CHARINDEX('_', @LatestSecondary)+1, 14);

        SELECT @LatestSecondaryTimeUTC =
            TRY_CONVERT(DATETIME, STUFF(STUFF(STUFF(@dtStr2, 9, 0, ' '), 12, 0, ':'), 15, 0, ':'), 120);

        SELECT @LatestSecondaryTime = DATEADD(MINUTE, 330, @LatestSecondaryTimeUTC);
    END

    -------------------------------------------------------
    -- 4) Check existence of monitored file on secondary
    -------------------------------------------------------
    SELECT @FoundInSecondary = filename FROM #s WHERE filename = @SecondLatestPrimary;

    -------------------------------------------------------
    -- 5) Delay check: PrimaryTime - LatestSecondaryTime (minutes)
    --    If LatestSecondaryTime is NULL, treat as missing (we will open alert)
    -------------------------------------------------------
    IF @LatestSecondaryTime IS NULL OR @SecondLatestTime IS NULL
        SET @TimeDiff = NULL;
    ELSE
        SET @TimeDiff = DATEDIFF(MINUTE, @LatestSecondaryTime, @SecondLatestTime);

    -------------------------------------------------------
    -- 6) OPEN ALERT condition: missing OR delay > 30 minutes
    -------------------------------------------------------
    IF (@FoundInSecondary IS NULL) OR (@TimeDiff IS NOT NULL AND @TimeDiff > 30)
    BEGIN
        -- Only create open alert if not already present for this file
        IF NOT EXISTS (SELECT 1 FROM dbo.LogShippingAlertTracker WHERE FileName = @SecondLatestPrimary AND AlertStatus = 'OPEN')
        BEGIN
            INSERT INTO dbo.LogShippingAlertTracker (FileName, AlertStatus, OpenAlertTime)
            VALUES (@SecondLatestPrimary, 'OPEN', GETDATE());

            -- capture the inserted ID for subject pairing
            SET @AlertID = SCOPE_IDENTITY();

            -- compose subject with Alert ID and server name
            SET @SubjectOpen = 'OPEN ALERT (ID ' + CAST(@AlertID AS VARCHAR(10)) + ') - Log Shipping Copy Delay (' + @ServerName + ')';

            -- build HTML message (header colored only)
            SET @Message =
                '<html><body>' +
                '<h2 style="color:red;">LOG SHIPPING COPY DELAY - OPEN ALERT</h2>' +
                '<table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse;font-size:14px;">' +
                '<tr style="background-color:#ffcccc;font-weight:bold;"><td>Parameter</td><td>Value</td></tr>' +
                '<tr><td>Second Latest Primary File</td><td>' + ISNULL(@SecondLatestPrimary,'N/A') + '</td></tr>' +
                '<tr><td>Primary Backup Time (IST)</td><td>' + ISNULL(CONVERT(VARCHAR(20), @SecondLatestTime, 120),'Unknown') + '</td></tr>' +
                '<tr><td>Latest Secondary Copied File</td><td>' + ISNULL(@LatestSecondary,'NO FILE FOUND') + '</td></tr>' +
                '<tr><td>Secondary Copied Time (IST)</td><td>' + ISNULL(CONVERT(VARCHAR(20), @LatestSecondaryTime, 120),'Unknown') + '</td></tr>' +
                '<tr><td>Status</td><td><b style="color:red;">File not copied OR delay &gt; 30 minutes</b></td></tr>' +
                '<tr><td>Action Required</td><td>Check Task Scheduler, Copy Job, Network Path, Folder Permissions</td></tr>' +
                '</table></body></html>';

            EXEC msdb.dbo.sp_send_dbmail
                @profile_name = 'DBA',
                @recipients   = 'mssqlalerts@geopits.com;aruneswaran@geopits.com',
                @subject      = @SubjectOpen,
                @body         = @Message,
                @body_format  = 'HTML';
        END

        -- done for this run (open alert created or existed)
        RETURN;
    END

    -------------------------------------------------------
    -- 7) RESOLVED processing: find all OPEN rows whose files now exist on secondary,
    --    set them RESOLVED and capture their IDs for per-file resolved emails.
    -------------------------------------------------------

    -- ensure temporary table exists to collect resolved rows
    IF OBJECT_ID('tempdb..#ResolvedFiles') IS NOT NULL
        DROP TABLE #ResolvedFiles;

    CREATE TABLE #ResolvedFiles
    (
        AlertID INT,
        FileName VARCHAR(255),
        ResolvedTime DATETIME
    );

    -- Populate #ResolvedFiles by updating tracker rows and OUTPUTting the updated rows
    UPDATE T
    SET AlertStatus = 'RESOLVED',
        ResolvedTime = GETDATE()
    OUTPUT inserted.ID, inserted.FileName, inserted.ResolvedTime
    INTO #ResolvedFiles (AlertID, FileName, ResolvedTime)
    FROM dbo.LogShippingAlertTracker T
    INNER JOIN #s S ON S.filename = T.FileName
    WHERE T.AlertStatus = 'OPEN';

    -- Send resolved email, one per resolved file (subject includes same AlertID)
    DECLARE @RFileName VARCHAR(255), @RAlertID INT, @RResolvedTime DATETIME;
    DECLARE ResolvedCursor CURSOR FAST_FORWARD FOR
        SELECT AlertID, FileName, ResolvedTime FROM #ResolvedFiles;

    OPEN ResolvedCursor;
    FETCH NEXT FROM ResolvedCursor INTO @RAlertID, @RFileName, @RResolvedTime;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @SubjectClose = 'RESOLVED ALERT (ID ' + CAST(@RAlertID AS VARCHAR(10)) + ') - Log Shipping Copy Issue (' + @ServerName + ')';

        SET @Message =
            '<html><body>' +
            '<h2 style="color:green;">LOG SHIPPING ISSUE RESOLVED</h2>' +
            '<table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse;font-size:14px;">' +
            '<tr style="background-color:#ccffcc;font-weight:bold;"><td>Parameter</td><td>Value</td></tr>' +
            '<tr><td>File Name</td><td>' + ISNULL(@RFileName,'N/A') + '</td></tr>' +
            '<tr><td>Resolved At (IST)</td><td>' + CONVERT(VARCHAR(20), DATEADD(MINUTE,0,@RResolvedTime), 120) + '</td></tr>' +
            '<tr><td>Status</td><td><b style="color:green;">Copied Successfully</b></td></tr>' +
            '</table></body></html>';

        EXEC msdb.dbo.sp_send_dbmail
            @profile_name = 'DBA',
            @recipients   = 'mssqlalerts@geopits.com;aruneswaran@geopits.com',
            @subject      = @SubjectClose,
            @body         = @Message,
            @body_format  = 'HTML';

        FETCH NEXT FROM ResolvedCursor INTO @RAlertID, @RFileName, @RResolvedTime;
    END

    CLOSE ResolvedCursor;
    DEALLOCATE ResolvedCursor;

END;
GO

/****** Object:  StoredProcedure [dbo].[Check_LogShippingCopyStatus_SecondLatest_V2]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[Check_LogShippingCopyStatus_SecondLatest_V2]
AS
BEGIN
    SET NOCOUNT ON;

    ------------------------------------------------------
    -- VARIABLES
    ------------------------------------------------------
    DECLARE 
          @PrimaryFolder VARCHAR(500)   = 'G:\charbilogship\'
        , @SecondaryFolder VARCHAR(500) = '\\10.10.10.42\e\Tlogshare\Cahrbiblobcopy\'
        , @SecondLatestPrimary VARCHAR(255)
        , @LatestSecondary VARCHAR(255)
        , @FoundInSecondary VARCHAR(255)
        , @SecondLatestTimeUTC DATETIME
        , @SecondLatestTime DATETIME
        , @LatestSecondaryTimeUTC DATETIME
        , @LatestSecondaryTime DATETIME
        , @Message VARCHAR(MAX)
        , @ServerName VARCHAR(200) = @@SERVERNAME
        , @AlertID INT
        , @TimeDiff INT;

    DECLARE @SubjectOpen  VARCHAR(400);
    DECLARE @SubjectClose VARCHAR(400);

    -------------------------------------------------------
    -- 1) PRIMARY SERVER - list files and pick second latest
    -------------------------------------------------------
    IF OBJECT_ID('tempdb..#p') IS NOT NULL DROP TABLE #p;
    CREATE TABLE #p (filename VARCHAR(255));

    INSERT #p
    EXEC master.dbo.xp_cmdshell 'dir /b /od "G:\charbilogship\*.trn"';

    DELETE FROM #p WHERE filename IS NULL OR filename NOT LIKE '%.trn';

    IF OBJECT_ID('tempdb..#LatestP') IS NOT NULL DROP TABLE #LatestP;
    SELECT TOP 1 * INTO #LatestP FROM #p ORDER BY filename DESC;

    SELECT TOP 1 @SecondLatestPrimary = filename
    FROM #p
    WHERE filename NOT IN (SELECT filename FROM #LatestP)
    ORDER BY filename DESC;

    -------------------------------------------------------
    -- 2) Extract timestamp from second-latest filename (UTC) -> convert to IST
    -------------------------------------------------------
    IF @SecondLatestPrimary IS NOT NULL
    BEGIN
        DECLARE @dtStr VARCHAR(14);
        SET @dtStr = SUBSTRING(@SecondLatestPrimary, CHARINDEX('_', @SecondLatestPrimary)+1, 14);

        SELECT @SecondLatestTimeUTC =
            TRY_CONVERT(DATETIME, STUFF(STUFF(STUFF(@dtStr,9,0,' '),12,0,':'),15,0,':'), 120);

        SELECT @SecondLatestTime = DATEADD(MINUTE, 330, @SecondLatestTimeUTC);
    END

    -------------------------------------------------------
    -- 3) SECONDARY SERVER - latest copied file + convert timestamp to IST
    -------------------------------------------------------
    IF OBJECT_ID('tempdb..#s') IS NOT NULL DROP TABLE #s;
    CREATE TABLE #s (filename VARCHAR(255));

    INSERT #s
    EXEC master.dbo.xp_cmdshell 'dir /b /od "\\10.10.10.42\e\Tlogshare\Cahrbiblobcopy\*.trn"';

    DELETE FROM #s WHERE filename IS NULL OR filename NOT LIKE '%.trn';

    SELECT TOP 1 @LatestSecondary = filename FROM #s ORDER BY filename DESC;

    IF @LatestSecondary IS NOT NULL
    BEGIN
        DECLARE @dtStr2 VARCHAR(14);
        SET @dtStr2 = SUBSTRING(@LatestSecondary, CHARINDEX('_', @LatestSecondary)+1, 14);

        SELECT @LatestSecondaryTimeUTC =
            TRY_CONVERT(DATETIME, STUFF(STUFF(STUFF(@dtStr2,9,0,' '),12,0,':'),15,0,':'), 120);

        SELECT @LatestSecondaryTime = DATEADD(MINUTE, 330, @LatestSecondaryTimeUTC);
    END

    -------------------------------------------------------
    -- 4) Compute TimeDiff only if both timestamps are present
    -------------------------------------------------------
    IF @LatestSecondaryTime IS NULL OR @SecondLatestTime IS NULL
        SET @TimeDiff = NULL;
    ELSE
        SET @TimeDiff = DATEDIFF(MINUTE, @LatestSecondaryTime, @SecondLatestTime);

    -------------------------------------------------------
    -- 5) OPEN ALERT condition: only when TimeDiff > 30 (Option C)
    --    (do NOT alert if file missing and TimeDiff is NULL)
    -------------------------------------------------------
    IF (@TimeDiff IS NOT NULL AND @TimeDiff > 45)
    BEGIN
        -- Only create open alert if not already present for this file
        IF NOT EXISTS (
            SELECT 1 FROM dbo.LogShippingAlertTracker 
            WHERE FileName = @SecondLatestPrimary AND AlertStatus = 'OPEN'
        )
        BEGIN
            INSERT INTO dbo.LogShippingAlertTracker (FileName, AlertStatus, OpenAlertTime)
            VALUES (@SecondLatestPrimary, 'OPEN', GETDATE());

            -- capture the inserted ID for subject pairing
            SET @AlertID = SCOPE_IDENTITY();

            -- compose subject with Alert ID and server name
            SET @SubjectOpen = 'OPEN ALERT (ID ' + CAST(@AlertID AS VARCHAR(10)) + ') - Log Shipping Copy Delay (' + @ServerName + ')';

            -- build HTML message (header colored only)
            SET @Message =
                '<html><body>' +
                '<h2 style="color:red;">LOG SHIPPING COPY DELAY - OPEN ALERT</h2>' +
                '<table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse;font-size:14px;">' +
                '<tr style="background-color:#ffcccc;font-weight:bold;"><td>Parameter</td><td>Value</td></tr>' +
                '<tr><td>Second Latest Primary File</td><td>' + ISNULL(@SecondLatestPrimary,'N/A') + '</td></tr>' +
                '<tr><td>Primary Backup Time (IST)</td><td>' + ISNULL(CONVERT(VARCHAR(20), @SecondLatestTime, 120),'Unknown') + '</td></tr>' +
                '<tr><td>Latest Secondary Copied File</td><td>' + ISNULL(@LatestSecondary,'NO FILE FOUND') + '</td></tr>' +
                '<tr><td>Secondary Copied Time (IST)</td><td>' + ISNULL(CONVERT(VARCHAR(20), @LatestSecondaryTime, 120),'Unknown') + '</td></tr>' +
                '<tr><td>Time Difference (mins)</td><td>' + CAST(@TimeDiff AS VARCHAR(10)) + '</td></tr>' +
                '<tr><td>Status</td><td><b style="color:red;">Delay &gt; 45 minutes</b></td></tr>' +
                '<tr><td>Action Required</td><td>Check Task Scheduler, Copy Job, Network Path, Folder Permissions</td></tr>' +
                '</table></body></html>';

            EXEC msdb.dbo.sp_send_dbmail
                @profile_name = 'DBA',
                @recipients   = 'mssqlalerts@geopits.com;aruneswaran@geopits.com',
                @subject      = @SubjectOpen,
                @body         = @Message,
                @body_format  = 'HTML';
        END

        RETURN;
    END

    -------------------------------------------------------
    -- 6) RESOLVED processing (set-based): resolve OPEN rows where
    --    current TimeDiff for that File <= 30 (use current LatestSecondaryTime)
    --    Note: If LatestSecondaryTime is NULL we cannot resolve
    -------------------------------------------------------
    IF @LatestSecondaryTime IS NOT NULL
    BEGIN
        -- temp table for resolved rows
        IF OBJECT_ID('tempdb..#ResolvedFiles') IS NOT NULL DROP TABLE #ResolvedFiles;
        CREATE TABLE #ResolvedFiles (AlertID INT, FileName VARCHAR(255), ResolvedTime DATETIME);

        -- Update tracker to RESOLVED when the condition meets (TimeDiff <= 30)
        UPDATE T
        SET AlertStatus = 'RESOLVED',
            ResolvedTime = GETDATE()
        OUTPUT inserted.ID, inserted.FileName, inserted.ResolvedTime
        INTO #ResolvedFiles (AlertID, FileName, ResolvedTime)
        FROM dbo.LogShippingAlertTracker T
        CROSS APPLY (
            -- extract primary UTC datetime from filename in tracker
            SELECT TRY_CONVERT(DATETIME,
                STUFF(STUFF(STUFF(SUBSTRING(T.FileName, CHARINDEX('_',T.FileName)+1, 14),9,0,' '),12,0,':'),15,0,':'), 120
            ) AS PrimaryUTC
        ) P
        WHERE T.AlertStatus = 'OPEN'
          AND P.PrimaryUTC IS NOT NULL
          -- convert PrimaryUTC to IST and compare with current LatestSecondaryTime
          AND DATEDIFF(MINUTE, @LatestSecondaryTime, DATEADD(MINUTE,330,P.PrimaryUTC)) <= 30;

        -- send per-file resolved emails
        DECLARE @RFileName VARCHAR(255), @RAlertID INT, @RResolvedTime DATETIME;
        DECLARE ResolvedCursor CURSOR FAST_FORWARD FOR
            SELECT AlertID, FileName, ResolvedTime FROM #ResolvedFiles;

        OPEN ResolvedCursor;
        FETCH NEXT FROM ResolvedCursor INTO @RAlertID, @RFileName, @RResolvedTime;

        WHILE @@FETCH_STATUS = 0
        BEGIN
            SET @SubjectClose = 'RESOLVED ALERT (ID ' + CAST(@RAlertID AS VARCHAR(10)) + ') - Log Shipping Copy Issue (' + @ServerName + ')';

            SET @Message =
                '<html><body>' +
                '<h2 style="color:green;">LOG SHIPPING ISSUE RESOLVED</h2>' +
                '<table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse;font-size:14px;">' +
                '<tr style="background-color:#ccffcc;font-weight:bold;"><td>Parameter</td><td>Value</td></tr>' +
                '<tr><td>File Name</td><td>' + ISNULL(@RFileName,'N/A') + '</td></tr>' +
                '<tr><td>Resolved At (IST)</td><td>' + CONVERT(VARCHAR(20), DATEADD(MINUTE,0,@RResolvedTime), 120) + '</td></tr>' +
                '<tr><td>Status</td><td><b style="color:green;">Issue Resolved</b></td></tr>' +
                '</table></body></html>';

            EXEC msdb.dbo.sp_send_dbmail
                @profile_name = 'DBA',
                @recipients   = 'mssqlalerts@geopits.com;aruneswaran@geopits.com',
                @subject      = @SubjectClose,
                @body         = @Message,
                @body_format  = 'HTML';

            FETCH NEXT FROM ResolvedCursor INTO @RAlertID, @RFileName, @RResolvedTime;
        END

        CLOSE ResolvedCursor;
        DEALLOCATE ResolvedCursor;
    END

    -- clean up temp tables
    IF OBJECT_ID('tempdb..#p') IS NOT NULL DROP TABLE #p;
    IF OBJECT_ID('tempdb..#LatestP') IS NOT NULL DROP TABLE #LatestP;
    IF OBJECT_ID('tempdb..#s') IS NOT NULL DROP TABLE #s;
    IF OBJECT_ID('tempdb..#ResolvedFiles') IS NOT NULL DROP TABLE #ResolvedFiles;

END;
GO

/****** Object:  StoredProcedure [dbo].[CommandExecute]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[CommandExecute]

@DatabaseContext nvarchar(max),
@Command nvarchar(max),
@CommandType nvarchar(max),
@Mode int,
@Comment nvarchar(max) = NULL,
@DatabaseName nvarchar(max) = NULL,
@SchemaName nvarchar(max) = NULL,
@ObjectName nvarchar(max) = NULL,
@ObjectType nvarchar(max) = NULL,
@IndexName nvarchar(max) = NULL,
@IndexType int = NULL,
@StatisticsName nvarchar(max) = NULL,
@PartitionNumber int = NULL,
@ExtendedInfo xml = NULL,
@LockMessageSeverity int = 16,
@ExecuteAsUser nvarchar(max) = NULL,
@LogToTable nvarchar(max),
@Execute nvarchar(max)

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source:  https://ola.hallengren.com                                                        //--
  --// License: https://ola.hallengren.com/license.html                                           //--
  --// GitHub:  https://github.com/olahallengren/sql-server-maintenance-solution                  //--
  --// Version: 2022-12-03 17:23:44                                                               //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)
  DECLARE @ErrorMessageOriginal nvarchar(max)
  DECLARE @Severity int

  DECLARE @Errors TABLE (ID int IDENTITY PRIMARY KEY,
                         [Message] nvarchar(max) NOT NULL,
                         Severity int NOT NULL,
                         [State] int)

  DECLARE @CurrentMessage nvarchar(max)
  DECLARE @CurrentSeverity int
  DECLARE @CurrentState int

  DECLARE @sp_executesql nvarchar(max) = QUOTENAME(@DatabaseContext) + '.sys.sp_executesql'

  DECLARE @StartTime datetime2
  DECLARE @EndTime datetime2

  DECLARE @ID int

  DECLARE @Error int = 0
  DECLARE @ReturnCode int = 0

  DECLARE @EmptyLine nvarchar(max) = CHAR(9)

  DECLARE @RevertCommand nvarchar(max)

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF NOT (SELECT [compatibility_level] FROM sys.databases WHERE database_id = DB_ID()) >= 90
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The database ' + QUOTENAME(DB_NAME(DB_ID())) + ' has to be in compatibility level 90 or higher.', 16, 1
  END

  IF NOT (SELECT uses_ansi_nulls FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'ANSI_NULLS has to be set to ON for the stored procedure.', 16, 1
  END

  IF NOT (SELECT uses_quoted_identifier FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'QUOTED_IDENTIFIER has to be set to ON for the stored procedure.', 16, 1
  END

  IF @LogToTable = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandLog')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The table CommandLog is missing. Download https://ola.hallengren.com/scripts/CommandLog.sql.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF @DatabaseContext IS NULL OR NOT EXISTS (SELECT * FROM sys.databases WHERE name = @DatabaseContext)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @DatabaseContext is not supported.', 16, 1
  END

  IF @Command IS NULL OR @Command = ''
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Command is not supported.', 16, 1
  END

  IF @CommandType IS NULL OR @CommandType = '' OR LEN(@CommandType) > 60
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @CommandType is not supported.', 16, 1
  END

  IF @Mode NOT IN(1,2) OR @Mode IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Mode is not supported.', 16, 1
  END

  IF @LockMessageSeverity NOT IN(10,16) OR @LockMessageSeverity IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @LockMessageSeverity is not supported.', 16, 1
  END

  IF LEN(@ExecuteAsUser) > 128
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @ExecuteAsUser is not supported.', 16, 1
  END

  IF @LogToTable NOT IN('Y','N') OR @LogToTable IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @LogToTable is not supported.', 16, 1
  END

  IF @Execute NOT IN('Y','N') OR @Execute IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Execute is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Raise errors                                                                               //--
  ----------------------------------------------------------------------------------------------------

  DECLARE ErrorCursor CURSOR FAST_FORWARD FOR SELECT [Message], Severity, [State] FROM @Errors ORDER BY [ID] ASC

  OPEN ErrorCursor

  FETCH ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState

  WHILE @@FETCH_STATUS = 0
  BEGIN
    RAISERROR('%s', @CurrentSeverity, @CurrentState, @CurrentMessage) WITH NOWAIT
    RAISERROR(@EmptyLine, 10, 1) WITH NOWAIT

    FETCH NEXT FROM ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState
  END

  CLOSE ErrorCursor

  DEALLOCATE ErrorCursor

  IF EXISTS (SELECT * FROM @Errors WHERE Severity >= 16)
  BEGIN
    SET @ReturnCode = 50000
    GOTO ReturnCode
  END

  ----------------------------------------------------------------------------------------------------
  --// Execute as user                                                                            //--
  ----------------------------------------------------------------------------------------------------

  IF @ExecuteAsUser IS NOT NULL
  BEGIN
    SET @Command = 'EXECUTE AS USER = ''' + REPLACE(@ExecuteAsUser,'''','''''') + '''; ' + @Command + '; REVERT;'

    SET @RevertCommand = 'REVERT'
  END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @StartTime = SYSDATETIME()

  SET @StartMessage = 'Date and time: ' + CONVERT(nvarchar,@StartTime,120)
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Database context: ' + QUOTENAME(@DatabaseContext)
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Command: ' + @Command
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  IF @Comment IS NOT NULL
  BEGIN
    SET @StartMessage = 'Comment: ' + @Comment
    RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT
  END

  IF @LogToTable = 'Y'
  BEGIN
    INSERT INTO dbo.CommandLog (DatabaseName, SchemaName, ObjectName, ObjectType, IndexName, IndexType, StatisticsName, PartitionNumber, ExtendedInfo, CommandType, Command, StartTime)
    VALUES (@DatabaseName, @SchemaName, @ObjectName, @ObjectType, @IndexName, @IndexType, @StatisticsName, @PartitionNumber, @ExtendedInfo, @CommandType, @Command, @StartTime)
  END

  SET @ID = SCOPE_IDENTITY()

  ----------------------------------------------------------------------------------------------------
  --// Execute command                                                                            //--
  ----------------------------------------------------------------------------------------------------

  IF @Mode = 1 AND @Execute = 'Y'
  BEGIN
    EXECUTE @sp_executesql @stmt = @Command
    SET @Error = @@ERROR
    SET @ReturnCode = @Error
  END

  IF @Mode = 2 AND @Execute = 'Y'
  BEGIN
    BEGIN TRY
      EXECUTE @sp_executesql @stmt = @Command
    END TRY
    BEGIN CATCH
      SET @Error = ERROR_NUMBER()
      SET @ErrorMessageOriginal = ERROR_MESSAGE()

      SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'')
      SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
      RAISERROR('%s',@Severity,1,@ErrorMessage) WITH NOWAIT

      IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
      BEGIN
        SET @ReturnCode = ERROR_NUMBER()
      END

      IF @ExecuteAsUser IS NOT NULL
      BEGIN
        EXECUTE @sp_executesql @RevertCommand
      END
    END CATCH
  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  SET @EndTime = SYSDATETIME()

  SET @EndMessage = 'Outcome: ' + CASE WHEN @Execute = 'N' THEN 'Not Executed' WHEN @Error = 0 THEN 'Succeeded' ELSE 'Failed' END
  RAISERROR('%s',10,1,@EndMessage) WITH NOWAIT

  SET @EndMessage = 'Duration: ' + CASE WHEN (DATEDIFF(SECOND,@StartTime,@EndTime) / (24 * 3600)) > 0 THEN CAST((DATEDIFF(SECOND,@StartTime,@EndTime) / (24 * 3600)) AS nvarchar) + '.' ELSE '' END + CONVERT(nvarchar,DATEADD(SECOND,DATEDIFF(SECOND,@StartTime,@EndTime),'1900-01-01'),108)
  RAISERROR('%s',10,1,@EndMessage) WITH NOWAIT

  SET @EndMessage = 'Date and time: ' + CONVERT(nvarchar,@EndTime,120)
  RAISERROR('%s',10,1,@EndMessage) WITH NOWAIT

  RAISERROR(@EmptyLine,10,1) WITH NOWAIT

  IF @LogToTable = 'Y'
  BEGIN
    UPDATE dbo.CommandLog
    SET EndTime = @EndTime,
        ErrorNumber = CASE WHEN @Execute = 'N' THEN NULL ELSE @Error END,
        ErrorMessage = @ErrorMessageOriginal
    WHERE ID = @ID
  END

  ReturnCode:
  IF @ReturnCode <> 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END
GO

/****** Object:  StoredProcedure [dbo].[DBA_Blocking_queries]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO




CREATE PROCEDURE [dbo].[DBA_Blocking_queries]
AS
BEGIN
    SET NOCOUNT ON;


IF OBJECT_ID('tempdb..#BlockingInfo') IS NOT NULL DROP TABLE #BlockingInfo;
IF OBJECT_ID('tempdb..#BlockingInfo1') IS NOT NULL DROP TABLE #BlockingInfo1;

-- Create the temporary tables
CREATE TABLE #BlockingInfo (
    head_blocker_session_id INT,
    blocking_queries_count INT,
    head_blocker_query NVARCHAR(max));

IF OBJECT_ID('dbadb..BlockedQueriesInfo') IS NULL

CREATE TABLE dbadb..BlockedQueriesInfo (
    ServerName NVARCHAR(100),
    BlockedSessionID INT,
    StartTime DATETIME,
    WaitingInMinutes FLOAT,
    WaitType NVARCHAR(50),
    BlockingSessionID INT,
    QueryWaiting NVARCHAR(max),
	logdate datetime default getdate()
);

IF OBJECT_ID('dbadb..HeadBlockingInfo') IS NULL
CREATE TABLE dbadb..HeadBlockingInfo (
     host_name NVARCHAR(100),
	login_name NVARCHAR(100),
	duration NVARCHAR(100),
	head_blocker_session_id INT,
    blocking_queries_count INT,
    head_blocker_query NVARCHAR(max),
	logdate datetime default getdate());

INSERT INTO dbadb..BlockedQueriesInfo (ServerName, BlockedSessionID, StartTime, WaitingInMinutes, WaitType, BlockingSessionID, QueryWaiting)
SELECT 
    DISTINCT @@SERVERNAME AS [Server Name], 
    b.session_id AS [Blocked Session ID], 
    r.start_time, 
    (b.wait_duration_ms / 1000) / 60 AS [Waiting in Minutes],
    b.wait_type AS [Wait Type], 
    b.blocking_session_id AS [Blocking Session ID], 
    t.[text] AS [Query Waiting to Execute]
FROM 
    sys.dm_os_waiting_tasks b 
INNER JOIN 
    sys.dm_exec_requests r ON r.session_id = b.session_id 
OUTER APPLY 
    sys.dm_exec_sql_text(r.sql_handle) t 
WHERE 
    b.blocking_session_id <> 0 and b.blocking_session_id <>b.session_id ;

-- Insert data into #BlockingInfo
WITH cteHead AS (
    SELECT 
        sess.session_id, 
        req.request_id, 
        LEFT(ISNULL(req.wait_type, ''), 50) AS wait_type,
        LEFT(ISNULL(req.wait_resource, ''), 40) AS wait_resource, 
        LEFT(req.last_wait_type, 50) AS last_wait_type,
        sess.is_user_process, 
        req.cpu_time AS request_cpu_time, 
        req.logical_reads AS request_logical_reads,
        req.reads AS request_reads, 
        req.writes AS request_writes, 
        req.wait_time, 
        req.blocking_session_id,
        sess.memory_usage,
        sess.cpu_time AS session_cpu_time, 
        sess.reads AS session_reads, 
        sess.writes AS session_writes, 
        sess.logical_reads AS session_logical_reads,
        CONVERT(decimal(5,2), req.percent_complete) AS percent_complete, 
        req.estimated_completion_time AS est_completion_time,
        req.start_time AS request_start_time, 
        LEFT(req.status, 15) AS request_status, 
        req.command,
        req.plan_handle, 
        req.sql_handle, 
        req.statement_start_offset, 
        req.statement_end_offset, 
        conn.most_recent_sql_handle,
        LEFT(sess.status, 15) AS session_status, 
        sess.group_id, 
        req.query_hash, 
        req.query_plan_hash
    FROM sys.dm_exec_sessions AS sess
    LEFT OUTER JOIN sys.dm_exec_requests AS req 
        ON sess.session_id = req.session_id
    LEFT OUTER JOIN sys.dm_exec_connections AS conn 
        ON conn.session_id = sess.session_id 
		   

),
cteBlockingHierarchy AS (
    SELECT 
        head.session_id AS head_blocker_session_id, 
        head.session_id AS session_id, 
        head.blocking_session_id,
        head.wait_type, 
        head.wait_time, 
        head.wait_resource, 
        head.statement_start_offset, 
        head.statement_end_offset,
        head.plan_handle, 
        head.sql_handle, 
        head.most_recent_sql_handle, 
        0 AS Level
    FROM cteHead AS head
    WHERE (head.blocking_session_id IS NULL OR head.blocking_session_id = 0)
    AND head.session_id IN (SELECT DISTINCT blocking_session_id FROM cteHead WHERE blocking_session_id != 0)
    UNION ALL
    SELECT 
        h.head_blocker_session_id, 
        blocked.session_id, 
        blocked.blocking_session_id, 
        blocked.wait_type,
        blocked.wait_time, 
        blocked.wait_resource, 
        h.statement_start_offset, 
        h.statement_end_offset,                                                                                                                                                                                                                                                                               
        h.plan_handle, 
        h.sql_handle, 
        h.most_recent_sql_handle, 
        [Level] + 1
    FROM cteHead AS blocked
    INNER JOIN cteBlockingHierarchy AS h 
        ON h.session_id = blocked.blocking_session_id 
        AND h.session_id != blocked.session_id -- Avoid infinite recursion for latch type of blocking
    WHERE h.wait_type COLLATE Latin1_General_BIN NOT IN ('EXCHANGE', 'CXPACKET') 
        OR h.wait_type IS NULL
)
INSERT INTO #BlockingInfo (head_blocker_session_id, blocking_queries_count, head_blocker_query)
SELECT 
    bh.head_blocker_session_id,
    COUNT(bh.session_id)  AS blocking_queries_count,
    txt.text AS head_blocker_query
	

FROM cteBlockingHierarchy AS bh
OUTER APPLY sys.dm_exec_sql_text(ISNULL(bh.sql_handle, bh.most_recent_sql_handle)) AS txt
where bh.head_blocker_session_id<>bh.session_id
GROUP BY bh.head_blocker_session_id, txt.text;

 -- select * from #BlockingInfo

CREATE TABLE #BlockingInfo1 (
    session_id INT,
    host_name NVARCHAR(100),
	login_name NVARCHAR(100),
	);

insert into #BlockingInfo1(session_id,host_name,login_name)
SELECT s.session_id, s.host_name,s.login_name
FROM sys.dm_exec_sessions s 
LEFT OUTER JOIN sys.dm_exec_requests r on r.session_id = s.session_id
OUTER APPLY sys.dm_exec_sql_text (r.sql_handle) t
OUTER APPLY sys.dm_exec_input_buffer(s.session_id, NULL) AS ib
WHERE s.session_id in   (select head_blocker_session_id from #BlockingInfo) 
ORDER BY   r.blocking_session_id desc, r.session_id

insert  into dbadb..HeadBlockingInfo(head_blocker_session_id ,blocking_queries_count , head_blocker_query,host_name ,login_name ,duration )
SELECT 
    s.head_blocker_session_id, 
    s.blocking_queries_count, 
    s.head_blocker_query,
    t.host_name, 
    t.login_name,    
    CONVERT(VARCHAR, DATEADD(SECOND, DATEDIFF(SECOND, MAX(ses.last_request_start_time), GETDATE()), 0), 108) AS duration
FROM 
    #BlockingInfo s 
INNER JOIN 
    #BlockingInfo1 t ON s.head_blocker_session_id = t.session_id
INNER JOIN 
    sys.dm_exec_sessions ses ON t.session_id = ses.session_id
GROUP BY 
    s.head_blocker_session_id, 
    s.blocking_queries_count, 
    s.head_blocker_query, 
    t.host_name, 
    t.login_name
	HAVING 
    DATEDIFF(SECOND, MAX(ses.last_request_start_time), GETDATE()) > 300
	order by duration desc;
-- Step 3: Generate HTML content from the blocking table
DECLARE @HTML NVARCHAR(MAX);
DECLARE @ServerName NVARCHAR(128);
SET @ServerName = (Select @@SERVERNAME);

DECLARE @Subject NVARCHAR(256);
set @Subject='Thyrocare '+@ServerName +' - Blocking Queries '   -- change 1





-- Initialize HTML
SET @HTML = '<html>' +
'<head>' +
'<style>' +
'body { font-family: Arial, sans-serif; color: #333; line-height: 1.6; background-color: white; padding: 20px; }' +
'table { width: 100%; border-collapse: collapse; margin-top: 20px; background-color: #ffffff; }' +  
'table, th, td { border: 1px solid #ddd; }' +
'th, td { padding: 12px; text-align: left; }' +
'th { background-color: #008080; color: white; }' +
'tr:nth-child(even) { background-color: #f2f2f2; }' +
'tr:hover { background-color: #e9ecef; }' +
'p { margin: 0 0 10px; }' +
'</style>' +
'</head>' +
'<body>' +
'<p>Hello Team,</p>' +
'<p>We have detected blocking queries on the <b>' + @ServerName + '</b> server that are currently affecting system performance.</p>' +
'<p><strong>Summary of Impact:</strong></p>' +
'<ul>';

-- Create the summary of blocking queries
DECLARE @Summary NVARCHAR(MAX);

SELECT @Summary = (
    SELECT 
        '<li>SPID <b>' + CAST(s.head_blocker_session_id AS NVARCHAR) + 
        '</b> is blocking ' + CAST(s.blocking_queries_count AS NVARCHAR) + 
        ' queries and has been running for ' + 
        CONVERT(VARCHAR, DATEADD(SECOND, DATEDIFF(SECOND, MAX(ses.last_request_start_time), GETDATE()), 0), 108) + '.</li>'
    FROM #BlockingInfo s
    INNER JOIN #BlockingInfo1 t ON s.head_blocker_session_id = t.session_id
    INNER JOIN sys.dm_exec_sessions ses ON t.session_id = ses.session_id
    GROUP BY s.head_blocker_session_id, s.blocking_queries_count
    HAVING DATEDIFF(SECOND, MAX(ses.last_request_start_time), GETDATE()) > 300
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)');

SET @HTML = @HTML + @Summary + '</ul>' +
'<p><strong>Overview of Blocking Queries:</strong></p>' +
'<p>Blocking occurs when one query holds a lock on a resource needed by another query, causing delays and performance degradation.</p>' +
'<p>Below are the details of the blocking sessions identified:</p>' +
'<table>' +
'<thead>' +
'<tr>' +
'<th>Head Blocker SPID</th>' +
'<th>No. Queries Waiting</th>' +
'<th>Blocking Query Text</th>' +
'<th>Host Name</th>' +
'<th>Login Name</th>' +
'<th>Duration</th>' +
'</tr>' +
'</thead>' +
'<tbody>' +
(SELECT 
        '<tr>' +
        '<td>' + CAST(s.head_blocker_session_id AS NVARCHAR) + '</td>' +
        '<td>' + CAST(s.blocking_queries_count AS NVARCHAR) + '</td>' +
        '<td>' + LEFT(s.head_blocker_query, 300) + '</td>' +
        '<td>' + s.host_name + '</td>' +
        '<td>' + s.login_name + '</td>' +
        '<td>' + s.duration + '</td>' +
        '</tr>'
    FROM dbadb..HeadBlockingInfo s
    WHERE DATEDIFF(SECOND, logdate, GETDATE()) < 60
	order by s.duration desc
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)') +
'</tbody>' +
'</table>' +
'<p>This query has been identified as causing blocking issues within the database. We recommend reviewing it promptly to assess whether termination is necessary to maintain optimal performance.</p>' +
'<p>Please let us know if you would like us to proceed with terminating these queries or if you prefer to allow them to complete their execution.</p>' +
'<p>Thank you for your prompt attention to this matter. We are here to assist you in resolving this issue.</p>' +
'<p>Best Regards,</p>' +
'<p>MSSQL DBA<br>GeoPITS</p>' +
'</body>' +
'</html>';

-- Output the final HTML
--SELECT @HTML AS HTML;




if(@HTML is not null)
BEGIN
EXEC msdb.dbo.Sp_send_dbmail
@profile_name = 'DBA',     --Change 3
@body = @HTML,
@body_format ='html',
@recipients = 'mssqlalerts@geopits.com',
--@copy_recipients ='',
@blind_copy_recipients='',
@subject =@Subject ;
END
 SET NOCOUNT OFF
 
END;

GO

/****** Object:  StoredProcedure [dbo].[DBA_Checking_LongRunning_Queries]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO



Create PROCEDURE [dbo].[DBA_Checking_LongRunning_Queries] 
AS
BEGIN

select  a.spid,a.blocked,SUBSTRING(text, ( r.statement_start_offset / 2 ) + 1,      ( ( CASE WHEN r.statement_end_offset <= 0   THEN DATALENGTH(text)   ELSE r.statement_end_offset END -   r  .statement_start_offset ) / 2 ) + 1) AS statement_text,text, r.percent_complete,DATEDIFF (   MINUTE , a.last_batch , GETDATE() ) [Min]   ,a.lastwaittype,r.start_time ,a.status,r.command,DB_NAME(a.dbid)   DB,a.program_name,a.loginame,a.hostname,b.client_net_address Client_IP,b.client_tcp_port   Client_Port,b.local_net_address Local_IP,b.local_tcp_port   Local_Port,a.cpu,a.physical_io,a.memusage,a.waittime,a.last_batch,query_plan from   sys.sysprocesses a left join sys.dm_exec_connections b on(a.spid =b.session_id) left join   sys.dm_exec_requests r on (a.spid=r.session_id) and (b.connection_id =r.connection_id )   cross  apply sys.dm_exec_sql_text(r.sql_handle)   cross  apply sys.dm_exec_query_plan(r.plan_handle)   where  a  .status not in('sleeping','background') and   a  .spid<>@@spid order by a.cpu desc    


select hostname,blocked, * from master.. sysprocesses with(nolock) where spid<>blocked and blocked<>0  and blocked not in (select spid from master.. sysprocesses with(nolock) where spid<>blocked and blocked<>0) order by waittime desc 
select hostname, blocked,* from master.. sysprocesses with(nolock) where spid in  (select blocked from master.. sysprocesses with(nolock) where  spid<>blocked and blocked<>0 and blocked not in   (select spid from master.. sysprocesses with(nolock) where spid<>blocked and blocked<>0)) 




END
GO

/****** Object:  StoredProcedure [dbo].[Dba_CheckReplicationLatency]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[Dba_CheckReplicationLatency]
AS
BEGIN
    -- Declare a table variable to hold the results of the query
    DECLARE @LatencyResults TABLE (
        object_name NVARCHAR(128),
        counter_name NVARCHAR(128),
        instance_name NVARCHAR(128),
        latency_min DECIMAL(18, 2)
    );

    -- Insert the results of the query into the table variable
    INSERT INTO @LatencyResults
    SELECT * FROM (
        SELECT object_name, counter_name, instance_name, 
               ROUND(cntr_value / 1000, 0) / 60 AS latency_min
        FROM sys.dm_os_performance_counters 
        WHERE object_name LIKE '%Replica%'
        AND counter_name LIKE '%Logreader:%latency%'
        UNION
        SELECT object_name, counter_name, instance_name, 
               ROUND(cntr_value / 1000, 0) / 60 AS latency_min
        FROM sys.dm_os_performance_counters 
        WHERE object_name LIKE '%Replica%'
        AND counter_name LIKE '%Dist%latency%'
    ) x WHERE latency_min >= 10;

    -- Check if there are any rows in the result set
     IF EXISTS (SELECT 1 FROM @LatencyResults)
    BEGIN
        DECLARE @TableHTML NVARCHAR(MAX);
        DECLARE @MessageBody NVARCHAR(MAX);
        DECLARE @ServerName NVARCHAR(128);
        DECLARE @Subject NVARCHAR(256);
		DECLARE @DateTime NVARCHAR(128);
        -- Get the server name
        SET @ServerName = @@SERVERNAME;

		        -- Get the current date and time
        SET @DateTime = CONVERT(NVARCHAR, GETDATE(), 120); -- yyyy-mm-dd hh:mm:ss

        -- Create HTML table with results using FOR XML PATH for concatenation
        SET @TableHTML = 
        N'<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 100%;">
            <tr style="background-color: #f2f2f2;">
                <th>Object Name</th>
                <th>Counter Name</th>
                <th>Instance Name</th>
                <th>Latency (min)</th>
            </tr>' +
            (
                SELECT 
                    N'<tr>' +
                    N'<td>' + object_name + N'</td>' +
                    N'<td>' + counter_name + N'</td>' +
                    N'<td>' + instance_name + N'</td>' +
                    N'<td style="color:red;">' + CONVERT(NVARCHAR(50), latency_min) + N'</td>' +
                    N'</tr>'
                FROM @LatencyResults
                FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') +
        N'</table>';

        -- Create the message body with additional details
        SET @MessageBody = 
        N'<h3>Replication Latency Alert - ' + @ServerName + N'</h3>' +
		N'<p>Date and Time: ' + @DateTime + N'</p>' +
        N'<p>Dear Team,</p>' +
        N'<p>The following replication latency issues have been detected on server <strong>' + @ServerName + N'</strong>:</p>' +
        @TableHTML +
        N'<p>Please review the details above and take the necessary actions.</p>' +
        N'<p>Best Regards,<br>Database Administrator</p>';

        -- Create the subject with server name
          SET @Subject = N'Replication Latency Alert on ' + @ServerName + ' - ' + @DateTime;


        -- Send an email notification
        EXEC msdb.dbo.sp_send_dbmail
            @profile_name = 'DBA',  -- Replace with your Database Mail profile name
            @recipients = 'aswin.kumarvpkothuru@thyrocare.com;sivaramakrishnan.a@thyrocare.com',  -- Replace with the recipient's email address
            @subject = @Subject,
            @body = @MessageBody,
            @body_format = 'HTML';  -- Ensure the email is sent in HTML format
    END
END



--exec Dba_CheckReplicationLatency
GO

/****** Object:  StoredProcedure [dbo].[DBA_GeoPITS_Longrunning]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO








CREATE proc [dbo].[DBA_GeoPITS_Longrunning]
as
begin
  SET NOCOUNT ON;

-- Step 1: Insert long-running queries into the table
INSERT INTO dbadb..longqrydetails (InstanceName, SPID, StartTime, ElapsedTime, UserName, ProgramName, DatabaseName, ExecutingSQL,StatementText, WaitType,StoredProcedure)
SELECT TOP 5
    (SELECT @@SERVERNAME) AS InstanceName,
    r.session_id AS SPID,
    r.start_time AS StartTime,
    CONVERT(VARCHAR, DATEADD(ms, r.total_elapsed_time, 0), 8) AS ElapsedTime,
    c.login_name AS UserName,
    c.program_name AS ProgramName,
    DB_NAME(r.database_id) AS DatabaseName,
    t.[text] AS ExecutingSQL,
	SUBSTRING(
        t.TEXT, 
        r.statement_start_offset / 2 + 1, 
        (CASE 
            WHEN r.statement_end_offset = -1 
                THEN LEN(CONVERT(NVARCHAR(max), t.TEXT)) * 2 
            ELSE r.statement_end_offset 
         END - r.statement_start_offset) / 2 + 1
    )  AS statement_text,
    r.wait_type AS WaitType
	,COALESCE(QUOTENAME(DB_NAME(t.dbid)) + N'.' + QUOTENAME(OBJECT_SCHEMA_NAME(t.objectid, t.dbid)) + N'.' + 
     QUOTENAME(OBJECT_NAME(t.objectid, t.dbid)), NULL) AS StoredProcedure
	 
FROM 
    sys.dm_exec_requests r
    INNER JOIN sys.dm_exec_sessions c ON r.session_id = c.session_id
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
	
WHERE (r.wait_type NOT LIKE 'SP_SERVER_DIAGNOSTICS%' or r.wait_type is not null)
    AND r.session_id != @@SPID
    AND r.session_id > 50
    AND t.[text] <> 'null'
    AND DB_NAME(r.database_id) not in ('distribution','msdb','model','master')
    AND t.[text] <> 'begin tran'
    AND t.[text] NOT LIKE '%ALTER INDEX%'
    AND t.[text] NOT LIKE 'UPDATE STATISTICS%'
    AND t.[text] NOT LIKE '%CREATE PROCEDURE sp_readrequest%'
	and t.[text] not like 'BACKUP%'
	and t.[text] not like 'SP_SERVER_DIAGNOSTICS%'
    AND r.total_elapsed_time / 60000 >= 60  -- Filter queries longer than 30 minutes 
	 AND c.status <> 'sleeping'
	 order by ElapsedTime desc;

-- Step 2: Generate the SPID list for termination
DECLARE @SPIDList NVARCHAR(MAX);

-- Concatenate SPIDs into a comma-separated list
SET @SPIDList = 
    STUFF(
        (SELECT ', ' + CAST(SPID AS NVARCHAR)
         FROM dbadb..longqrydetails 
         WHERE DATEDIFF(MINUTE, logdate, GETDATE()) < 1
           FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)')
    , 1, 2, ''); -- Remove the leading comma and space

-- Step 3: Generate HTML content from the longqrydetails table
DECLARE @HTML NVARCHAR(MAX);
DECLARE @ServerName NVARCHAR(128);
SET @ServerName = (Select @@SERVERNAME);

DECLARE @Subject NVARCHAR(256);
set @Subject='Thyrocare '+@ServerName +' -Long Running Queries:Open'

SET @HTML = 
    '<html>' +
    '<head>' +
    '<style>' +
    'body { font-family: Arial, sans-serif; color: #333; line-height: 1.6; }' +
    'table { width: 100%; border-collapse: collapse; margin-top: 20px; }' +
    'table, th, td { border: 1px solid #ddd; }' +
    'th, td { padding: 12px; text-align: centre; }' +
    'th { background-color: #008bff; color: white; }' +
    'tr:nth-child(even) { background-color: #f2f2f2; }' +
    'p { margin: 0 0 10px; }' +
    'h2 { color: #007bff; }' +
    '</style>' +
    '</head>' +
    '<body>' +
    '<p>Hello Team,</p>' +
    '<p>Our DBAs have detected long-running queries on <b>'+ @ServerName+ '</b> Server that are consuming significant resources and may impact overall performance.</p>' +
    '<p>Below is a query that requires your attention:</p>' +
    '<p> SPID:<strong>' + ISNULL(@SPIDList, 'No SPIDs available') + '</strong></p>' +
	'<p> Query Details:</p>'+
    '<table>' +
    '<thead>' +
    '<tr>' +
    '<th>SPID</th>' +
    '<th>Start Time</th>' +
    '<th>Elapsed Time (hh:mm:ss)</th>' +
    '<th>User</th>' +
    '<th>Database</th>' +
    '<th>SQL Text</th>' +
    '<th>Wait Type</th>' +
	'<th>StoredProcedure</th>' +
    '</tr>' +
    '</thead>' +
    '<tbody>' +
    (SELECT TOP 5
        '<tr>' +
        '<td>' + ISNULL(CAST(SPID AS NVARCHAR(MAX)), '') + '</td>' +
        '<td>' + ISNULL(CONVERT(varchar, StartTime, 120), '') + '</td>' +
        '<td>' + ISNULL(ElapsedTime, '') + '</td>' +
        '<td>' + ISNULL(UserName, '') + '</td>' +
        '<td>' + ISNULL(DatabaseName, '') + '</td>' +
        '<td>' + ISNULL(LEFT(StatementText, 250), '') + '</td>' +
        '<td>' + ISNULL(WaitType, '') + '</td>' +
		'<td>' + ISNULL(StoredProcedure, 'Query') + '</td>' +
		'</tr>'
    FROM dbadb..longqrydetails 
    WHERE DATEDIFF(MINUTE, logdate, GETDATE()) < 1
	order by ElapsedTime desc
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)') +
    '</tbody>' +
    '</table>' +
	'<p>    </p>'+
	'<p> This query has been running for over 60 minutes. We recommend terminating it to avoid potential performance issues.<br> Please confirm if you would like us to proceed with terminating the query, or if you prefer to allow it to complete its execution  </p>'+
    
    '<p>Kindly provide your confirmation, and our team will take the necessary action based on your response.</p>' +
    '<p>Thanks for your attention.</p>' +
    '<p>Best Regards,<br>MSSQL DBA<br>GeoPITS</p>' +
    '</body>' +
    '</html>';

-- Output the final HTML
--SELECT @HTML AS HTML;


if(@HTML is not null)
BEGIN
EXEC msdb.dbo.Sp_send_dbmail
@profile_name = 'DBA',
@body = @HTML,
@body_format ='html',
@recipients = 'mssqlalerts@geopits.com',
--@copy_recipients ='',
@blind_copy_recipients='',
@subject =@Subject ;
END

  SET NOCOUNT OFF;
  END

  SET ANSI_NULLS Off
GO

/****** Object:  StoredProcedure [dbo].[DBA_GeoPITS_Longrunning_closed]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO







CREATE proc [dbo].[DBA_GeoPITS_Longrunning_closed]
as	
begin
  SET NOCOUNT ON;
CREATE TABLE #longqrydetails(
	[InstanceName] [nvarchar](max) NULL,
	[StartTime] [datetime] NULL,
	[ElapsedTime] [varchar](8) NULL,
	[SPID] [int] NULL,
	[UserName] [nvarchar](max) NULL,
	[ProgramName] [nvarchar](max) NULL,
	[DatabaseName] [nvarchar](max) NULL,
	[ExecutingSQL] [nvarchar](max) NULL,
	[WaitType] [nvarchar](max) NULL,
	[logdate] [datetime] NULL DEFAULT (getdate())
) 

INSERT INTO #longqrydetails (InstanceName, SPID, StartTime, ElapsedTime, UserName, ProgramName, DatabaseName, ExecutingSQL, WaitType)SELECT 
    (SELECT @@SERVERNAME) AS InstanceName,
    r.session_id AS SPID,
    r.start_time AS StartTime,
    CONVERT(VARCHAR, DATEADD(ms, r.total_elapsed_time, 0), 8) AS ElapsedTime,
    c.login_name AS UserName,
    c.program_name AS ProgramName,
    DB_NAME(r.database_id) AS DatabaseName,
    LEFT(t.[text], 500) AS ExecutingSQL,
    r.wait_type AS WaitType
FROM 
    sys.dm_exec_requests r
    INNER JOIN sys.dm_exec_sessions c ON r.session_id = c.session_id
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
WHERE (r.wait_type NOT LIKE 'SP_SERVER_DIAGNOSTICS%' or r.wait_type is not null)
    AND r.session_id != @@SPID
    AND r.session_id > 50
    AND t.[text] <> 'null'
    AND DB_NAME(r.database_id) not in ('distribution','msdb','model','master')
    AND t.[text] <> 'begin tran'
	and t.[text] not like '%ALTER INDEX%'
	and t.[text] not like 'UPDATE STATISTICS%'  and t.[text] not like'%CREATE PROCEDURE sp_readrequest%'
	and t.[text] not like 'BACKUP%'
	AND r.total_elapsed_time / 60000 >= 60 -- Filter queries longer than 30 minute ;
	AND c.status <> 'sleeping'; 

-- Step 3: Generate the SPID list for termination
DECLARE @SPIDList NVARCHAR(MAX);

SET @SPIDList = 
   STUFF((
        SELECT ', ' + CAST(SPID AS NVARCHAR)
        FROM dbadb..longqrydetails  where datediff(HOUR,logdate,getdate())<=2  and SPID not in (select SPID from #longqrydetails) and is_closed=0  --Update 1
		 group by SPID
           FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)')
    , 1, 2, ''); -- Remove the leading comma and space

-- Step 4: Generate HTML content from the temporary table



DECLARE @HTML NVARCHAR(MAX);
DECLARE @ServerName NVARCHAR(128);
SET @ServerName = (Select @@SERVERNAME);

DECLARE @Subject NVARCHAR(256);
set @Subject='Thyrocare '+@ServerName +' -Long Running Queries:Closed'

SET @HTML = 
    '<html>' +
    '<head>' +
    '<style>' +
    'body { font-family: Arial, sans-serif; color: #333; line-height: 1.6; }' +
    'table { width: 100%; border-collapse: collapse; margin-top: 20px; }' +
    'table, th, td { border: 1px solid #ddd; }' +
    'th, td { padding: 12px; text-align: left; }' +
    'th { background-color: #4169E1; color: #C0C0C0; }' +
    '</style>' +
    '</head>' +
    '<body>' +
    '<p>Hello Team,</p>' +
    '<p>We have recently identified and reviewed several long-running queries on <b>'+@ServerName+'</b> that were consuming substantial resources.</p>
<p> I wanted to provide you with an update on the status of these queries.</p>
<p>Below is a summary of the long-running queries that have been addressed:</p>
<p>The following queries have either been executed successfully or terminated:</p>' +
		'<p> Query ID: <b>' + ISNULL(@SPIDList, 'No SPIDs available') + '</b> .</p>' +
'<p>These actions were taken as part of our ongoing performance optimization efforts, and the corresponding SPIDs have been closed.</p>'+
'<p>  Details of Closed Queries:</p>' +
    
    '<table>' +
    '<tr>' +
    '<th>SPID</th>' +
    '<th>Start Time</th>' +
    '<th>Elapsed Time (hh:mm:ss)</th>' +
    '<th>User</th>' +
    '<th>Database</th>' +
    '<th>SQL Text</th>' +
    '<th>Wait Type</th>' +
	'<th>StoredProcedure</th>' +
    '</tr>' +
    '</thead>' +
    '<tbody>' +
    (SELECT 
        '<tr>' +
        '<td>' + ISNULL(CAST(SPID AS NVARCHAR(MAX)), '') + '</td>' +
        '<td>' + ISNULL(CONVERT(varchar, StartTime, 120), '') + '</td>' +
        '<td>' + ISNULL(max(ElapsedTime), '') + '</td>' +
        '<td>' + ISNULL(UserName, '') + '</td>' +
        '<td>' + ISNULL(DatabaseName, '') + '</td>' +
        '<td>' + ISNULL(LEFT(StatementText, 250), '') + '</td>' +
        '<td>' + ISNULL(WaitType, '') + '</td>' +
		'<td>' + ISNULL(StoredProcedure, 'Query') + '</td>' +

        '</tr>'
    FROM dbadb..longqrydetails where  datediff(HOUR,logdate,getdate())<=2 and SPID not in (select SPID from #longqrydetails) and is_closed=0 --Update 2
  group by SPID ,StartTime,UserName,DatabaseName,LEFT(StatementText, 250),WaitType, StoredProcedure,ElapsedTime
  order by ElapsedTime desc
    FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)') +
    '</table>' +
   
    '<p>Thanks for your consideration.</p>' +
    '<p>Best regards,<br>MSSQL DBA,<br/>GeoPITS</p>' +
    '</body>' +
    '</html>';

	update  dbadb..longqrydetails set  is_closed=1  where datediff(HOUR,logdate,getdate())<=2 and SPID not in (select SPID from #longqrydetails) and is_closed=0  ; --Update 3

	drop table #longqrydetails


	-- Output the final HTML
--SELECT @HTML AS HTML;
if(@HTML is not null)
BEGIN
EXEC msdb.dbo.Sp_send_dbmail
@profile_name = 'DBA',
@body = @HTML,
@body_format ='html',
@recipients = 'mssqlalerts@geopits.com',
--@copy_recipients ='',
@blind_copy_recipients='',
@subject = @Subject;
END

  SET NOCOUNT OFF;
END

  SET ANSI_NULLS Off
GO

/****** Object:  StoredProcedure [dbo].[DBA_Identity_Health_Monitor_And_Alert]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[DBA_Identity_Health_Monitor_And_Alert]
AS
BEGIN
    SET NOCOUNT ON;

    /* ===============================
       CONFIG
    =============================== */
    DECLARE @WARNING_PCT  DECIMAL(5,2) = 70.0;
    DECLARE @CRITICAL_PCT DECIMAL(5,2) = 85.0;

    DECLARE @RECIPIENTS NVARCHAR(MAX) =
        'ASWIN.KUMARVPKOTHURU@THYROCARE.COM;SIVARAMAKRISHNAN.A@THYROCARE.COM;DB@THYROCARE.COM';

    /* ===============================
       STEP 1 : CAPTURE IDENTITY HEALTH
    =============================== */
    DECLARE @SQL NVARCHAR(MAX) = N'';

    SELECT @SQL += '
    USE ' + QUOTENAME(NAME) + ';
    INSERT INTO DBADB.dbo.IDENTITY_HEALTH_HISTORY
    (
        SERVER_NAME,
        DATABASE_NAME,
        SCHEMA_NAME,
        TABLE_NAME,
        IDENTITY_COLUMN,
        DATA_TYPE,
        CURRENT_IDENTITY,
        INCREMENT_BY,
        MAX_ALLOWED,
        REMAINING_TO_MAX,
        PCT_USED,
        ALERT_LEVEL
    )
    SELECT
        @@SERVERNAME,
        DB_NAME(),
        S.NAME,
        T.NAME,
        C.NAME,
        TY.NAME,
        CAST(IDENT_CURRENT(QUOTENAME(S.NAME)+''.''+QUOTENAME(T.NAME)) AS DECIMAL(38,0)),
        IDENT_INCR(QUOTENAME(S.NAME)+''.''+QUOTENAME(T.NAME)),
        MAX_VALS.MAX_ALLOWED,
        MAX_VALS.MAX_ALLOWED -
            CAST(IDENT_CURRENT(QUOTENAME(S.NAME)+''.''+QUOTENAME(T.NAME)) AS DECIMAL(38,0)),
        CAST(
            (
                CAST(IDENT_CURRENT(QUOTENAME(S.NAME)+''.''+QUOTENAME(T.NAME)) AS DECIMAL(38,6))
                / MAX_VALS.MAX_ALLOWED
            ) * 100
        AS DECIMAL(9,4)),
        CASE
            WHEN (
                (
                    CAST(IDENT_CURRENT(QUOTENAME(S.NAME)+''.''+QUOTENAME(T.NAME)) AS DECIMAL(38,6))
                    / MAX_VALS.MAX_ALLOWED
                ) * 100
            ) >= ' + CAST(@CRITICAL_PCT AS VARCHAR(10)) + ' THEN ''CRITICAL''
            WHEN (
                (
                    CAST(IDENT_CURRENT(QUOTENAME(S.NAME)+''.''+QUOTENAME(T.NAME)) AS DECIMAL(38,6))
                    / MAX_VALS.MAX_ALLOWED
                ) * 100
            ) >= ' + CAST(@WARNING_PCT AS VARCHAR(10)) + ' THEN ''WARNING''
            ELSE ''OK''
        END
    FROM sys.tables T
    JOIN sys.schemas S ON S.schema_id = T.schema_id
    JOIN sys.columns C ON C.object_id = T.object_id
    JOIN sys.types TY ON TY.user_type_id = C.user_type_id
    CROSS APPLY
    (
        SELECT CASE TY.name
            WHEN ''TINYINT''  THEN CAST(255 AS DECIMAL(38,6))
            WHEN ''SMALLINT'' THEN CAST(32767 AS DECIMAL(38,6))
            WHEN ''INT''      THEN CAST(2147483647 AS DECIMAL(38,6))
            WHEN ''BIGINT''   THEN CAST(9223372036854775807 AS DECIMAL(38,6))
        END
    ) MAX_VALS(MAX_ALLOWED)
    WHERE C.is_identity = 1
      AND TY.name IN (''TINYINT'',''SMALLINT'',''INT'',''BIGINT'');
    '
    FROM sys.databases
    WHERE database_id > 4
      AND state_desc = 'ONLINE';

    EXEC sys.sp_executesql @SQL;

    /* ===============================
       STEP 2 : CHECK ALERT
    =============================== */
    IF NOT EXISTS
    (
        SELECT 1
        FROM DBADB.dbo.IDENTITY_HEALTH_HISTORY
        WHERE CAPTURE_TIME >= DATEADD(MINUTE, -5, SYSDATETIME())
          AND ALERT_LEVEL IN ('WARNING','CRITICAL')
    )
        RETURN;

    /* ===============================
       STEP 3 : BUILD EMAIL
    =============================== */
    DECLARE @BODY NVARCHAR(MAX);

    SET @BODY = '
<html>
<body style="font-family:Arial; background-color:#f4f6f8; padding:15px;">

<table width="100%" cellpadding="0" cellspacing="0"
       style="background:#ffffff; border:1px solid #dcdcdc;">

<tr>
<td style="background:#b71c1c; color:white; padding:12px;
           font-size:18px; font-weight:bold; text-align:center;">
IDENTITY COLUMN ALERT
</td>
</tr>

<tr>
<td style="padding:10px; font-size:13px;">
<b>Generated Time:</b> ' + CONVERT(VARCHAR(19), SYSDATETIME(), 120) + '<br/>
<b>Monitoring:</b> SQL Server Identity Column Health
</td>
</tr>

<tr>
<td style="padding-left:10px;">
<span style="
    background:#b71c1c;
    color:white;
    padding:4px 10px;
    font-size:12px;
    font-weight:bold;
">
CRITICAL ALERT
</span>
</td>
</tr>

<tr>
<td style="padding:10px;">
<table width="100%" cellpadding="6" cellspacing="0"
       style="border:1px solid #ddd; background:#fafafa;">
<tr>
<td style="font-size:13px;">
<b>Affected Tables:</b> 1<br/>
<b>Highest Usage:</b> 100%
</td>
</tr>
</table>
</td>
</tr>

<tr>
<td style="padding:10px;">

<table width="100%" cellpadding="5" cellspacing="0"
       style="border-collapse:collapse; font-size:12px;">

<tr style="background:#424242; color:white;">
<th style="border:1px solid #ccc;">Server</th>
<th style="border:1px solid #ccc;">Capture Time</th>
<th style="border:1px solid #ccc;">Database</th>
<th style="border:1px solid #ccc;">Schema</th>
<th style="border:1px solid #ccc;">Table</th>
<th style="border:1px solid #ccc;">Column</th>
<th style="border:1px solid #ccc;">Type</th>
<th style="border:1px solid #ccc;">Current</th>
<th style="border:1px solid #ccc;">Max</th>
<th style="border:1px solid #ccc;">% Used</th>
<th style="border:1px solid #ccc;">Status</th>
</tr>';

    SELECT @BODY = @BODY +
    '<tr style="background:#fdecea; font-weight:bold;">
    <td style="border:1px solid #ccc;">' + SERVER_NAME + '</td>
    <td style="border:1px solid #ccc;">' + CONVERT(VARCHAR(19), CAPTURE_TIME, 120) + '</td>
    <td style="border:1px solid #ccc;">' + DATABASE_NAME + '</td>
    <td style="border:1px solid #ccc;">' + SCHEMA_NAME + '</td>
    <td style="border:1px solid #ccc;">' + TABLE_NAME + '</td>
    <td style="border:1px solid #ccc;">' + IDENTITY_COLUMN + '</td>
    <td style="border:1px solid #ccc;">' + DATA_TYPE + '</td>
    <td style="border:1px solid #ccc;">' + CAST(CURRENT_IDENTITY AS VARCHAR(30)) + '</td>
    <td style="border:1px solid #ccc;">' + CAST(MAX_ALLOWED AS VARCHAR(30)) + '</td>
    <td style="border:1px solid #ccc;">' + CAST(PCT_USED AS VARCHAR(20)) + '</td>
    <td style="border:1px solid #ccc; color:white; background:#d32f2f;">
        CRITICAL
    </td>
</tr>'
    FROM
    (
        SELECT *
        FROM
        (
            SELECT *,
                   ROW_NUMBER() OVER
                   (
                       PARTITION BY
                           SERVER_NAME,
                           DATABASE_NAME,
                           SCHEMA_NAME,
                           TABLE_NAME,
                           IDENTITY_COLUMN
                       ORDER BY CAPTURE_TIME DESC
                   ) rn
            FROM DBADB.dbo.IDENTITY_HEALTH_HISTORY
            WHERE CAPTURE_TIME >= DATEADD(MINUTE, -30, SYSDATETIME())
              AND ALERT_LEVEL IN ('WARNING','CRITICAL')
        ) x
        WHERE rn = 1
    ) final;

    SET @BODY += '
</table>
</td>
</tr>

<tr>
<td style="padding:10px; font-size:11px; color:#555; text-align:center;">
This is an automated DBA monitoring alert.<br/>
Please take immediate action for CRITICAL identity columns.
</td>
</tr>

</table>
</body>
</html>';

    /* ===============================
       STEP 4 : SEND MAIL
    =============================== */
    EXEC msdb.dbo.sp_send_dbmail
        @profile_name = 'DBA',
        @recipients   = @RECIPIENTS,
        @subject      = 'IDENTITY COLUMN ALERT - WARNING / CRITICAL - PROD CHARBI SERVER',
        @body         = @BODY,
        @body_format  = 'HTML';
END;
GO

/****** Object:  StoredProcedure [dbo].[DBAUnusedIndexReport]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE     PROCEDURE [dbo].[DBAUnusedIndexReport]
    @subjectcontent NVARCHAR(512),
    @ServerName NVARCHAR(512),
    @Recipient NVARCHAR(MAX),
    @DBProfile NVARCHAR(512)
AS
BEGIN
    BEGIN TRY
        IF 1 = (SELECT COUNT(*) FROM sys.dm_os_sys_info WHERE DATEDIFF(day, sqlserver_start_time, GETDATE()) > 7)
        BEGIN
            -- Create a table in DBADB to store the results if it doesn't exist
            IF NOT EXISTS (SELECT * FROM DBADB.sys.tables WHERE name = 'UnusedIndexes')
            BEGIN
                EXEC('
                CREATE TABLE DBADB.dbo.UnusedIndexes (
                    DatabaseName NVARCHAR(128),
                    ObjectName NVARCHAR(128),
                    IndexName NVARCHAR(128),
                    IndexID INT,
                    UserSeek BIGINT,
                    UserScans BIGINT,
                    UserLookups BIGINT,
                    UserUpdates BIGINT,
                    TableRows BIGINT,
                    DropStatement NVARCHAR(MAX),
                    Logdate DATETIME DEFAULT GETDATE()
                )');
            END

            -- Create a temporary table to store the results
            CREATE TABLE #UnusedIndexes (
                DatabaseName NVARCHAR(128),
                ObjectName NVARCHAR(128),
                IndexName NVARCHAR(128),
                IndexID INT,
                UserSeek BIGINT,
                UserScans BIGINT,
                UserLookups BIGINT,
                UserUpdates BIGINT,
                TableRows BIGINT,
                DropStatement NVARCHAR(MAX)
            );

            -- Collect unused indexes from all user databases
            DECLARE @sql NVARCHAR(MAX);
            SET @sql = N'
            DECLARE @dbName NVARCHAR(128);
            DECLARE dbCursor CURSOR FOR
            SELECT name FROM sys.databases WHERE database_id > 4 AND database_id <> DB_ID(''DBADB''); -- Exclude system databases

            OPEN dbCursor;
            FETCH NEXT FROM dbCursor INTO @dbName;

            WHILE @@FETCH_STATUS = 0
            BEGIN
                DECLARE @dynamicSQL NVARCHAR(MAX) = N''
                USE '' + QUOTENAME(@dbName) + N'';
                INSERT INTO #UnusedIndexes
                SELECT
                    @dbName AS DatabaseName,
                    o.name AS ObjectName,
                    i.name AS IndexName,
                    i.index_id AS IndexID,
                    dm_ius.user_seeks AS UserSeek,
                    dm_ius.user_scans AS UserScans,
                    dm_ius.user_lookups AS UserLookups,
                    dm_ius.user_updates AS UserUpdates,
                    p.TableRows,
                    ''''DROP INDEX '''' + QUOTENAME(i.name) + '''' ON '''' + QUOTENAME(s.name) + ''''.'''' + QUOTENAME(OBJECT_NAME(dm_ius.OBJECT_ID)) AS DropStatement
                FROM sys.dm_db_index_usage_stats dm_ius
                INNER JOIN sys.indexes i ON i.index_id = dm_ius.index_id AND dm_ius.OBJECT_ID = i.OBJECT_ID
                INNER JOIN sys.objects o ON dm_ius.OBJECT_ID = o.OBJECT_ID
                INNER JOIN sys.schemas s ON o.schema_id = s.schema_id
                INNER JOIN (SELECT SUM(p.rows) TableRows, p.index_id, p.OBJECT_ID
                            FROM sys.partitions p GROUP BY p.index_id, p.OBJECT_ID) p
                ON p.index_id = dm_ius.index_id AND dm_ius.OBJECT_ID = p.OBJECT_ID
                WHERE OBJECTPROPERTY(dm_ius.OBJECT_ID, ''''IsUserTable'''') = 1
                AND i.type_desc = ''''nonclustered''''
                AND i.is_primary_key = 0
                AND i.is_unique_constraint = 0
                AND (dm_ius.user_seeks + dm_ius.user_scans + dm_ius.user_lookups) = 0;
                '';

                EXEC sp_executesql @dynamicSQL, N''@dbName NVARCHAR(128)'', @dbName;

                FETCH NEXT FROM dbCursor INTO @dbName;
            END

            CLOSE dbCursor;
            DEALLOCATE dbCursor;
            ';

            EXEC sp_executesql @sql;

            -- Insert the results into the DBADB.UnusedIndexes table
            INSERT INTO DBADB.dbo.UnusedIndexes ([DatabaseName]
              ,[ObjectName]
              ,[IndexName]
              ,[IndexID]
              ,[UserSeek]
              ,[UserScans]
              ,[UserLookups]
              ,[UserUpdates]
              ,[TableRows]
              ,[DropStatement])
            SELECT * FROM #UnusedIndexes;

            -- Compare with previous data and delete old data
            DELETE FROM DBADB.dbo.UnusedIndexes
            WHERE Logdate < DATEADD(day, -30, GETDATE());

            -- Get the total number of unused indexes
            DECLARE @TotalUnusedIndexes INT;
            SELECT @TotalUnusedIndexes = COUNT(*) FROM DBADB.dbo.UnusedIndexes WHERE DATEDIFF(MINUTE, logdate, GETDATE()) < 1;

            -- Get the unused index counts for yesterday and a week before
            DECLARE @YesterdayUnusedIndexes TABLE (DatabaseName NVARCHAR(128), UnusedIndexCount INT);
            DECLARE @WeekBeforeUnusedIndexes TABLE (DatabaseName NVARCHAR(128), UnusedIndexCount INT);

            INSERT INTO @YesterdayUnusedIndexes
            SELECT DatabaseName, COUNT(*) AS UnusedIndexCount
            FROM DBADB.dbo.UnusedIndexes
            WHERE cast(Logdate as date) >=  cast(DATEADD(day, -1, GETDATE()) as date) AND Logdate < cast(GETDATE() as date)
            GROUP BY DatabaseName;

            INSERT INTO @WeekBeforeUnusedIndexes
            SELECT DatabaseName, COUNT(*) AS UnusedIndexCount
            FROM DBADB.dbo.UnusedIndexes
            WHERE cast(Logdate as date) >=  cast(DATEADD(day, -7, GETDATE()) as date) AND Logdate < cast(GETDATE()-6 as date)
            GROUP BY DatabaseName;

            -- Drop the temporary table
            DROP TABLE #UnusedIndexes;

            -- Send email report
			 DECLARE @sqlserver_start_time1 DATETIME;
            SELECT @sqlserver_start_time1 = sqlserver_start_time FROM sys.dm_os_sys_info;
            DECLARE @EmailBody NVARCHAR(MAX);
            SET @EmailBody = '
<html>
<head>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: left;
        }
        th {
            background-color: #800000; /* Change this color as needed */
            color: white;
        }
        a {
            color: #1a73e8;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .note {
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>
<body>
    <p>Hi Team,</p>
    <p>We have identified total <strong>' + CAST(@TotalUnusedIndexes AS NVARCHAR(10)) + '</strong> unused indexes on the  <strong>' + @ServerName + '</strong> server.</p>
	<p>The ' + @ServerName + ' SQL Server start time is : <strong>' + CAST(@sqlserver_start_time1 AS NVARCHAR(30)) + '</strong>.</p>
    <p>Unused Index Details:</p>
	<table>
        <thead>
            <tr>
                <th>Database Name</th>
                <th>Number of Unused Indexes Today</th>
                <th>Unused Indexes Yesterday</th>
                <th>Unused Indexes a Week Ago</th>
            </tr>
			</thead>
        <tbody>' +
        (SELECT TOP 15
            '<tr>' +
            '<td>' + ISNULL(ui.DatabaseName, '') + '</td>' +
            '<td>' + CAST(ISNULL(COUNT(*), 0) AS NVARCHAR) + '</td>' +
            '<td>' + CAST(ISNULL(yi.UnusedIndexCount, 0) AS NVARCHAR) + '</td>' +
            '<td>' + CAST(ISNULL(wi.UnusedIndexCount, 0) AS NVARCHAR) + '</td>' +
            '</tr>'
        FROM [DBADB].[dbo].[UnusedIndexes] ui
        LEFT JOIN @YesterdayUnusedIndexes yi ON ui.DatabaseName = yi.DatabaseName
        LEFT JOIN @WeekBeforeUnusedIndexes wi ON ui.DatabaseName = wi.DatabaseName
        WHERE DATEDIFF(MINUTE, ui.logdate, GETDATE()) < 1
        GROUP BY ui.DatabaseName, yi.UnusedIndexCount, wi.UnusedIndexCount
        ORDER BY COUNT(*) DESC
        FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)') +
        '</tbody>
    </table>
    <p>If you would like us to review these unused indexes, please send an email to <a href="mailto:dcc@geopits.com">dcc@geopits.com</a>.</p>
    <p>We will analyze the indexes and provide you with our recommendations.</p>
    <p class="note"><strong>Note:</strong> If the database participates in High Availability and Disaster Recovery (HADR), we need to cross-check with other replicas before making any changes to unused indexes.</p>
    <p>Thank you,<br>Best Regards,<br>MSSQL DBA,<br>GeoPITS</br></p>
</body>
</html>';

            -- Send email notification
            EXEC msdb.dbo.sp_send_dbmail
                @profile_name = @DBProfile,
                @recipients = @Recipient,
                @subject = @subjectcontent,
                @body = @EmailBody,
                @body_format = 'HTML';
        END
        ELSE
        BEGIN
            DECLARE @sqlserver_start_time DATETIME;
            SELECT @sqlserver_start_time = sqlserver_start_time FROM sys.dm_os_sys_info;

            -- Send email notification
            DECLARE @EmailBody1 NVARCHAR(MAX);
            SET @EmailBody1 = '
<html>
<body>
    <p>Hi Team,</p>
    <p>The ' + @ServerName + ' SQL Server start time is less than 7 days: <strong>' + CAST(@sqlserver_start_time AS NVARCHAR(30)) + '</strong>.</p>
    <p>As a result, the unused index details may not be accurate. We recommend waiting until <strong>' + CAST(DATEADD(DAY, 7, @sqlserver_start_time) AS NVARCHAR(30)) + '</strong> for more reliable data.</p>
    <p>Thank you,<br>Best Regards,<br>MSSQL DBA,<br>GeoPITS<br></p>
</body>
</html>';

            -- Send email notification

			
            EXEC msdb.dbo.sp_send_dbmail
                @profile_name = @DBProfile,
                @recipients = @Recipient,
                @subject = @subjectcontent,
                @body = @EmailBody1,
                @body_format = 'HTML';
        END
    END TRY
    BEGIN CATCH
        -- Error handling
        DECLARE @ErrorMessage NVARCHAR(4000);
        DECLARE @ErrorSeverity INT;
        DECLARE @ErrorState INT;

        SELECT 
            @ErrorMessage = ERROR_MESSAGE(),
            @ErrorSeverity = ERROR_SEVERITY(),
            @ErrorState = ERROR_STATE();

        RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);
    END CATCH
END;
GO

/****** Object:  StoredProcedure [dbo].[DDLModificationAlert]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[DDLModificationAlert]
AS
BEGIN

SET NOCOUNT ON
DECLARE @tracepath NVARCHAR(260);

-- Specify the default trace directory path
SET @tracepath = (SELECT TOP 1 [path] FROM sys.traces WHERE is_default = 1);
SELECT DISTINCT
    TE.name AS EventName,
    CONVERT(datetimeoffset, StartTime) AS EventTime,
    DB_NAME(t.DatabaseID) AS DatabaseName,
    t.ObjectName AS ObjectName,
    t.ObjectType AS ObjectType,
    t.ObjectType AS ObjectTypeCode,
    t.ObjectType AS ObjectTypeDesc,
    t.HostName,
    t.ApplicationName,
    t.LoginName,
        t.Error
FROM    sys.fn_trace_gettable(@tracepath, default) T
INNER JOIN sys.trace_events TE ON T.EventClass = TE.trace_event_id
WHERE
te.trace_event_id IN (46, 47)
and t.DatabaseID > 4
and t.ObjectName NOT LIKE '#%'
--and t.ObjectType NOT IN (83, 88)
--and t.EventSubClass NOT IN (1, 2)
and t.IndexID is NULL
AND StartTime >= DATEADD(HOUR, -1, GETDATE()); 

SET NOCOUNT OFF
end
GO

/****** Object:  StoredProcedure [dbo].[DiskCorruption]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE [dbo].[DiskCorruption]
AS
BEGIN
SET NOCOUNT ON
declare @start varchar(50)
declare @end varchar(50)
declare @table table(logdate datetime, processinfo varchar(100), textmsg nvarchar(max))
select @start = convert(varchar, dateadd(hour, -6, GETDATE()), 20)
select @end = convert(varchar, dateadd(hour, 0, GETDATE()), 20)
insert into @table
EXEC master.dbo.xp_readerrorlog 0, 1, N'I/O Error', NULL, @start, @end, N'desc' 
select * from @table
SET NOCOUNT OFF
END
GO

/****** Object:  StoredProcedure [dbo].[DiskSpace]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[DiskSpace]
AS
BEGIN
SET NOCOUNT ON
SELECT volume_mount_point [drivename],
CAST(MIN((total_bytes+available_bytes) / 1024. / 1024 / 1024) AS NUMERIC(8,1)) [capacity(GB)],
CAST(MIN(available_bytes / 1024. / 1024 / 1024) AS NUMERIC(8,1)) [freespace(GB)],
CAST(((MIN(total_bytes+available_bytes))-(MIN(available_bytes)))*100/
(MIN(total_bytes+available_bytes)) AS NUMERIC(8,1)) [Used %]
FROM sys.master_files AS f 
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.file_id)
GROUP BY volume_mount_point;
SET NOCOUNT OFF
END
GO

/****** Object:  StoredProcedure [dbo].[IndexOptimize]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[IndexOptimize]

@Databases nvarchar(max) = NULL,
@FragmentationLow nvarchar(max) = NULL,
@FragmentationMedium nvarchar(max) = 'INDEX_REORGANIZE,INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE',
@FragmentationHigh nvarchar(max) = 'INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE',
@FragmentationLevel1 int = 5,
@FragmentationLevel2 int = 30,
@MinNumberOfPages int = 1000,
@MaxNumberOfPages int = NULL,
@SortInTempdb nvarchar(max) = 'N',
@MaxDOP int = NULL,
@FillFactor int = NULL,
@PadIndex nvarchar(max) = NULL,
@LOBCompaction nvarchar(max) = 'Y',
@UpdateStatistics nvarchar(max) = NULL,
@OnlyModifiedStatistics nvarchar(max) = 'N',
@StatisticsModificationLevel int = NULL,
@StatisticsSample int = NULL,
@StatisticsResample nvarchar(max) = 'N',
@PartitionLevel nvarchar(max) = 'Y',
@MSShippedObjects nvarchar(max) = 'N',
@Indexes nvarchar(max) = NULL,
@TimeLimit int = NULL,
@Delay int = NULL,
@WaitAtLowPriorityMaxDuration int = NULL,
@WaitAtLowPriorityAbortAfterWait nvarchar(max) = NULL,
@Resumable nvarchar(max) = 'N',
@AvailabilityGroups nvarchar(max) = NULL,
@LockTimeout int = NULL,
@LockMessageSeverity int = 16,
@StringDelimiter nvarchar(max) = ',',
@DatabaseOrder nvarchar(max) = NULL,
@DatabasesInParallel nvarchar(max) = 'N',
@ExecuteAsUser nvarchar(max) = NULL,
@LogToTable nvarchar(max) = 'N',
@Execute nvarchar(max) = 'Y'

AS

BEGIN

  ----------------------------------------------------------------------------------------------------
  --// Source:  https://ola.hallengren.com                                                        //--
  --// License: https://ola.hallengren.com/license.html                                           //--
  --// GitHub:  https://github.com/olahallengren/sql-server-maintenance-solution                  //--
  --// Version: 2022-12-03 17:23:44                                                               //--
  ----------------------------------------------------------------------------------------------------

  SET NOCOUNT ON

  SET ARITHABORT ON

  SET NUMERIC_ROUNDABORT OFF

  DECLARE @StartMessage nvarchar(max)
  DECLARE @EndMessage nvarchar(max)
  DECLARE @DatabaseMessage nvarchar(max)
  DECLARE @ErrorMessage nvarchar(max)
  DECLARE @Severity int

  DECLARE @StartTime datetime2 = SYSDATETIME()
  DECLARE @SchemaName nvarchar(max) = OBJECT_SCHEMA_NAME(@@PROCID)
  DECLARE @ObjectName nvarchar(max) = OBJECT_NAME(@@PROCID)
  DECLARE @VersionTimestamp nvarchar(max) = SUBSTRING(OBJECT_DEFINITION(@@PROCID),CHARINDEX('--// Version: ',OBJECT_DEFINITION(@@PROCID)) + LEN('--// Version: ') + 1, 19)
  DECLARE @Parameters nvarchar(max)

  DECLARE @HostPlatform nvarchar(max)

  DECLARE @PartitionLevelStatistics bit

  DECLARE @QueueID int
  DECLARE @QueueStartTime datetime2

  DECLARE @CurrentDBID int
  DECLARE @CurrentDatabaseName nvarchar(max)

  DECLARE @CurrentDatabase_sp_executesql nvarchar(max)

  DECLARE @CurrentExecuteAsUserExists bit
  DECLARE @CurrentUserAccess nvarchar(max)
  DECLARE @CurrentIsReadOnly bit
  DECLARE @CurrentDatabaseState nvarchar(max)
  DECLARE @CurrentInStandby bit
  DECLARE @CurrentRecoveryModel nvarchar(max)

  DECLARE @CurrentIsDatabaseAccessible bit
  DECLARE @CurrentReplicaID uniqueidentifier
  DECLARE @CurrentAvailabilityGroupID uniqueidentifier
  DECLARE @CurrentAvailabilityGroup nvarchar(max)
  DECLARE @CurrentAvailabilityGroupRole nvarchar(max)
  DECLARE @CurrentDatabaseMirroringRole nvarchar(max)

  DECLARE @CurrentDatabaseContext nvarchar(max)
  DECLARE @CurrentCommand nvarchar(max)
  DECLARE @CurrentCommandOutput int
  DECLARE @CurrentCommandType nvarchar(max)
  DECLARE @CurrentComment nvarchar(max)
  DECLARE @CurrentExtendedInfo xml

  DECLARE @Errors TABLE (ID int IDENTITY PRIMARY KEY,
                         [Message] nvarchar(max) NOT NULL,
                         Severity int NOT NULL,
                         [State] int)

  DECLARE @CurrentMessage nvarchar(max)
  DECLARE @CurrentSeverity int
  DECLARE @CurrentState int

  DECLARE @CurrentIxID int
  DECLARE @CurrentIxOrder int
  DECLARE @CurrentSchemaID int
  DECLARE @CurrentSchemaName nvarchar(max)
  DECLARE @CurrentObjectID int
  DECLARE @CurrentObjectName nvarchar(max)
  DECLARE @CurrentObjectType nvarchar(max)
  DECLARE @CurrentIsMemoryOptimized bit
  DECLARE @CurrentIndexID int
  DECLARE @CurrentIndexName nvarchar(max)
  DECLARE @CurrentIndexType int
  DECLARE @CurrentStatisticsID int
  DECLARE @CurrentStatisticsName nvarchar(max)
  DECLARE @CurrentPartitionID bigint
  DECLARE @CurrentPartitionNumber int
  DECLARE @CurrentPartitionCount int
  DECLARE @CurrentIsPartition bit
  DECLARE @CurrentIndexExists bit
  DECLARE @CurrentStatisticsExists bit
  DECLARE @CurrentIsImageText bit
  DECLARE @CurrentIsNewLOB bit
  DECLARE @CurrentIsFileStream bit
  DECLARE @CurrentIsColumnStore bit
  DECLARE @CurrentIsComputed bit
  DECLARE @CurrentIsTimestamp bit
  DECLARE @CurrentAllowPageLocks bit
  DECLARE @CurrentNoRecompute bit
  DECLARE @CurrentIsIncremental bit
  DECLARE @CurrentRowCount bigint
  DECLARE @CurrentModificationCounter bigint
  DECLARE @CurrentOnReadOnlyFileGroup bit
  DECLARE @CurrentResumableIndexOperation bit
  DECLARE @CurrentFragmentationLevel float
  DECLARE @CurrentPageCount bigint
  DECLARE @CurrentFragmentationGroup nvarchar(max)
  DECLARE @CurrentAction nvarchar(max)
  DECLARE @CurrentMaxDOP int
  DECLARE @CurrentUpdateStatistics nvarchar(max)
  DECLARE @CurrentStatisticsSample int
  DECLARE @CurrentStatisticsResample nvarchar(max)
  DECLARE @CurrentDelay datetime

  DECLARE @tmpDatabases TABLE (ID int IDENTITY,
                               DatabaseName nvarchar(max),
                               DatabaseType nvarchar(max),
                               AvailabilityGroup bit,
                               StartPosition int,
                               DatabaseSize bigint,
                               [Order] int,
                               Selected bit,
                               Completed bit,
                               PRIMARY KEY(Selected, Completed, [Order], ID))

  DECLARE @tmpAvailabilityGroups TABLE (ID int IDENTITY PRIMARY KEY,
                                        AvailabilityGroupName nvarchar(max),
                                        StartPosition int,
                                        Selected bit)

  DECLARE @tmpDatabasesAvailabilityGroups TABLE (DatabaseName nvarchar(max),
                                                 AvailabilityGroupName nvarchar(max))

  DECLARE @tmpIndexesStatistics TABLE (ID int IDENTITY,
                                       SchemaID int,
                                       SchemaName nvarchar(max),
                                       ObjectID int,
                                       ObjectName nvarchar(max),
                                       ObjectType nvarchar(max),
                                       IsMemoryOptimized bit,
                                       IndexID int,
                                       IndexName nvarchar(max),
                                       IndexType int,
                                       AllowPageLocks bit,
                                       IsImageText bit,
                                       IsNewLOB bit,
                                       IsFileStream bit,
                                       IsColumnStore bit,
                                       IsComputed bit,
                                       IsTimestamp bit,
                                       OnReadOnlyFileGroup bit,
                                       ResumableIndexOperation bit,
                                       StatisticsID int,
                                       StatisticsName nvarchar(max),
                                       [NoRecompute] bit,
                                       IsIncremental bit,
                                       PartitionID bigint,
                                       PartitionNumber int,
                                       PartitionCount int,
                                       StartPosition int,
                                       [Order] int,
                                       Selected bit,
                                       Completed bit,
                                       PRIMARY KEY(Selected, Completed, [Order], ID))

  DECLARE @SelectedDatabases TABLE (DatabaseName nvarchar(max),
                                    DatabaseType nvarchar(max),
                                    AvailabilityGroup nvarchar(max),
                                    StartPosition int,
                                    Selected bit)

  DECLARE @SelectedAvailabilityGroups TABLE (AvailabilityGroupName nvarchar(max),
                                             StartPosition int,
                                             Selected bit)

  DECLARE @SelectedIndexes TABLE (DatabaseName nvarchar(max),
                                  SchemaName nvarchar(max),
                                  ObjectName nvarchar(max),
                                  IndexName nvarchar(max),
                                  StartPosition int,
                                  Selected bit)

  DECLARE @Actions TABLE ([Action] nvarchar(max))

  INSERT INTO @Actions([Action]) VALUES('INDEX_REBUILD_ONLINE')
  INSERT INTO @Actions([Action]) VALUES('INDEX_REBUILD_OFFLINE')
  INSERT INTO @Actions([Action]) VALUES('INDEX_REORGANIZE')

  DECLARE @ActionsPreferred TABLE (FragmentationGroup nvarchar(max),
                                   [Priority] int,
                                   [Action] nvarchar(max))

  DECLARE @CurrentActionsAllowed TABLE ([Action] nvarchar(max))

  DECLARE @CurrentAlterIndexWithClauseArguments TABLE (ID int IDENTITY,
                                                       Argument nvarchar(max),
                                                       Added bit DEFAULT 0)

  DECLARE @CurrentAlterIndexArgumentID int
  DECLARE @CurrentAlterIndexArgument nvarchar(max)
  DECLARE @CurrentAlterIndexWithClause nvarchar(max)

  DECLARE @CurrentUpdateStatisticsWithClauseArguments TABLE (ID int IDENTITY,
                                                             Argument nvarchar(max),
                                                             Added bit DEFAULT 0)

  DECLARE @CurrentUpdateStatisticsArgumentID int
  DECLARE @CurrentUpdateStatisticsArgument nvarchar(max)
  DECLARE @CurrentUpdateStatisticsWithClause nvarchar(max)

  DECLARE @Error int = 0
  DECLARE @ReturnCode int = 0

  DECLARE @EmptyLine nvarchar(max) = CHAR(9)

  DECLARE @Version numeric(18,10) = CAST(LEFT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)),CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - 1) + '.' + REPLACE(RIGHT(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)), LEN(CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))) - CHARINDEX('.',CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max)))),'.','') AS numeric(18,10))

  IF @Version >= 14
  BEGIN
    SELECT @HostPlatform = host_platform
    FROM sys.dm_os_host_info
  END
  ELSE
  BEGIN
    SET @HostPlatform = 'Windows'
  END

  DECLARE @AmazonRDS bit = CASE WHEN DB_ID('rdsadmin') IS NOT NULL AND SUSER_SNAME(0x01) = 'rdsa' THEN 1 ELSE 0 END

  ----------------------------------------------------------------------------------------------------
  --// Log initial information                                                                    //--
  ----------------------------------------------------------------------------------------------------

  SET @Parameters = '@Databases = ' + ISNULL('''' + REPLACE(@Databases,'''','''''') + '''','NULL')
  SET @Parameters += ', @FragmentationLow = ' + ISNULL('''' + REPLACE(@FragmentationLow,'''','''''') + '''','NULL')
  SET @Parameters += ', @FragmentationMedium = ' + ISNULL('''' + REPLACE(@FragmentationMedium,'''','''''') + '''','NULL')
  SET @Parameters += ', @FragmentationHigh = ' + ISNULL('''' + REPLACE(@FragmentationHigh,'''','''''') + '''','NULL')
  SET @Parameters += ', @FragmentationLevel1 = ' + ISNULL(CAST(@FragmentationLevel1 AS nvarchar),'NULL')
  SET @Parameters += ', @FragmentationLevel2 = ' + ISNULL(CAST(@FragmentationLevel2 AS nvarchar),'NULL')
  SET @Parameters += ', @MinNumberOfPages = ' + ISNULL(CAST(@MinNumberOfPages AS nvarchar),'NULL')
  SET @Parameters += ', @MaxNumberOfPages = ' + ISNULL(CAST(@MaxNumberOfPages AS nvarchar),'NULL')
  SET @Parameters += ', @SortInTempdb = ' + ISNULL('''' + REPLACE(@SortInTempdb,'''','''''') + '''','NULL')
  SET @Parameters += ', @MaxDOP = ' + ISNULL(CAST(@MaxDOP AS nvarchar),'NULL')
  SET @Parameters += ', @FillFactor = ' + ISNULL(CAST(@FillFactor AS nvarchar),'NULL')
  SET @Parameters += ', @PadIndex = ' + ISNULL('''' + REPLACE(@PadIndex,'''','''''') + '''','NULL')
  SET @Parameters += ', @LOBCompaction = ' + ISNULL('''' + REPLACE(@LOBCompaction,'''','''''') + '''','NULL')
  SET @Parameters += ', @UpdateStatistics = ' + ISNULL('''' + REPLACE(@UpdateStatistics,'''','''''') + '''','NULL')
  SET @Parameters += ', @OnlyModifiedStatistics = ' + ISNULL('''' + REPLACE(@OnlyModifiedStatistics,'''','''''') + '''','NULL')
  SET @Parameters += ', @StatisticsModificationLevel = ' + ISNULL(CAST(@StatisticsModificationLevel AS nvarchar),'NULL')
  SET @Parameters += ', @StatisticsSample = ' + ISNULL(CAST(@StatisticsSample AS nvarchar),'NULL')
  SET @Parameters += ', @StatisticsResample = ' + ISNULL('''' + REPLACE(@StatisticsResample,'''','''''') + '''','NULL')
  SET @Parameters += ', @PartitionLevel = ' + ISNULL('''' + REPLACE(@PartitionLevel,'''','''''') + '''','NULL')
  SET @Parameters += ', @MSShippedObjects = ' + ISNULL('''' + REPLACE(@MSShippedObjects,'''','''''') + '''','NULL')
  SET @Parameters += ', @Indexes = ' + ISNULL('''' + REPLACE(@Indexes,'''','''''') + '''','NULL')
  SET @Parameters += ', @TimeLimit = ' + ISNULL(CAST(@TimeLimit AS nvarchar),'NULL')
  SET @Parameters += ', @Delay = ' + ISNULL(CAST(@Delay AS nvarchar),'NULL')
  SET @Parameters += ', @WaitAtLowPriorityMaxDuration = ' + ISNULL(CAST(@WaitAtLowPriorityMaxDuration AS nvarchar),'NULL')
  SET @Parameters += ', @WaitAtLowPriorityAbortAfterWait = ' + ISNULL('''' + REPLACE(@WaitAtLowPriorityAbortAfterWait,'''','''''') + '''','NULL')
  SET @Parameters += ', @Resumable = ' + ISNULL('''' + REPLACE(@Resumable,'''','''''') + '''','NULL')
  SET @Parameters += ', @AvailabilityGroups = ' + ISNULL('''' + REPLACE(@AvailabilityGroups,'''','''''') + '''','NULL')
  SET @Parameters += ', @LockTimeout = ' + ISNULL(CAST(@LockTimeout AS nvarchar),'NULL')
  SET @Parameters += ', @LockMessageSeverity = ' + ISNULL(CAST(@LockMessageSeverity AS nvarchar),'NULL')
  SET @Parameters += ', @StringDelimiter = ' + ISNULL('''' + REPLACE(@StringDelimiter,'''','''''') + '''','NULL')
  SET @Parameters += ', @DatabaseOrder = ' + ISNULL('''' + REPLACE(@DatabaseOrder,'''','''''') + '''','NULL')
  SET @Parameters += ', @DatabasesInParallel = ' + ISNULL('''' + REPLACE(@DatabasesInParallel,'''','''''') + '''','NULL')
  SET @Parameters += ', @ExecuteAsUser = ' + ISNULL('''' + REPLACE(@ExecuteAsUser,'''','''''') + '''','NULL')
  SET @Parameters += ', @LogToTable = ' + ISNULL('''' + REPLACE(@LogToTable,'''','''''') + '''','NULL')
  SET @Parameters += ', @Execute = ' + ISNULL('''' + REPLACE(@Execute,'''','''''') + '''','NULL')

  SET @StartMessage = 'Date and time: ' + CONVERT(nvarchar,@StartTime,120)
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Server: ' + CAST(SERVERPROPERTY('ServerName') AS nvarchar(max))
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Version: ' + CAST(SERVERPROPERTY('ProductVersion') AS nvarchar(max))
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Edition: ' + CAST(SERVERPROPERTY('Edition') AS nvarchar(max))
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Platform: ' + @HostPlatform
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Procedure: ' + QUOTENAME(DB_NAME(DB_ID())) + '.' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@ObjectName)
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Parameters: ' + @Parameters
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Version: ' + @VersionTimestamp
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  SET @StartMessage = 'Source: https://ola.hallengren.com'
  RAISERROR('%s',10,1,@StartMessage) WITH NOWAIT

  RAISERROR(@EmptyLine,10,1) WITH NOWAIT

  ----------------------------------------------------------------------------------------------------
  --// Check core requirements                                                                    //--
  ----------------------------------------------------------------------------------------------------

  IF NOT (SELECT [compatibility_level] FROM sys.databases WHERE database_id = DB_ID()) >= 90
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The database ' + QUOTENAME(DB_NAME(DB_ID())) + ' has to be in compatibility level 90 or higher.', 16, 1
  END

  IF NOT (SELECT uses_ansi_nulls FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'ANSI_NULLS has to be set to ON for the stored procedure.', 16, 1
  END

  IF NOT (SELECT uses_quoted_identifier FROM sys.sql_modules WHERE [object_id] = @@PROCID) = 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'QUOTED_IDENTIFIER has to be set to ON for the stored procedure.', 16, 1
  END

  IF NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The stored procedure CommandExecute is missing. Download https://ola.hallengren.com/scripts/CommandExecute.sql.', 16, 1
  END

  IF EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'P' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandExecute' AND OBJECT_DEFINITION(objects.[object_id]) NOT LIKE '%@DatabaseContext%')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The stored procedure CommandExecute needs to be updated. Download https://ola.hallengren.com/scripts/CommandExecute.sql.', 16, 1
  END

  IF @LogToTable = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'CommandLog')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The table CommandLog is missing. Download https://ola.hallengren.com/scripts/CommandLog.sql.', 16, 1
  END

  IF @DatabasesInParallel = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'Queue')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The table Queue is missing. Download https://ola.hallengren.com/scripts/Queue.sql.', 16, 1
  END

  IF @DatabasesInParallel = 'Y' AND NOT EXISTS (SELECT * FROM sys.objects objects INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] = 'U' AND schemas.[name] = 'dbo' AND objects.[name] = 'QueueDatabase')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The table QueueDatabase is missing. Download https://ola.hallengren.com/scripts/QueueDatabase.sql.', 16, 1
  END

  IF @@TRANCOUNT <> 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The transaction count is not 0.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Select databases                                                                           //--
  ----------------------------------------------------------------------------------------------------

  SET @Databases = REPLACE(@Databases, CHAR(10), '')
  SET @Databases = REPLACE(@Databases, CHAR(13), '')

  WHILE CHARINDEX(@StringDelimiter + ' ', @Databases) > 0 SET @Databases = REPLACE(@Databases, @StringDelimiter + ' ', @StringDelimiter)
  WHILE CHARINDEX(' ' + @StringDelimiter, @Databases) > 0 SET @Databases = REPLACE(@Databases, ' ' + @StringDelimiter, @StringDelimiter)

  SET @Databases = LTRIM(RTRIM(@Databases));

  WITH Databases1 (StartPosition, EndPosition, DatabaseItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, 1), 0), LEN(@Databases) + 1) - 1) AS DatabaseItem
  WHERE @Databases IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) AS EndPosition,
         SUBSTRING(@Databases, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Databases, EndPosition + 1), 0), LEN(@Databases) + 1) - EndPosition - 1) AS DatabaseItem
  FROM Databases1
  WHERE EndPosition < LEN(@Databases) + 1
  ),
  Databases2 (DatabaseItem, StartPosition, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem LIKE '-%' THEN RIGHT(DatabaseItem,LEN(DatabaseItem) - 1) ELSE DatabaseItem END AS DatabaseItem,
         StartPosition,
         CASE WHEN DatabaseItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM Databases1
  ),
  Databases3 (DatabaseItem, DatabaseType, AvailabilityGroup, StartPosition, Selected) AS
  (
  SELECT CASE WHEN DatabaseItem IN('ALL_DATABASES','SYSTEM_DATABASES','USER_DATABASES','AVAILABILITY_GROUP_DATABASES') THEN '%' ELSE DatabaseItem END AS DatabaseItem,
         CASE WHEN DatabaseItem = 'SYSTEM_DATABASES' THEN 'S' WHEN DatabaseItem = 'USER_DATABASES' THEN 'U' ELSE NULL END AS DatabaseType,
         CASE WHEN DatabaseItem = 'AVAILABILITY_GROUP_DATABASES' THEN 1 ELSE NULL END AvailabilityGroup,
         StartPosition,
         Selected
  FROM Databases2
  ),
  Databases4 (DatabaseName, DatabaseType, AvailabilityGroup, StartPosition, Selected) AS
  (
  SELECT CASE WHEN LEFT(DatabaseItem,1) = '[' AND RIGHT(DatabaseItem,1) = ']' THEN PARSENAME(DatabaseItem,1) ELSE DatabaseItem END AS DatabaseItem,
         DatabaseType,
         AvailabilityGroup,
         StartPosition,
         Selected
  FROM Databases3
  )
  INSERT INTO @SelectedDatabases (DatabaseName, DatabaseType, AvailabilityGroup, StartPosition, Selected)
  SELECT DatabaseName,
         DatabaseType,
         AvailabilityGroup,
         StartPosition,
         Selected
  FROM Databases4
  OPTION (MAXRECURSION 0)

  IF @Version >= 11 AND SERVERPROPERTY('IsHadrEnabled') = 1
  BEGIN
    INSERT INTO @tmpAvailabilityGroups (AvailabilityGroupName, Selected)
    SELECT name AS AvailabilityGroupName,
           0 AS Selected
    FROM sys.availability_groups

    INSERT INTO @tmpDatabasesAvailabilityGroups (DatabaseName, AvailabilityGroupName)
    SELECT databases.name,
           availability_groups.name
    FROM sys.databases databases
    INNER JOIN sys.availability_replicas availability_replicas ON databases.replica_id = availability_replicas.replica_id
    INNER JOIN sys.availability_groups availability_groups ON availability_replicas.group_id = availability_groups.group_id
  END

  INSERT INTO @tmpDatabases (DatabaseName, DatabaseType, AvailabilityGroup, [Order], Selected, Completed)
  SELECT [name] AS DatabaseName,
         CASE WHEN name IN('master','msdb','model') OR is_distributor = 1 THEN 'S' ELSE 'U' END AS DatabaseType,
         NULL AS AvailabilityGroup,
         0 AS [Order],
         0 AS Selected,
         0 AS Completed
  FROM sys.databases
  WHERE [name] <> 'tempdb'
  AND source_database_id IS NULL
  ORDER BY [name] ASC

  UPDATE tmpDatabases
  SET AvailabilityGroup = CASE WHEN EXISTS (SELECT * FROM @tmpDatabasesAvailabilityGroups WHERE DatabaseName = tmpDatabases.DatabaseName) THEN 1 ELSE 0 END
  FROM @tmpDatabases tmpDatabases

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)
  WHERE SelectedDatabases.Selected = 1

  UPDATE tmpDatabases
  SET tmpDatabases.Selected = SelectedDatabases.Selected
  FROM @tmpDatabases tmpDatabases
  INNER JOIN @SelectedDatabases SelectedDatabases
  ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
  AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
  AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)
  WHERE SelectedDatabases.Selected = 0

  UPDATE tmpDatabases
  SET tmpDatabases.StartPosition = SelectedDatabases2.StartPosition
  FROM @tmpDatabases tmpDatabases
  INNER JOIN (SELECT tmpDatabases.DatabaseName, MIN(SelectedDatabases.StartPosition) AS StartPosition
              FROM @tmpDatabases tmpDatabases
              INNER JOIN @SelectedDatabases SelectedDatabases
              ON tmpDatabases.DatabaseName LIKE REPLACE(SelectedDatabases.DatabaseName,'_','[_]')
              AND (tmpDatabases.DatabaseType = SelectedDatabases.DatabaseType OR SelectedDatabases.DatabaseType IS NULL)
              AND (tmpDatabases.AvailabilityGroup = SelectedDatabases.AvailabilityGroup OR SelectedDatabases.AvailabilityGroup IS NULL)
              WHERE SelectedDatabases.Selected = 1
              GROUP BY tmpDatabases.DatabaseName) SelectedDatabases2
  ON tmpDatabases.DatabaseName = SelectedDatabases2.DatabaseName

  IF @Databases IS NOT NULL AND (NOT EXISTS(SELECT * FROM @SelectedDatabases) OR EXISTS(SELECT * FROM @SelectedDatabases WHERE DatabaseName IS NULL OR DatabaseName = ''))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Databases is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Select availability groups                                                                 //--
  ----------------------------------------------------------------------------------------------------

  IF @AvailabilityGroups IS NOT NULL AND @Version >= 11 AND SERVERPROPERTY('IsHadrEnabled') = 1
  BEGIN

    SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, CHAR(10), '')
    SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, CHAR(13), '')

    WHILE CHARINDEX(@StringDelimiter + ' ', @AvailabilityGroups) > 0 SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, @StringDelimiter + ' ', @StringDelimiter)
    WHILE CHARINDEX(' ' + @StringDelimiter, @AvailabilityGroups) > 0 SET @AvailabilityGroups = REPLACE(@AvailabilityGroups, ' ' + @StringDelimiter, @StringDelimiter)

    SET @AvailabilityGroups = LTRIM(RTRIM(@AvailabilityGroups));

    WITH AvailabilityGroups1 (StartPosition, EndPosition, AvailabilityGroupItem) AS
    (
    SELECT 1 AS StartPosition,
           ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, 1), 0), LEN(@AvailabilityGroups) + 1) AS EndPosition,
           SUBSTRING(@AvailabilityGroups, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, 1), 0), LEN(@AvailabilityGroups) + 1) - 1) AS AvailabilityGroupItem
    WHERE @AvailabilityGroups IS NOT NULL
    UNION ALL
    SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
           ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, EndPosition + 1), 0), LEN(@AvailabilityGroups) + 1) AS EndPosition,
           SUBSTRING(@AvailabilityGroups, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @AvailabilityGroups, EndPosition + 1), 0), LEN(@AvailabilityGroups) + 1) - EndPosition - 1) AS AvailabilityGroupItem
    FROM AvailabilityGroups1
    WHERE EndPosition < LEN(@AvailabilityGroups) + 1
    ),
    AvailabilityGroups2 (AvailabilityGroupItem, StartPosition, Selected) AS
    (
    SELECT CASE WHEN AvailabilityGroupItem LIKE '-%' THEN RIGHT(AvailabilityGroupItem,LEN(AvailabilityGroupItem) - 1) ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,
           StartPosition,
           CASE WHEN AvailabilityGroupItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
    FROM AvailabilityGroups1
    ),
    AvailabilityGroups3 (AvailabilityGroupItem, StartPosition, Selected) AS
    (
    SELECT CASE WHEN AvailabilityGroupItem = 'ALL_AVAILABILITY_GROUPS' THEN '%' ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,
           StartPosition,
           Selected
    FROM AvailabilityGroups2
    ),
    AvailabilityGroups4 (AvailabilityGroupName, StartPosition, Selected) AS
    (
    SELECT CASE WHEN LEFT(AvailabilityGroupItem,1) = '[' AND RIGHT(AvailabilityGroupItem,1) = ']' THEN PARSENAME(AvailabilityGroupItem,1) ELSE AvailabilityGroupItem END AS AvailabilityGroupItem,
           StartPosition,
           Selected
    FROM AvailabilityGroups3
    )
    INSERT INTO @SelectedAvailabilityGroups (AvailabilityGroupName, StartPosition, Selected)
    SELECT AvailabilityGroupName, StartPosition, Selected
    FROM AvailabilityGroups4
    OPTION (MAXRECURSION 0)

    UPDATE tmpAvailabilityGroups
    SET tmpAvailabilityGroups.Selected = SelectedAvailabilityGroups.Selected
    FROM @tmpAvailabilityGroups tmpAvailabilityGroups
    INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups
    ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,'_','[_]')
    WHERE SelectedAvailabilityGroups.Selected = 1

    UPDATE tmpAvailabilityGroups
    SET tmpAvailabilityGroups.Selected = SelectedAvailabilityGroups.Selected
    FROM @tmpAvailabilityGroups tmpAvailabilityGroups
    INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups
    ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,'_','[_]')
    WHERE SelectedAvailabilityGroups.Selected = 0

    UPDATE tmpAvailabilityGroups
    SET tmpAvailabilityGroups.StartPosition = SelectedAvailabilityGroups2.StartPosition
    FROM @tmpAvailabilityGroups tmpAvailabilityGroups
    INNER JOIN (SELECT tmpAvailabilityGroups.AvailabilityGroupName, MIN(SelectedAvailabilityGroups.StartPosition) AS StartPosition
                FROM @tmpAvailabilityGroups tmpAvailabilityGroups
                INNER JOIN @SelectedAvailabilityGroups SelectedAvailabilityGroups
                ON tmpAvailabilityGroups.AvailabilityGroupName LIKE REPLACE(SelectedAvailabilityGroups.AvailabilityGroupName,'_','[_]')
                WHERE SelectedAvailabilityGroups.Selected = 1
                GROUP BY tmpAvailabilityGroups.AvailabilityGroupName) SelectedAvailabilityGroups2
    ON tmpAvailabilityGroups.AvailabilityGroupName = SelectedAvailabilityGroups2.AvailabilityGroupName

    UPDATE tmpDatabases
    SET tmpDatabases.StartPosition = tmpAvailabilityGroups.StartPosition,
        tmpDatabases.Selected = 1
    FROM @tmpDatabases tmpDatabases
    INNER JOIN @tmpDatabasesAvailabilityGroups tmpDatabasesAvailabilityGroups ON tmpDatabases.DatabaseName = tmpDatabasesAvailabilityGroups.DatabaseName
    INNER JOIN @tmpAvailabilityGroups tmpAvailabilityGroups ON tmpDatabasesAvailabilityGroups.AvailabilityGroupName = tmpAvailabilityGroups.AvailabilityGroupName
    WHERE tmpAvailabilityGroups.Selected = 1

  END

  IF @AvailabilityGroups IS NOT NULL AND (NOT EXISTS(SELECT * FROM @SelectedAvailabilityGroups) OR EXISTS(SELECT * FROM @SelectedAvailabilityGroups WHERE AvailabilityGroupName IS NULL OR AvailabilityGroupName = '') OR @Version < 11 OR SERVERPROPERTY('IsHadrEnabled') = 0)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @AvailabilityGroups is not supported.', 16, 1
  END

  IF (@Databases IS NULL AND @AvailabilityGroups IS NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'You need to specify one of the parameters @Databases and @AvailabilityGroups.', 16, 2
  END

  IF (@Databases IS NOT NULL AND @AvailabilityGroups IS NOT NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'You can only specify one of the parameters @Databases and @AvailabilityGroups.', 16, 3
  END

  ----------------------------------------------------------------------------------------------------
  --// Select indexes                                                                             //--
  ----------------------------------------------------------------------------------------------------

  SET @Indexes = REPLACE(@Indexes, CHAR(10), '')
  SET @Indexes = REPLACE(@Indexes, CHAR(13), '')

  WHILE CHARINDEX(@StringDelimiter + ' ', @Indexes) > 0 SET @Indexes = REPLACE(@Indexes, @StringDelimiter + ' ', @StringDelimiter)
  WHILE CHARINDEX(' ' + @StringDelimiter, @Indexes) > 0 SET @Indexes = REPLACE(@Indexes, ' ' + @StringDelimiter, @StringDelimiter)

  SET @Indexes = LTRIM(RTRIM(@Indexes));

  WITH Indexes1 (StartPosition, EndPosition, IndexItem) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, 1), 0), LEN(@Indexes) + 1) AS EndPosition,
         SUBSTRING(@Indexes, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, 1), 0), LEN(@Indexes) + 1) - 1) AS IndexItem
  WHERE @Indexes IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, EndPosition + 1), 0), LEN(@Indexes) + 1) AS EndPosition,
         SUBSTRING(@Indexes, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @Indexes, EndPosition + 1), 0), LEN(@Indexes) + 1) - EndPosition - 1) AS IndexItem
  FROM Indexes1
  WHERE EndPosition < LEN(@Indexes) + 1
  ),
  Indexes2 (IndexItem, StartPosition, Selected) AS
  (
  SELECT CASE WHEN IndexItem LIKE '-%' THEN RIGHT(IndexItem,LEN(IndexItem) - 1) ELSE IndexItem END AS IndexItem,
         StartPosition,
         CASE WHEN IndexItem LIKE '-%' THEN 0 ELSE 1 END AS Selected
  FROM Indexes1
  ),
  Indexes3 (IndexItem, StartPosition, Selected) AS
  (
  SELECT CASE WHEN IndexItem = 'ALL_INDEXES' THEN '%.%.%.%' ELSE IndexItem END AS IndexItem,
         StartPosition,
         Selected
  FROM Indexes2
  ),
  Indexes4 (DatabaseName, SchemaName, ObjectName, IndexName, StartPosition, Selected) AS
  (
  SELECT CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,3) ELSE PARSENAME(IndexItem,4) END AS DatabaseName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,2) ELSE PARSENAME(IndexItem,3) END AS SchemaName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN PARSENAME(IndexItem,1) ELSE PARSENAME(IndexItem,2) END AS ObjectName,
         CASE WHEN PARSENAME(IndexItem,4) IS NULL THEN '%' ELSE PARSENAME(IndexItem,1) END AS IndexName,
         StartPosition,
         Selected
  FROM Indexes3
  )
  INSERT INTO @SelectedIndexes (DatabaseName, SchemaName, ObjectName, IndexName, StartPosition, Selected)
  SELECT DatabaseName, SchemaName, ObjectName, IndexName, StartPosition, Selected
  FROM Indexes4
  OPTION (MAXRECURSION 0)

  ----------------------------------------------------------------------------------------------------
  --// Select actions                                                                             //--
  ----------------------------------------------------------------------------------------------------

  SET @FragmentationLow = REPLACE(@FragmentationLow, @StringDelimiter + ' ', @StringDelimiter);

  WITH FragmentationLow (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, 1), 0), LEN(@FragmentationLow) + 1) AS EndPosition,
         SUBSTRING(@FragmentationLow, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, 1), 0), LEN(@FragmentationLow) + 1) - 1) AS [Action]
  WHERE @FragmentationLow IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, EndPosition + 1), 0), LEN(@FragmentationLow) + 1) AS EndPosition,
         SUBSTRING(@FragmentationLow, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationLow, EndPosition + 1), 0), LEN(@FragmentationLow) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationLow
  WHERE EndPosition < LEN(@FragmentationLow) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT 'Low' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationLow
  OPTION (MAXRECURSION 0)

  SET @FragmentationMedium = REPLACE(@FragmentationMedium, @StringDelimiter + ' ', @StringDelimiter);

  WITH FragmentationMedium (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, 1), 0), LEN(@FragmentationMedium) + 1) AS EndPosition,
         SUBSTRING(@FragmentationMedium, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, 1), 0), LEN(@FragmentationMedium) + 1) - 1) AS [Action]
  WHERE @FragmentationMedium IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, EndPosition + 1), 0), LEN(@FragmentationMedium) + 1) AS EndPosition,
         SUBSTRING(@FragmentationMedium, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationMedium, EndPosition + 1), 0), LEN(@FragmentationMedium) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationMedium
  WHERE EndPosition < LEN(@FragmentationMedium) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT 'Medium' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationMedium
  OPTION (MAXRECURSION 0)

  SET @FragmentationHigh = REPLACE(@FragmentationHigh, @StringDelimiter + ' ', @StringDelimiter);

  WITH FragmentationHigh (StartPosition, EndPosition, [Action]) AS
  (
  SELECT 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, 1), 0), LEN(@FragmentationHigh) + 1) AS EndPosition,
         SUBSTRING(@FragmentationHigh, 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, 1), 0), LEN(@FragmentationHigh) + 1) - 1) AS [Action]
  WHERE @FragmentationHigh IS NOT NULL
  UNION ALL
  SELECT CAST(EndPosition AS int) + 1 AS StartPosition,
         ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, EndPosition + 1), 0), LEN(@FragmentationHigh) + 1) AS EndPosition,
         SUBSTRING(@FragmentationHigh, EndPosition + 1, ISNULL(NULLIF(CHARINDEX(@StringDelimiter, @FragmentationHigh, EndPosition + 1), 0), LEN(@FragmentationHigh) + 1) - EndPosition - 1) AS [Action]
  FROM FragmentationHigh
  WHERE EndPosition < LEN(@FragmentationHigh) + 1
  )
  INSERT INTO @ActionsPreferred(FragmentationGroup, [Priority], [Action])
  SELECT 'High' AS FragmentationGroup,
         ROW_NUMBER() OVER(ORDER BY StartPosition ASC) AS [Priority],
         [Action]
  FROM FragmentationHigh
  OPTION (MAXRECURSION 0)

  ----------------------------------------------------------------------------------------------------
  --// Check input parameters                                                                     //--
  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = 'Low' AND [Action] NOT IN(SELECT * FROM @Actions))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationLow is not supported.', 16, 1
  END

  IF EXISTS (SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = 'Low' GROUP BY [Action] HAVING COUNT(*) > 1)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationLow is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = 'Medium' AND [Action] NOT IN(SELECT * FROM @Actions))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationMedium is not supported.', 16, 1
  END

  IF EXISTS (SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = 'Medium' GROUP BY [Action] HAVING COUNT(*) > 1)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationMedium is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS (SELECT [Action] FROM @ActionsPreferred WHERE FragmentationGroup = 'High' AND [Action] NOT IN(SELECT * FROM @Actions))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationHigh is not supported.', 16, 1
  END

  IF EXISTS (SELECT * FROM @ActionsPreferred WHERE FragmentationGroup = 'High' GROUP BY [Action] HAVING COUNT(*) > 1)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationHigh is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @FragmentationLevel1 <= 0 OR @FragmentationLevel1 >= 100 OR @FragmentationLevel1 IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationLevel1 is not supported.', 16, 1
  END

  IF @FragmentationLevel1 >= @FragmentationLevel2
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationLevel1 is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @FragmentationLevel2 <= 0 OR @FragmentationLevel2 >= 100 OR @FragmentationLevel2 IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationLevel2 is not supported.', 16, 1
  END

  IF @FragmentationLevel2 <= @FragmentationLevel1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FragmentationLevel2 is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @MinNumberOfPages < 0 OR @MinNumberOfPages IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @MinNumberOfPages is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @MaxNumberOfPages < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @MaxNumberOfPages is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @SortInTempdb NOT IN('Y','N') OR @SortInTempdb IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @SortInTempdb is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @MaxDOP < 0 OR @MaxDOP > 64
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @MaxDOP is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @FillFactor <= 0 OR @FillFactor > 100
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @FillFactor is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @PadIndex NOT IN('Y','N')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @PadIndex is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @LOBCompaction NOT IN('Y','N') OR @LOBCompaction IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @LOBCompaction is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @UpdateStatistics NOT IN('ALL','COLUMNS','INDEX')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @UpdateStatistics is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @OnlyModifiedStatistics NOT IN('Y','N') OR @OnlyModifiedStatistics IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @OnlyModifiedStatistics is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StatisticsModificationLevel <= 0 OR @StatisticsModificationLevel > 100
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @StatisticsModificationLevel is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @OnlyModifiedStatistics = 'Y' AND @StatisticsModificationLevel IS NOT NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'You can only specify one of the parameters @OnlyModifiedStatistics and @StatisticsModificationLevel.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StatisticsSample <= 0 OR @StatisticsSample  > 100
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @StatisticsSample is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StatisticsResample NOT IN('Y','N') OR @StatisticsResample IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @StatisticsResample is not supported.', 16, 1
  END

  IF @StatisticsResample = 'Y' AND @StatisticsSample IS NOT NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @StatisticsResample is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @PartitionLevel NOT IN('Y','N') OR @PartitionLevel IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @PartitionLevel is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @MSShippedObjects NOT IN('Y','N') OR @MSShippedObjects IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @MSShippedObjects is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS(SELECT * FROM @SelectedIndexes WHERE DatabaseName IS NULL OR SchemaName IS NULL OR ObjectName IS NULL OR IndexName IS NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Indexes is not supported.', 16, 1
  END

  IF @Indexes IS NOT NULL AND NOT EXISTS(SELECT * FROM @SelectedIndexes)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Indexes is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @TimeLimit < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @TimeLimit is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @Delay < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Delay is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @WaitAtLowPriorityMaxDuration < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @WaitAtLowPriorityMaxDuration is not supported.', 16, 1
  END

  IF @WaitAtLowPriorityMaxDuration IS NOT NULL AND @Version < 12
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @WaitAtLowPriorityMaxDuration is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @WaitAtLowPriorityAbortAfterWait NOT IN('NONE','SELF','BLOCKERS')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @WaitAtLowPriorityAbortAfterWait is not supported.', 16, 1
  END

  IF @WaitAtLowPriorityAbortAfterWait IS NOT NULL AND @Version < 12
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @WaitAtLowPriorityAbortAfterWait is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF (@WaitAtLowPriorityAbortAfterWait IS NOT NULL AND @WaitAtLowPriorityMaxDuration IS NULL) OR (@WaitAtLowPriorityAbortAfterWait IS NULL AND @WaitAtLowPriorityMaxDuration IS NOT NULL)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The parameters @WaitAtLowPriorityMaxDuration and @WaitAtLowPriorityAbortAfterWait can only be used together.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @Resumable NOT IN('Y','N') OR @Resumable IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Resumable is not supported.', 16, 1
  END

  IF @Resumable = 'Y' AND NOT (@Version >= 14 OR SERVERPROPERTY('EngineEdition') IN (5, 8))
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Resumable is not supported.', 16, 2
  END

  IF @Resumable = 'Y' AND @SortInTempdb = 'Y'
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'You can only specify one of the parameters @Resumable and @SortInTempdb.', 16, 3
  END

  ----------------------------------------------------------------------------------------------------

  IF @LockTimeout < 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @LockTimeout is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @LockMessageSeverity NOT IN(10, 16)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @LockMessageSeverity is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @StringDelimiter IS NULL OR LEN(@StringDelimiter) > 1
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @StringDelimiter is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @DatabaseOrder NOT IN('DATABASE_NAME_ASC','DATABASE_NAME_DESC','DATABASE_SIZE_ASC','DATABASE_SIZE_DESC')
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @DatabaseOrder is not supported.', 16, 1
  END

  IF @DatabaseOrder IS NOT NULL AND SERVERPROPERTY('EngineEdition') = 5
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @DatabaseOrder is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF @DatabasesInParallel NOT IN('Y','N') OR @DatabasesInParallel IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @DatabasesInParallel is not supported.', 16, 1
  END

  IF @DatabasesInParallel = 'Y' AND SERVERPROPERTY('EngineEdition') = 5
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @DatabasesInParallel is not supported.', 16, 2
  END

  ----------------------------------------------------------------------------------------------------

  IF LEN(@ExecuteAsUser) > 128
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @ExecuteAsUser is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @LogToTable NOT IN('Y','N') OR @LogToTable IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @LogToTable is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF @Execute NOT IN('Y','N') OR @Execute IS NULL
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The value for the parameter @Execute is not supported.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------

  IF EXISTS(SELECT * FROM @Errors)
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The documentation is available at https://ola.hallengren.com/sql-server-index-and-statistics-maintenance.html.', 16, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Check that selected databases and availability groups exist                                //--
  ----------------------------------------------------------------------------------------------------

  SET @ErrorMessage = ''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '
  FROM @SelectedDatabases
  WHERE DatabaseName NOT LIKE '%[%]%'
  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The following databases in the @Databases parameter do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1
  END

  SET @ErrorMessage = ''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '
  FROM @SelectedIndexes
  WHERE DatabaseName NOT LIKE '%[%]%'
  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The following databases in the @Indexes parameter do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1
  END

  SET @ErrorMessage = ''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(AvailabilityGroupName) + ', '
  FROM @SelectedAvailabilityGroups
  WHERE AvailabilityGroupName NOT LIKE '%[%]%'
  AND AvailabilityGroupName NOT IN (SELECT AvailabilityGroupName FROM @tmpAvailabilityGroups)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The following availability groups do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1
  END

  SET @ErrorMessage = ''
  SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + ', '
  FROM @SelectedIndexes
  WHERE DatabaseName NOT LIKE '%[%]%'
  AND DatabaseName IN (SELECT DatabaseName FROM @tmpDatabases)
  AND DatabaseName NOT IN (SELECT DatabaseName FROM @tmpDatabases WHERE Selected = 1)
  IF @@ROWCOUNT > 0
  BEGIN
    INSERT INTO @Errors ([Message], Severity, [State])
    SELECT 'The following databases have been selected in the @Indexes parameter, but not in the @Databases or @AvailabilityGroups parameters: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.', 10, 1
  END

  ----------------------------------------------------------------------------------------------------
  --// Raise errors                                                                               //--
  ----------------------------------------------------------------------------------------------------

  DECLARE ErrorCursor CURSOR FAST_FORWARD FOR SELECT [Message], Severity, [State] FROM @Errors ORDER BY [ID] ASC

  OPEN ErrorCursor

  FETCH ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState

  WHILE @@FETCH_STATUS = 0
  BEGIN
    RAISERROR('%s', @CurrentSeverity, @CurrentState, @CurrentMessage) WITH NOWAIT
    RAISERROR(@EmptyLine, 10, 1) WITH NOWAIT

    FETCH NEXT FROM ErrorCursor INTO @CurrentMessage, @CurrentSeverity, @CurrentState
  END

  CLOSE ErrorCursor

  DEALLOCATE ErrorCursor

  IF EXISTS (SELECT * FROM @Errors WHERE Severity >= 16)
  BEGIN
    SET @ReturnCode = 50000
    GOTO Logging
  END

  ----------------------------------------------------------------------------------------------------
  --// Should statistics be updated on the partition level?                                       //--
  ----------------------------------------------------------------------------------------------------

  SET @PartitionLevelStatistics = CASE WHEN @PartitionLevel = 'Y' AND ((@Version >= 12.05 AND @Version < 13) OR @Version >= 13.04422 OR SERVERPROPERTY('EngineEdition') IN (5,8)) THEN 1 ELSE 0 END

  ----------------------------------------------------------------------------------------------------
  --// Update database order                                                                      //--
  ----------------------------------------------------------------------------------------------------

  IF @DatabaseOrder IN('DATABASE_SIZE_ASC','DATABASE_SIZE_DESC')
  BEGIN
    UPDATE tmpDatabases
    SET DatabaseSize = (SELECT SUM(CAST(size AS bigint)) FROM sys.master_files WHERE [type] = 0 AND database_id = DB_ID(tmpDatabases.DatabaseName))
    FROM @tmpDatabases tmpDatabases
  END

  IF @DatabaseOrder IS NULL
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY StartPosition ASC, DatabaseName ASC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = 'DATABASE_NAME_ASC'
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseName ASC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = 'DATABASE_NAME_DESC'
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseName DESC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = 'DATABASE_SIZE_ASC'
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseSize ASC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END
  ELSE
  IF @DatabaseOrder = 'DATABASE_SIZE_DESC'
  BEGIN
    WITH tmpDatabases AS (
    SELECT DatabaseName, [Order], ROW_NUMBER() OVER (ORDER BY DatabaseSize DESC) AS RowNumber
    FROM @tmpDatabases tmpDatabases
    WHERE Selected = 1
    )
    UPDATE tmpDatabases
    SET [Order] = RowNumber
  END

  ----------------------------------------------------------------------------------------------------
  --// Update the queue                                                                           //--
  ----------------------------------------------------------------------------------------------------

  IF @DatabasesInParallel = 'Y'
  BEGIN

    BEGIN TRY

      SELECT @QueueID = QueueID
      FROM dbo.[Queue]
      WHERE SchemaName = @SchemaName
      AND ObjectName = @ObjectName
      AND [Parameters] = @Parameters

      IF @QueueID IS NULL
      BEGIN
        BEGIN TRANSACTION

        SELECT @QueueID = QueueID
        FROM dbo.[Queue] WITH (UPDLOCK, HOLDLOCK)
        WHERE SchemaName = @SchemaName
        AND ObjectName = @ObjectName
        AND [Parameters] = @Parameters

        IF @QueueID IS NULL
        BEGIN
          INSERT INTO dbo.[Queue] (SchemaName, ObjectName, [Parameters])
          SELECT @SchemaName, @ObjectName, @Parameters

          SET @QueueID = SCOPE_IDENTITY()
        END

        COMMIT TRANSACTION
      END

      BEGIN TRANSACTION

      UPDATE [Queue]
      SET QueueStartTime = SYSDATETIME(),
          SessionID = @@SPID,
          RequestID = (SELECT request_id FROM sys.dm_exec_requests WHERE session_id = @@SPID),
          RequestStartTime = (SELECT start_time FROM sys.dm_exec_requests WHERE session_id = @@SPID)
      FROM dbo.[Queue] [Queue]
      WHERE QueueID = @QueueID
      AND NOT EXISTS (SELECT *
                      FROM sys.dm_exec_requests
                      WHERE session_id = [Queue].SessionID
                      AND request_id = [Queue].RequestID
                      AND start_time = [Queue].RequestStartTime)
      AND NOT EXISTS (SELECT *
                      FROM dbo.QueueDatabase QueueDatabase
                      INNER JOIN sys.dm_exec_requests ON QueueDatabase.SessionID = session_id AND QueueDatabase.RequestID = request_id AND QueueDatabase.RequestStartTime = start_time
                      WHERE QueueDatabase.QueueID = @QueueID)

      IF @@ROWCOUNT = 1
      BEGIN
        INSERT INTO dbo.QueueDatabase (QueueID, DatabaseName)
        SELECT @QueueID AS QueueID,
               DatabaseName
        FROM @tmpDatabases tmpDatabases
        WHERE Selected = 1
        AND NOT EXISTS (SELECT * FROM dbo.QueueDatabase WHERE DatabaseName = tmpDatabases.DatabaseName AND QueueID = @QueueID)

        DELETE QueueDatabase
        FROM dbo.QueueDatabase QueueDatabase
        WHERE QueueID = @QueueID
        AND NOT EXISTS (SELECT * FROM @tmpDatabases tmpDatabases WHERE DatabaseName = QueueDatabase.DatabaseName AND Selected = 1)

        UPDATE QueueDatabase
        SET DatabaseOrder = tmpDatabases.[Order]
        FROM dbo.QueueDatabase QueueDatabase
        INNER JOIN @tmpDatabases tmpDatabases ON QueueDatabase.DatabaseName = tmpDatabases.DatabaseName
        WHERE QueueID = @QueueID
      END

      COMMIT TRANSACTION

      SELECT @QueueStartTime = QueueStartTime
      FROM dbo.[Queue]
      WHERE QueueID = @QueueID

    END TRY

    BEGIN CATCH
      IF XACT_STATE() <> 0
      BEGIN
        ROLLBACK TRANSACTION
      END
      SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'')
      RAISERROR('%s',16,1,@ErrorMessage) WITH NOWAIT
      RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      SET @ReturnCode = ERROR_NUMBER()
      GOTO Logging
    END CATCH

  END

  ----------------------------------------------------------------------------------------------------
  --// Execute commands                                                                           //--
  ----------------------------------------------------------------------------------------------------

  WHILE (1 = 1)
  BEGIN

    IF @DatabasesInParallel = 'Y'
    BEGIN
      UPDATE QueueDatabase
      SET DatabaseStartTime = NULL,
          SessionID = NULL,
          RequestID = NULL,
          RequestStartTime = NULL
      FROM dbo.QueueDatabase QueueDatabase
      WHERE QueueID = @QueueID
      AND DatabaseStartTime IS NOT NULL
      AND DatabaseEndTime IS NULL
      AND NOT EXISTS (SELECT * FROM sys.dm_exec_requests WHERE session_id = QueueDatabase.SessionID AND request_id = QueueDatabase.RequestID AND start_time = QueueDatabase.RequestStartTime)

      UPDATE QueueDatabase
      SET DatabaseStartTime = SYSDATETIME(),
          DatabaseEndTime = NULL,
          SessionID = @@SPID,
          RequestID = (SELECT request_id FROM sys.dm_exec_requests WHERE session_id = @@SPID),
          RequestStartTime = (SELECT start_time FROM sys.dm_exec_requests WHERE session_id = @@SPID),
          @CurrentDatabaseName = DatabaseName
      FROM (SELECT TOP 1 DatabaseStartTime,
                         DatabaseEndTime,
                         SessionID,
                         RequestID,
                         RequestStartTime,
                         DatabaseName
            FROM dbo.QueueDatabase
            WHERE QueueID = @QueueID
            AND (DatabaseStartTime < @QueueStartTime OR DatabaseStartTime IS NULL)
            AND NOT (DatabaseStartTime IS NOT NULL AND DatabaseEndTime IS NULL)
            ORDER BY DatabaseOrder ASC
            ) QueueDatabase
    END
    ELSE
    BEGIN
      SELECT TOP 1 @CurrentDBID = ID,
                   @CurrentDatabaseName = DatabaseName
      FROM @tmpDatabases
      WHERE Selected = 1
      AND Completed = 0
      ORDER BY [Order] ASC
    END

    IF @@ROWCOUNT = 0
    BEGIN
      BREAK
    END

    SET @CurrentDatabase_sp_executesql = QUOTENAME(@CurrentDatabaseName) + '.sys.sp_executesql'

    IF @ExecuteAsUser IS NOT NULL
    BEGIN
      SET @CurrentCommand = ''
      SET @CurrentCommand += 'IF EXISTS(SELECT * FROM sys.database_principals database_principals WHERE database_principals.[name] = @ParamExecuteAsUser) BEGIN SET @ParamExecuteAsUserExists = 1 END ELSE BEGIN SET @ParamExecuteAsUserExists = 0 END'

      EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N'@ParamExecuteAsUser sysname, @ParamExecuteAsUserExists bit OUTPUT', @ParamExecuteAsUser = @ExecuteAsUser, @ParamExecuteAsUserExists = @CurrentExecuteAsUserExists OUTPUT
    END

    BEGIN
      SET @DatabaseMessage = 'Date and time: ' + CONVERT(nvarchar,SYSDATETIME(),120)
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = 'Database: ' + QUOTENAME(@CurrentDatabaseName)
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT
    END

    SELECT @CurrentUserAccess = user_access_desc,
           @CurrentIsReadOnly = is_read_only,
           @CurrentDatabaseState = state_desc,
           @CurrentInStandby = is_in_standby,
           @CurrentRecoveryModel = recovery_model_desc
    FROM sys.databases
    WHERE [name] = @CurrentDatabaseName

    BEGIN
      SET @DatabaseMessage = 'State: ' + @CurrentDatabaseState
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = 'Standby: ' + CASE WHEN @CurrentInStandby = 1 THEN 'Yes' ELSE 'No' END
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = 'Updateability: ' + CASE WHEN @CurrentIsReadOnly = 1 THEN 'READ_ONLY' WHEN  @CurrentIsReadOnly = 0 THEN 'READ_WRITE' END
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = 'User access: ' + @CurrentUserAccess
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = 'Recovery model: ' + @CurrentRecoveryModel
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT
    END

    IF @CurrentDatabaseState = 'ONLINE' AND SERVERPROPERTY('EngineEdition') <> 5
    BEGIN
      IF EXISTS (SELECT * FROM sys.database_recovery_status WHERE database_id = DB_ID(@CurrentDatabaseName) AND database_guid IS NOT NULL)
      BEGIN
        SET @CurrentIsDatabaseAccessible = 1
      END
      ELSE
      BEGIN
        SET @CurrentIsDatabaseAccessible = 0
      END
    END

    IF @Version >= 11 AND SERVERPROPERTY('IsHadrEnabled') = 1
    BEGIN
      SELECT @CurrentReplicaID = databases.replica_id
      FROM sys.databases databases
      INNER JOIN sys.availability_replicas availability_replicas ON databases.replica_id = availability_replicas.replica_id
      WHERE databases.[name] = @CurrentDatabaseName

      SELECT @CurrentAvailabilityGroupID = group_id
      FROM sys.availability_replicas
      WHERE replica_id = @CurrentReplicaID

      SELECT @CurrentAvailabilityGroupRole = role_desc
      FROM sys.dm_hadr_availability_replica_states
      WHERE replica_id = @CurrentReplicaID

      SELECT @CurrentAvailabilityGroup = [name]
      FROM sys.availability_groups
      WHERE group_id = @CurrentAvailabilityGroupID
    END

    IF SERVERPROPERTY('EngineEdition') <> 5
    BEGIN
      SELECT @CurrentDatabaseMirroringRole = UPPER(mirroring_role_desc)
      FROM sys.database_mirroring
      WHERE database_id = DB_ID(@CurrentDatabaseName)
    END

    IF @CurrentIsDatabaseAccessible IS NOT NULL
    BEGIN
      SET @DatabaseMessage = 'Is accessible: ' + CASE WHEN @CurrentIsDatabaseAccessible = 1 THEN 'Yes' ELSE 'No' END
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT
    END

    IF @CurrentAvailabilityGroup IS NOT NULL
    BEGIN
      SET @DatabaseMessage = 'Availability group: ' + ISNULL(@CurrentAvailabilityGroup,'N/A')
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT

      SET @DatabaseMessage = 'Availability group role: ' + ISNULL(@CurrentAvailabilityGroupRole,'N/A')
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT
    END

    IF @CurrentDatabaseMirroringRole IS NOT NULL
    BEGIN
      SET @DatabaseMessage = 'Database mirroring role: ' + @CurrentDatabaseMirroringRole
      RAISERROR('%s',10,1,@DatabaseMessage) WITH NOWAIT
    END

    RAISERROR(@EmptyLine,10,1) WITH NOWAIT

    IF @CurrentExecuteAsUserExists = 0
    BEGIN
      SET @DatabaseMessage = 'The user ' + QUOTENAME(@ExecuteAsUser) + ' does not exist in the database ' + QUOTENAME(@CurrentDatabaseName) + '.'
      RAISERROR('%s',16,1,@DatabaseMessage) WITH NOWAIT
      RAISERROR(@EmptyLine,10,1) WITH NOWAIT
    END

    IF @CurrentDatabaseState = 'ONLINE'
    AND NOT (@CurrentUserAccess = 'SINGLE_USER' AND @CurrentIsDatabaseAccessible = 0)
    AND DATABASEPROPERTYEX(@CurrentDatabaseName,'Updateability') = 'READ_WRITE'
    AND (@CurrentExecuteAsUserExists = 1 OR @CurrentExecuteAsUserExists IS NULL)
    BEGIN

      -- Select indexes in the current database
      IF (EXISTS(SELECT * FROM @ActionsPreferred) OR @UpdateStatistics IS NOT NULL) AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
      BEGIN
        SET @CurrentCommand = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;'
                              + ' SELECT SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, IsMemoryOptimized, IndexID, IndexName, IndexType, AllowPageLocks, IsImageText, IsNewLOB, IsFileStream, IsColumnStore, IsComputed, IsTimestamp, OnReadOnlyFileGroup, ResumableIndexOperation, StatisticsID, StatisticsName, NoRecompute, IsIncremental, PartitionID, PartitionNumber, PartitionCount, [Order], Selected, Completed'
                              + ' FROM ('

        IF EXISTS(SELECT * FROM @ActionsPreferred) OR @UpdateStatistics IN('ALL','INDEX')
        BEGIN
          SET @CurrentCommand = @CurrentCommand + 'SELECT schemas.[schema_id] AS SchemaID'
                                                    + ', schemas.[name] AS SchemaName'
                                                    + ', objects.[object_id] AS ObjectID'
                                                    + ', objects.[name] AS ObjectName'
                                                    + ', RTRIM(objects.[type]) AS ObjectType'
                                                    + ', ' + CASE WHEN @Version >= 12 THEN 'tables.is_memory_optimized' ELSE '0' END + ' AS IsMemoryOptimized'
                                                    + ', indexes.index_id AS IndexID'
                                                    + ', indexes.[name] AS IndexName'
                                                    + ', indexes.[type] AS IndexType'
                                                    + ', indexes.allow_page_locks AS AllowPageLocks'

                                                    + ', CASE WHEN indexes.[type] = 1 AND EXISTS(SELECT * FROM sys.columns columns INNER JOIN sys.types types ON columns.system_type_id = types.user_type_id WHERE columns.[object_id] = objects.object_id AND types.name IN(''image'',''text'',''ntext'')) THEN 1 ELSE 0 END AS IsImageText'

                                                    + ', CASE WHEN indexes.[type] = 1 AND EXISTS(SELECT * FROM sys.columns columns INNER JOIN sys.types types ON columns.system_type_id = types.user_type_id OR (columns.user_type_id = types.user_type_id AND types.is_assembly_type = 1) WHERE columns.[object_id] = objects.object_id AND (types.name IN(''xml'') OR (types.name IN(''varchar'',''nvarchar'',''varbinary'') AND columns.max_length = -1) OR (types.is_assembly_type = 1 AND columns.max_length = -1))) THEN 1'
                                                    + ' WHEN indexes.[type] = 2 AND EXISTS(SELECT * FROM sys.index_columns index_columns INNER JOIN sys.columns columns ON index_columns.[object_id] = columns.[object_id] AND index_columns.column_id = columns.column_id INNER JOIN sys.types types ON columns.system_type_id = types.user_type_id OR (columns.user_type_id = types.user_type_id AND types.is_assembly_type = 1) WHERE index_columns.[object_id] = objects.object_id AND index_columns.index_id = indexes.index_id AND (types.[name] IN(''xml'') OR (types.[name] IN(''varchar'',''nvarchar'',''varbinary'') AND columns.max_length = -1) OR (types.is_assembly_type = 1 AND columns.max_length = -1))) THEN 1 ELSE 0 END AS IsNewLOB'

                                                    + ', CASE WHEN indexes.[type] = 1 AND EXISTS(SELECT * FROM sys.columns columns WHERE columns.[object_id] = objects.object_id  AND columns.is_filestream = 1) THEN 1 ELSE 0 END AS IsFileStream'

                                                    + ', CASE WHEN EXISTS(SELECT * FROM sys.indexes indexes WHERE indexes.[object_id] = objects.object_id AND [type] IN(5,6)) THEN 1 ELSE 0 END AS IsColumnStore'

                                                    + ', CASE WHEN EXISTS(SELECT * FROM sys.index_columns index_columns INNER JOIN sys.columns columns ON index_columns.object_id = columns.object_id AND index_columns.column_id = columns.column_id WHERE (index_columns.key_ordinal > 0 OR index_columns.partition_ordinal > 0) AND columns.is_computed = 1 AND index_columns.object_id = indexes.object_id AND index_columns.index_id = indexes.index_id) THEN 1 ELSE 0 END AS IsComputed'

                                                    + ', CASE WHEN EXISTS(SELECT * FROM sys.index_columns index_columns INNER JOIN sys.columns columns ON index_columns.[object_id] = columns.[object_id] AND index_columns.column_id = columns.column_id INNER JOIN sys.types types ON columns.system_type_id = types.system_type_id WHERE index_columns.[object_id] = objects.object_id AND index_columns.index_id = indexes.index_id AND types.[name] = ''timestamp'') THEN 1 ELSE 0 END AS IsTimestamp'

                                                    + ', CASE WHEN EXISTS (SELECT * FROM sys.indexes indexes2 INNER JOIN sys.destination_data_spaces destination_data_spaces ON indexes.data_space_id = destination_data_spaces.partition_scheme_id INNER JOIN sys.filegroups filegroups ON destination_data_spaces.data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND indexes2.[object_id] = indexes.[object_id] AND indexes2.[index_id] = indexes.index_id' + CASE WHEN @PartitionLevel = 'Y' THEN ' AND destination_data_spaces.destination_id = partitions.partition_number' ELSE '' END + ') THEN 1'
                                                    + ' WHEN EXISTS (SELECT * FROM sys.indexes indexes2 INNER JOIN sys.filegroups filegroups ON indexes.data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND indexes.[object_id] = indexes2.[object_id] AND indexes.[index_id] = indexes2.index_id) THEN 1'
                                                    + ' WHEN indexes.[type] = 1 AND EXISTS (SELECT * FROM sys.tables tables INNER JOIN sys.filegroups filegroups ON tables.lob_data_space_id = filegroups.data_space_id WHERE filegroups.is_read_only = 1 AND tables.[object_id] = objects.[object_id]) THEN 1 ELSE 0 END AS OnReadOnlyFileGroup'

                                                    + ', ' + CASE WHEN @Version >= 14 THEN 'CASE WHEN EXISTS(SELECT * FROM sys.index_resumable_operations index_resumable_operations WHERE state_desc = ''PAUSED'' AND index_resumable_operations.object_id = indexes.object_id AND index_resumable_operations.index_id = indexes.index_id AND (index_resumable_operations.partition_number = partitions.partition_number OR index_resumable_operations.partition_number IS NULL)) THEN 1 ELSE 0 END' ELSE '0' END + ' AS ResumableIndexOperation'

                                                    + ', stats.stats_id AS StatisticsID'
                                                    + ', stats.name AS StatisticsName'
                                                    + ', stats.no_recompute AS NoRecompute'
                                                    + ', ' + CASE WHEN @Version >= 12 THEN 'stats.is_incremental' ELSE '0' END + ' AS IsIncremental'
                                                    + ', ' + CASE WHEN @PartitionLevel = 'Y' THEN 'partitions.partition_id AS PartitionID' WHEN @PartitionLevel = 'N' THEN 'NULL AS PartitionID' END
                                                    + ', ' + CASE WHEN @PartitionLevel = 'Y' THEN 'partitions.partition_number AS PartitionNumber' WHEN @PartitionLevel = 'N' THEN 'NULL AS PartitionNumber' END
                                                    + ', ' + CASE WHEN @PartitionLevel = 'Y' THEN 'IndexPartitions.partition_count AS PartitionCount' WHEN @PartitionLevel = 'N' THEN 'NULL AS PartitionCount' END
                                                    + ', 0 AS [Order]'
                                                    + ', 0 AS Selected'
                                                    + ', 0 AS Completed'
                                                    + ' FROM sys.indexes indexes'
                                                    + ' INNER JOIN sys.objects objects ON indexes.[object_id] = objects.[object_id]'
                                                    + ' INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id]'
                                                    + ' LEFT OUTER JOIN sys.tables tables ON objects.[object_id] = tables.[object_id]'
                                                    + ' LEFT OUTER JOIN sys.stats stats ON indexes.[object_id] = stats.[object_id] AND indexes.[index_id] = stats.[stats_id]'
          IF @PartitionLevel = 'Y'
          BEGIN
            SET @CurrentCommand = @CurrentCommand + ' LEFT OUTER JOIN sys.partitions partitions ON indexes.[object_id] = partitions.[object_id] AND indexes.index_id = partitions.index_id'
                                                      + ' LEFT OUTER JOIN (SELECT partitions.[object_id], partitions.index_id, COUNT(DISTINCT partitions.partition_number) AS partition_count FROM sys.partitions partitions GROUP BY partitions.[object_id], partitions.index_id) IndexPartitions ON partitions.[object_id] = IndexPartitions.[object_id] AND partitions.[index_id] = IndexPartitions.[index_id]'
          END

          SET @CurrentCommand = @CurrentCommand + ' WHERE objects.[type] IN(''U'',''V'')'
                                                    + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END
                                                    + ' AND indexes.[type] IN(1,2,3,4,5,6,7)'
                                                    + ' AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0'
        END

        IF (EXISTS(SELECT * FROM @ActionsPreferred) AND @UpdateStatistics = 'COLUMNS') OR @UpdateStatistics = 'ALL'
        BEGIN
          SET @CurrentCommand = @CurrentCommand + ' UNION '
        END

        IF @UpdateStatistics IN('ALL','COLUMNS')
        BEGIN
          SET @CurrentCommand = @CurrentCommand + 'SELECT schemas.[schema_id] AS SchemaID'
                                                    + ', schemas.[name] AS SchemaName'
                                                    + ', objects.[object_id] AS ObjectID'
                                                    + ', objects.[name] AS ObjectName'
                                                    + ', RTRIM(objects.[type]) AS ObjectType'
                                                    + ', ' + CASE WHEN @Version >= 12 THEN 'tables.is_memory_optimized' ELSE '0' END + ' AS IsMemoryOptimized'
                                                    + ', NULL AS IndexID, NULL AS IndexName'
                                                    + ', NULL AS IndexType'
                                                    + ', NULL AS AllowPageLocks'
                                                    + ', NULL AS IsImageText'
                                                    + ', NULL AS IsNewLOB'
                                                    + ', NULL AS IsFileStream'
                                                    + ', NULL AS IsColumnStore'
                                                    + ', NULL AS IsComputed'
                                                    + ', NULL AS IsTimestamp'
                                                    + ', NULL AS OnReadOnlyFileGroup'
                                                    + ', NULL AS ResumableIndexOperation'
                                                    + ', stats.stats_id AS StatisticsID'
                                                    + ', stats.name AS StatisticsName'
                                                    + ', stats.no_recompute AS NoRecompute'
                                                    + ', ' + CASE WHEN @Version >= 12 THEN 'stats.is_incremental' ELSE '0' END + ' AS IsIncremental'
                                                    + ', NULL AS PartitionID'
                                                    + ', ' + CASE WHEN @PartitionLevelStatistics = 1 THEN 'dm_db_incremental_stats_properties.partition_number' ELSE 'NULL' END + ' AS PartitionNumber'
                                                    + ', NULL AS PartitionCount'
                                                    + ', 0 AS [Order]'
                                                    + ', 0 AS Selected'
                                                    + ', 0 AS Completed'
                                                    + ' FROM sys.stats stats'
                                                    + ' INNER JOIN sys.objects objects ON stats.[object_id] = objects.[object_id]'
                                                    + ' INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id]'
                                                    + ' LEFT OUTER JOIN sys.tables tables ON objects.[object_id] = tables.[object_id]'

          IF @PartitionLevelStatistics = 1
          BEGIN
            SET @CurrentCommand = @CurrentCommand + ' OUTER APPLY sys.dm_db_incremental_stats_properties(stats.object_id, stats.stats_id) dm_db_incremental_stats_properties'
          END

          SET @CurrentCommand = @CurrentCommand + ' WHERE objects.[type] IN(''U'',''V'')'
                                                    + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END
                                                    + ' AND NOT EXISTS(SELECT * FROM sys.indexes indexes WHERE indexes.[object_id] = stats.[object_id] AND indexes.index_id = stats.stats_id)'
        END

        SET @CurrentCommand = @CurrentCommand + ') IndexesStatistics'

        INSERT INTO @tmpIndexesStatistics (SchemaID, SchemaName, ObjectID, ObjectName, ObjectType, IsMemoryOptimized, IndexID, IndexName, IndexType, AllowPageLocks, IsImageText, IsNewLOB, IsFileStream, IsColumnStore, IsComputed, IsTimestamp, OnReadOnlyFileGroup, ResumableIndexOperation, StatisticsID, StatisticsName, [NoRecompute], IsIncremental, PartitionID, PartitionNumber, PartitionCount, [Order], Selected, Completed)
        EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand
        SET @Error = @@ERROR
        IF @Error <> 0
        BEGIN
          SET @ReturnCode = @Error
        END
      END

      IF @Indexes IS NULL
      BEGIN
        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = 1
        FROM @tmpIndexesStatistics tmpIndexesStatistics
      END
      ELSE
      BEGIN
        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = SelectedIndexes.Selected
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN @SelectedIndexes SelectedIndexes
        ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,'_','[_]') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,'_','[_]') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,'_','[_]') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,'_','[_]')
        WHERE SelectedIndexes.Selected = 1

        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.Selected = SelectedIndexes.Selected
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN @SelectedIndexes SelectedIndexes
        ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,'_','[_]') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,'_','[_]') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,'_','[_]') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,'_','[_]')
        WHERE SelectedIndexes.Selected = 0

        UPDATE tmpIndexesStatistics
        SET tmpIndexesStatistics.StartPosition = SelectedIndexes2.StartPosition
        FROM @tmpIndexesStatistics tmpIndexesStatistics
        INNER JOIN (SELECT tmpIndexesStatistics.SchemaName, tmpIndexesStatistics.ObjectName, tmpIndexesStatistics.IndexName, tmpIndexesStatistics.StatisticsName, MIN(SelectedIndexes.StartPosition) AS StartPosition
                    FROM @tmpIndexesStatistics tmpIndexesStatistics
                    INNER JOIN @SelectedIndexes SelectedIndexes
                    ON @CurrentDatabaseName LIKE REPLACE(SelectedIndexes.DatabaseName,'_','[_]') AND tmpIndexesStatistics.SchemaName LIKE REPLACE(SelectedIndexes.SchemaName,'_','[_]') AND tmpIndexesStatistics.ObjectName LIKE REPLACE(SelectedIndexes.ObjectName,'_','[_]') AND COALESCE(tmpIndexesStatistics.IndexName,tmpIndexesStatistics.StatisticsName) LIKE REPLACE(SelectedIndexes.IndexName,'_','[_]')
                    WHERE SelectedIndexes.Selected = 1
                    GROUP BY tmpIndexesStatistics.SchemaName, tmpIndexesStatistics.ObjectName, tmpIndexesStatistics.IndexName, tmpIndexesStatistics.StatisticsName) SelectedIndexes2
        ON tmpIndexesStatistics.SchemaName = SelectedIndexes2.SchemaName
        AND tmpIndexesStatistics.ObjectName = SelectedIndexes2.ObjectName
        AND (tmpIndexesStatistics.IndexName = SelectedIndexes2.IndexName OR tmpIndexesStatistics.IndexName IS NULL)
        AND (tmpIndexesStatistics.StatisticsName = SelectedIndexes2.StatisticsName OR tmpIndexesStatistics.StatisticsName IS NULL)
      END;

      WITH tmpIndexesStatistics AS (
      SELECT SchemaName, ObjectName, [Order], ROW_NUMBER() OVER (ORDER BY ISNULL(ResumableIndexOperation,0) DESC, StartPosition ASC, SchemaName ASC, ObjectName ASC, CASE WHEN IndexType IS NULL THEN 1 ELSE 0 END ASC, IndexType ASC, IndexName ASC, StatisticsName ASC, PartitionNumber ASC) AS RowNumber
      FROM @tmpIndexesStatistics tmpIndexesStatistics
      WHERE Selected = 1
      )
      UPDATE tmpIndexesStatistics
      SET [Order] = RowNumber

      SET @ErrorMessage = ''
      SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + '.' + QUOTENAME(SchemaName) + '.' + QUOTENAME(ObjectName) + ', '
      FROM @SelectedIndexes SelectedIndexes
      WHERE DatabaseName = @CurrentDatabaseName
      AND SchemaName NOT LIKE '%[%]%'
      AND ObjectName NOT LIKE '%[%]%'
      AND IndexName LIKE '%[%]%'
      AND NOT EXISTS (SELECT * FROM @tmpIndexesStatistics WHERE SchemaName = SelectedIndexes.SchemaName AND ObjectName = SelectedIndexes.ObjectName)
      IF @@ROWCOUNT > 0
      BEGIN
        SET @ErrorMessage = 'The following objects in the @Indexes parameter do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.'
        RAISERROR('%s',10,1,@ErrorMessage) WITH NOWAIT
        SET @Error = @@ERROR
        RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      END

      SET @ErrorMessage = ''
      SELECT @ErrorMessage = @ErrorMessage + QUOTENAME(DatabaseName) + QUOTENAME(SchemaName) + '.' + QUOTENAME(ObjectName) + '.' + QUOTENAME(IndexName) + ', '
      FROM @SelectedIndexes SelectedIndexes
      WHERE DatabaseName = @CurrentDatabaseName
      AND SchemaName NOT LIKE '%[%]%'
      AND ObjectName NOT LIKE '%[%]%'
      AND IndexName NOT LIKE '%[%]%'
      AND NOT EXISTS (SELECT * FROM @tmpIndexesStatistics WHERE SchemaName = SelectedIndexes.SchemaName AND ObjectName = SelectedIndexes.ObjectName AND IndexName = SelectedIndexes.IndexName)
      IF @@ROWCOUNT > 0
      BEGIN
        SET @ErrorMessage = 'The following indexes in the @Indexes parameter do not exist: ' + LEFT(@ErrorMessage,LEN(@ErrorMessage)-1) + '.'
        RAISERROR('%s',10,1,@ErrorMessage) WITH NOWAIT
        SET @Error = @@ERROR
        RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      END

      WHILE (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
      BEGIN
        SELECT TOP 1 @CurrentIxID = ID,
                     @CurrentIxOrder = [Order],
                     @CurrentSchemaID = SchemaID,
                     @CurrentSchemaName = SchemaName,
                     @CurrentObjectID = ObjectID,
                     @CurrentObjectName = ObjectName,
                     @CurrentObjectType = ObjectType,
                     @CurrentIsMemoryOptimized = IsMemoryOptimized,
                     @CurrentIndexID = IndexID,
                     @CurrentIndexName = IndexName,
                     @CurrentIndexType = IndexType,
                     @CurrentAllowPageLocks = AllowPageLocks,
                     @CurrentIsImageText = IsImageText,
                     @CurrentIsNewLOB = IsNewLOB,
                     @CurrentIsFileStream = IsFileStream,
                     @CurrentIsColumnStore = IsColumnStore,
                     @CurrentIsComputed = IsComputed,
                     @CurrentIsTimestamp = IsTimestamp,
                     @CurrentOnReadOnlyFileGroup = OnReadOnlyFileGroup,
                     @CurrentResumableIndexOperation = ResumableIndexOperation,
                     @CurrentStatisticsID = StatisticsID,
                     @CurrentStatisticsName = StatisticsName,
                     @CurrentNoRecompute = [NoRecompute],
                     @CurrentIsIncremental = IsIncremental,
                     @CurrentPartitionID = PartitionID,
                     @CurrentPartitionNumber = PartitionNumber,
                     @CurrentPartitionCount = PartitionCount
        FROM @tmpIndexesStatistics
        WHERE Selected = 1
        AND Completed = 0
        ORDER BY [Order] ASC

        IF @@ROWCOUNT = 0
        BEGIN
          BREAK
        END

        -- Is the index a partition?
        IF @CurrentPartitionNumber IS NULL OR @CurrentPartitionCount = 1 BEGIN SET @CurrentIsPartition = 0 END ELSE BEGIN SET @CurrentIsPartition = 1 END

        -- Does the index exist?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentCommand = ''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '

          IF @CurrentIsPartition = 0 SET @CurrentCommand += 'IF EXISTS(SELECT * FROM sys.indexes indexes INNER JOIN sys.objects objects ON indexes.[object_id] = objects.[object_id] INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] IN(''U'',''V'') AND indexes.[type] IN(1,2,3,4,5,6,7) AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0 AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND indexes.index_id = @ParamIndexID AND indexes.[name] = @ParamIndexName AND indexes.[type] = @ParamIndexType) BEGIN SET @ParamIndexExists = 1 END'
          IF @CurrentIsPartition = 1 SET @CurrentCommand += 'IF EXISTS(SELECT * FROM sys.indexes indexes INNER JOIN sys.objects objects ON indexes.[object_id] = objects.[object_id] INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] INNER JOIN sys.partitions partitions ON indexes.[object_id] = partitions.[object_id] AND indexes.index_id = partitions.index_id WHERE objects.[type] IN(''U'',''V'') AND indexes.[type] IN(1,2,3,4,5,6,7) AND indexes.is_disabled = 0 AND indexes.is_hypothetical = 0 AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND indexes.index_id = @ParamIndexID AND indexes.[name] = @ParamIndexName AND indexes.[type] = @ParamIndexType AND partitions.partition_id = @ParamPartitionID AND partitions.partition_number = @ParamPartitionNumber) BEGIN SET @ParamIndexExists = 1 END'

          BEGIN TRY
            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N'@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamIndexID int, @ParamIndexName sysname, @ParamIndexType int, @ParamPartitionID bigint, @ParamPartitionNumber int, @ParamIndexExists bit OUTPUT', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamIndexID = @CurrentIndexID, @ParamIndexName = @CurrentIndexName, @ParamIndexType = @CurrentIndexType, @ParamPartitionID = @CurrentPartitionID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamIndexExists = @CurrentIndexExists OUTPUT

            IF @CurrentIndexExists IS NULL
            BEGIN
              SET @CurrentIndexExists = 0
              GOTO NoAction
            END
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'') + CASE WHEN ERROR_NUMBER() = 1222 THEN ' The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the index exists.' ELSE '' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR('%s',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Does the statistics exist?
        IF @CurrentStatisticsID IS NOT NULL AND @UpdateStatistics IS NOT NULL
        BEGIN
          SET @CurrentCommand = ''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '

          SET @CurrentCommand += 'IF EXISTS(SELECT * FROM sys.stats stats INNER JOIN sys.objects objects ON stats.[object_id] = objects.[object_id] INNER JOIN sys.schemas schemas ON objects.[schema_id] = schemas.[schema_id] WHERE objects.[type] IN(''U'',''V'')' + CASE WHEN @MSShippedObjects = 'N' THEN ' AND objects.is_ms_shipped = 0' ELSE '' END + ' AND schemas.[schema_id] = @ParamSchemaID AND schemas.[name] = @ParamSchemaName AND objects.[object_id] = @ParamObjectID AND objects.[name] = @ParamObjectName AND objects.[type] = @ParamObjectType AND stats.stats_id = @ParamStatisticsID AND stats.[name] = @ParamStatisticsName) BEGIN SET @ParamStatisticsExists = 1 END'

          BEGIN TRY
            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N'@ParamSchemaID int, @ParamSchemaName sysname, @ParamObjectID int, @ParamObjectName sysname, @ParamObjectType sysname, @ParamStatisticsID int, @ParamStatisticsName sysname, @ParamStatisticsExists bit OUTPUT', @ParamSchemaID = @CurrentSchemaID, @ParamSchemaName = @CurrentSchemaName, @ParamObjectID = @CurrentObjectID, @ParamObjectName = @CurrentObjectName, @ParamObjectType = @CurrentObjectType, @ParamStatisticsID = @CurrentStatisticsID, @ParamStatisticsName = @CurrentStatisticsName, @ParamStatisticsExists = @CurrentStatisticsExists OUTPUT

            IF @CurrentStatisticsExists IS NULL
            BEGIN
              SET @CurrentStatisticsExists = 0
              GOTO NoAction
            END
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'') + CASE WHEN ERROR_NUMBER() = 1222 THEN ' The statistics ' + QUOTENAME(@CurrentStatisticsName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. It could not be checked if the statistics exists.' ELSE '' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR('%s',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Has the data in the statistics been modified since the statistics was last updated?
        IF @CurrentStatisticsID IS NOT NULL AND @UpdateStatistics IS NOT NULL
        BEGIN
          SET @CurrentCommand = ''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '

          IF @PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1
          BEGIN
            SET @CurrentCommand += 'SELECT @ParamRowCount = [rows], @ParamModificationCounter = modification_counter FROM sys.dm_db_incremental_stats_properties (@ParamObjectID, @ParamStatisticsID) WHERE partition_number = @ParamPartitionNumber'
          END
          ELSE
          IF (@Version >= 10.504000 AND @Version < 11) OR @Version >= 11.03000
          BEGIN
            SET @CurrentCommand += 'SELECT @ParamRowCount = [rows], @ParamModificationCounter = modification_counter FROM sys.dm_db_stats_properties (@ParamObjectID, @ParamStatisticsID)'
          END
          ELSE
          BEGIN
            SET @CurrentCommand += 'SELECT @ParamRowCount = rowcnt, @ParamModificationCounter = rowmodctr FROM sys.sysindexes sysindexes WHERE sysindexes.[id] = @ParamObjectID AND sysindexes.[indid] = @ParamStatisticsID'
          END

          BEGIN TRY
            EXECUTE @CurrentDatabase_sp_executesql @stmt = @CurrentCommand, @params = N'@ParamObjectID int, @ParamStatisticsID int, @ParamPartitionNumber int, @ParamRowCount bigint OUTPUT, @ParamModificationCounter bigint OUTPUT', @ParamObjectID = @CurrentObjectID, @ParamStatisticsID = @CurrentStatisticsID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamRowCount = @CurrentRowCount OUTPUT, @ParamModificationCounter = @CurrentModificationCounter OUTPUT

            IF @CurrentRowCount IS NULL SET @CurrentRowCount = 0
            IF @CurrentModificationCounter IS NULL SET @CurrentModificationCounter = 0
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'') + CASE WHEN ERROR_NUMBER() = 1222 THEN ' The statistics ' + QUOTENAME(@CurrentStatisticsName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. The rows and modification_counter could not be checked.' ELSE '' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR('%s',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Is the index fragmented?
        IF @CurrentIndexID IS NOT NULL
        AND @CurrentOnReadOnlyFileGroup = 0
        AND EXISTS(SELECT * FROM @ActionsPreferred)
        AND (EXISTS(SELECT [Priority], [Action], COUNT(*) FROM @ActionsPreferred GROUP BY [Priority], [Action] HAVING COUNT(*) <> 3) OR @MinNumberOfPages > 0 OR @MaxNumberOfPages IS NOT NULL)
        BEGIN
          SET @CurrentCommand = ''

          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '

          SET @CurrentCommand += 'SELECT @ParamFragmentationLevel = MAX(avg_fragmentation_in_percent), @ParamPageCount = SUM(page_count) FROM sys.dm_db_index_physical_stats(DB_ID(@ParamDatabaseName), @ParamObjectID, @ParamIndexID, @ParamPartitionNumber, ''LIMITED'') WHERE alloc_unit_type_desc = ''IN_ROW_DATA'' AND index_level = 0'

          BEGIN TRY
            EXECUTE sp_executesql @stmt = @CurrentCommand, @params = N'@ParamDatabaseName nvarchar(max), @ParamObjectID int, @ParamIndexID int, @ParamPartitionNumber int, @ParamFragmentationLevel float OUTPUT, @ParamPageCount bigint OUTPUT', @ParamDatabaseName = @CurrentDatabaseName, @ParamObjectID = @CurrentObjectID, @ParamIndexID = @CurrentIndexID, @ParamPartitionNumber = @CurrentPartitionNumber, @ParamFragmentationLevel = @CurrentFragmentationLevel OUTPUT, @ParamPageCount = @CurrentPageCount OUTPUT
          END TRY
          BEGIN CATCH
            SET @ErrorMessage = 'Msg ' + CAST(ERROR_NUMBER() AS nvarchar) + ', ' + ISNULL(ERROR_MESSAGE(),'') + CASE WHEN ERROR_NUMBER() = 1222 THEN ' The index ' + QUOTENAME(@CurrentIndexName) + ' on the object ' + QUOTENAME(@CurrentDatabaseName) + '.' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' is locked. The page_count and avg_fragmentation_in_percent could not be checked.' ELSE '' END
            SET @Severity = CASE WHEN ERROR_NUMBER() IN(1205,1222) THEN @LockMessageSeverity ELSE 16 END
            RAISERROR('%s',@Severity,1,@ErrorMessage) WITH NOWAIT
            RAISERROR(@EmptyLine,10,1) WITH NOWAIT

            IF NOT (ERROR_NUMBER() IN(1205,1222) AND @LockMessageSeverity = 10)
            BEGIN
              SET @ReturnCode = ERROR_NUMBER()
            END

            GOTO NoAction
          END CATCH
        END

        -- Select fragmentation group
        IF @CurrentIndexID IS NOT NULL AND @CurrentOnReadOnlyFileGroup = 0 AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          SET @CurrentFragmentationGroup = CASE
          WHEN @CurrentFragmentationLevel >= @FragmentationLevel2 THEN 'High'
          WHEN @CurrentFragmentationLevel >= @FragmentationLevel1 AND @CurrentFragmentationLevel < @FragmentationLevel2 THEN 'Medium'
          WHEN @CurrentFragmentationLevel < @FragmentationLevel1 THEN 'Low'
          END
        END

        -- Which actions are allowed?
        IF @CurrentIndexID IS NOT NULL AND EXISTS(SELECT * FROM @ActionsPreferred)
        BEGIN
          IF @CurrentOnReadOnlyFileGroup = 0 AND @CurrentIndexType IN (1,2,3,4,5) AND (@CurrentIsMemoryOptimized = 0 OR @CurrentIsMemoryOptimized IS NULL) AND (@CurrentAllowPageLocks = 1 OR @CurrentIndexType = 5)
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES ('INDEX_REORGANIZE')
          END
          IF @CurrentOnReadOnlyFileGroup = 0 AND @CurrentIndexType IN (1,2,3,4,5) AND (@CurrentIsMemoryOptimized = 0 OR @CurrentIsMemoryOptimized IS NULL)
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES ('INDEX_REBUILD_OFFLINE')
          END
          IF @CurrentOnReadOnlyFileGroup = 0
          AND (@CurrentIsMemoryOptimized = 0 OR @CurrentIsMemoryOptimized IS NULL)
          AND (@CurrentIsPartition = 0 OR @Version >= 12)
          AND ((@CurrentIndexType = 1 AND @CurrentIsImageText = 0 AND @CurrentIsNewLOB = 0)
          OR (@CurrentIndexType = 2 AND @CurrentIsNewLOB = 0)
          OR (@CurrentIndexType = 1 AND @CurrentIsImageText = 0 AND @CurrentIsFileStream = 0 AND @Version >= 11)
          OR (@CurrentIndexType = 2 AND @Version >= 11))
          AND (@CurrentIsColumnStore = 0 OR @Version < 11)
          AND SERVERPROPERTY('EngineEdition') IN (3,5,8)
          BEGIN
            INSERT INTO @CurrentActionsAllowed ([Action])
            VALUES ('INDEX_REBUILD_ONLINE')
          END
        END

        -- Decide action
        IF @CurrentIndexID IS NOT NULL
        AND EXISTS(SELECT * FROM @ActionsPreferred)
        AND (@CurrentPageCount >= @MinNumberOfPages OR @MinNumberOfPages = 0)
        AND (@CurrentPageCount <= @MaxNumberOfPages OR @MaxNumberOfPages IS NULL)
        AND @CurrentResumableIndexOperation = 0
        BEGIN
          IF EXISTS(SELECT [Priority], [Action], COUNT(*) FROM @ActionsPreferred GROUP BY [Priority], [Action] HAVING COUNT(*) <> 3)
          BEGIN
            SELECT @CurrentAction = [Action]
            FROM @ActionsPreferred
            WHERE FragmentationGroup = @CurrentFragmentationGroup
            AND [Priority] = (SELECT MIN([Priority])
                              FROM @ActionsPreferred
                              WHERE FragmentationGroup = @CurrentFragmentationGroup
                              AND [Action] IN (SELECT [Action] FROM @CurrentActionsAllowed))
          END
          ELSE
          BEGIN
            SELECT @CurrentAction = [Action]
            FROM @ActionsPreferred
            WHERE [Priority] = (SELECT MIN([Priority])
                                FROM @ActionsPreferred
                                WHERE [Action] IN (SELECT [Action] FROM @CurrentActionsAllowed))
          END
        END

        IF @CurrentResumableIndexOperation = 1
        BEGIN
          SET @CurrentAction = 'INDEX_REBUILD_ONLINE'
        END

        -- Workaround for limitation in SQL Server, http://support.microsoft.com/kb/2292737
        IF @CurrentIndexID IS NOT NULL
        BEGIN
          SET @CurrentMaxDOP = @MaxDOP

          IF @CurrentAction = 'INDEX_REBUILD_ONLINE' AND @CurrentAllowPageLocks = 0
          BEGIN
            SET @CurrentMaxDOP = 1
          END
        END

        -- Update statistics?
        IF @CurrentStatisticsID IS NOT NULL
        AND ((@UpdateStatistics = 'ALL' AND (@CurrentIndexType IN (1,2,3,4,7) OR @CurrentIndexID IS NULL)) OR (@UpdateStatistics = 'INDEX' AND @CurrentIndexID IS NOT NULL AND @CurrentIndexType IN (1,2,3,4,7)) OR (@UpdateStatistics = 'COLUMNS' AND @CurrentIndexID IS NULL))
        AND ((@OnlyModifiedStatistics = 'N' AND @StatisticsModificationLevel IS NULL) OR (@OnlyModifiedStatistics = 'Y' AND @CurrentModificationCounter > 0) OR ((@CurrentModificationCounter * 1. / NULLIF(@CurrentRowCount,0)) * 100 >= @StatisticsModificationLevel) OR (@StatisticsModificationLevel IS NOT NULL AND @CurrentModificationCounter > 0 AND (@CurrentModificationCounter >= SQRT(@CurrentRowCount * 1000))) OR (@CurrentIsMemoryOptimized = 1 AND NOT (@Version >= 13 OR SERVERPROPERTY('EngineEdition') IN (5,8))))
        AND ((@CurrentIsPartition = 0 AND (@CurrentAction NOT IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') OR @CurrentAction IS NULL)) OR (@CurrentIsPartition = 1 AND (@CurrentPartitionNumber = @CurrentPartitionCount OR (@PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1))))
        BEGIN
          SET @CurrentUpdateStatistics = 'Y'
        END
        ELSE
        BEGIN
          SET @CurrentUpdateStatistics = 'N'
        END

        SET @CurrentStatisticsSample = @StatisticsSample
        SET @CurrentStatisticsResample = @StatisticsResample

        -- Memory-optimized tables only supports FULLSCAN and RESAMPLE in SQL Server 2014
        IF @CurrentIsMemoryOptimized = 1 AND NOT (@Version >= 13 OR SERVERPROPERTY('EngineEdition') IN (5,8)) AND (@CurrentStatisticsSample <> 100 OR @CurrentStatisticsSample IS NULL)
        BEGIN
          SET @CurrentStatisticsSample = NULL
          SET @CurrentStatisticsResample = 'Y'
        END

        -- Incremental statistics only supports RESAMPLE
        IF @PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1
        BEGIN
          SET @CurrentStatisticsSample = NULL
          SET @CurrentStatisticsResample = 'Y'
        END

        -- Create index comment
        IF @CurrentIndexID IS NOT NULL
        BEGIN
          SET @CurrentComment = 'ObjectType: ' + CASE WHEN @CurrentObjectType = 'U' THEN 'Table' WHEN @CurrentObjectType = 'V' THEN 'View' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'IndexType: ' + CASE WHEN @CurrentIndexType = 1 THEN 'Clustered' WHEN @CurrentIndexType = 2 THEN 'NonClustered' WHEN @CurrentIndexType = 3 THEN 'XML' WHEN @CurrentIndexType = 4 THEN 'Spatial' WHEN @CurrentIndexType = 5 THEN 'Clustered Columnstore' WHEN @CurrentIndexType = 6 THEN 'NonClustered Columnstore' WHEN @CurrentIndexType = 7 THEN 'NonClustered Hash' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'ImageText: ' + CASE WHEN @CurrentIsImageText = 1 THEN 'Yes' WHEN @CurrentIsImageText = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'NewLOB: ' + CASE WHEN @CurrentIsNewLOB = 1 THEN 'Yes' WHEN @CurrentIsNewLOB = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'FileStream: ' + CASE WHEN @CurrentIsFileStream = 1 THEN 'Yes' WHEN @CurrentIsFileStream = 0 THEN 'No' ELSE 'N/A' END + ', '
          IF @Version >= 11 SET @CurrentComment += 'ColumnStore: ' + CASE WHEN @CurrentIsColumnStore = 1 THEN 'Yes' WHEN @CurrentIsColumnStore = 0 THEN 'No' ELSE 'N/A' END + ', '
          IF @Version >= 14 AND @Resumable = 'Y' SET @CurrentComment += 'Computed: ' + CASE WHEN @CurrentIsComputed = 1 THEN 'Yes' WHEN @CurrentIsComputed = 0 THEN 'No' ELSE 'N/A' END + ', '
          IF @Version >= 14 AND @Resumable = 'Y' SET @CurrentComment += 'Timestamp: ' + CASE WHEN @CurrentIsTimestamp = 1 THEN 'Yes' WHEN @CurrentIsTimestamp = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'AllowPageLocks: ' + CASE WHEN @CurrentAllowPageLocks = 1 THEN 'Yes' WHEN @CurrentAllowPageLocks = 0 THEN 'No' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'PageCount: ' + ISNULL(CAST(@CurrentPageCount AS nvarchar),'N/A') + ', '
          SET @CurrentComment += 'Fragmentation: ' + ISNULL(CAST(@CurrentFragmentationLevel AS nvarchar),'N/A')
        END

        IF @CurrentIndexID IS NOT NULL AND (@CurrentPageCount IS NOT NULL OR @CurrentFragmentationLevel IS NOT NULL)
        BEGIN
        SET @CurrentExtendedInfo = (SELECT *
                                    FROM (SELECT CAST(@CurrentPageCount AS nvarchar) AS [PageCount],
                                                 CAST(@CurrentFragmentationLevel AS nvarchar) AS Fragmentation
                                    ) ExtendedInfo FOR XML RAW('ExtendedInfo'), ELEMENTS)
        END

        IF @CurrentIndexID IS NOT NULL AND @CurrentAction IS NOT NULL AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
        BEGIN
          SET @CurrentDatabaseContext = @CurrentDatabaseName

          SET @CurrentCommandType = 'ALTER_INDEX'

          SET @CurrentCommand = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand += 'ALTER INDEX ' + QUOTENAME(@CurrentIndexName) + ' ON ' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName)
          IF @CurrentResumableIndexOperation = 1 SET @CurrentCommand += ' RESUME'
          IF @CurrentAction IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') AND @CurrentResumableIndexOperation = 0 SET @CurrentCommand += ' REBUILD'
          IF @CurrentAction IN('INDEX_REORGANIZE') AND @CurrentResumableIndexOperation = 0 SET @CurrentCommand += ' REORGANIZE'
          IF @CurrentIsPartition = 1 AND @CurrentResumableIndexOperation = 0 SET @CurrentCommand += ' PARTITION = ' + CAST(@CurrentPartitionNumber AS nvarchar)

          IF @CurrentAction IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') AND @SortInTempdb = 'Y' AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'SORT_IN_TEMPDB = ON'
          END

          IF @CurrentAction IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') AND @SortInTempdb = 'N' AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'SORT_IN_TEMPDB = OFF'
          END

          IF @CurrentAction = 'INDEX_REBUILD_ONLINE' AND (@CurrentIsPartition = 0 OR @Version >= 12) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'ONLINE = ON' + CASE WHEN @WaitAtLowPriorityMaxDuration IS NOT NULL THEN ' (WAIT_AT_LOW_PRIORITY (MAX_DURATION = ' + CAST(@WaitAtLowPriorityMaxDuration AS nvarchar) + ', ABORT_AFTER_WAIT = ' + UPPER(@WaitAtLowPriorityAbortAfterWait) + '))' ELSE '' END
          END

          IF @CurrentAction = 'INDEX_REBUILD_OFFLINE' AND (@CurrentIsPartition = 0 OR @Version >= 12) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'ONLINE = OFF'
          END

          IF @CurrentAction IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') AND @CurrentMaxDOP IS NOT NULL
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'MAXDOP = ' + CAST(@CurrentMaxDOP AS nvarchar)
          END

          IF @CurrentAction IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') AND @FillFactor IS NOT NULL AND @CurrentIsPartition = 0 AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'FILLFACTOR = ' + CAST(@FillFactor AS nvarchar)
          END

          IF @CurrentAction IN('INDEX_REBUILD_ONLINE','INDEX_REBUILD_OFFLINE') AND @PadIndex = 'Y' AND @CurrentIsPartition = 0 AND @CurrentIndexType IN(1,2,3,4) AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'PAD_INDEX = ON'
          END

          IF (@Version >= 14 OR SERVERPROPERTY('EngineEdition') IN (5,8)) AND @CurrentAction = 'INDEX_REBUILD_ONLINE' AND @CurrentResumableIndexOperation = 0
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT CASE WHEN @Resumable = 'Y' AND @CurrentIndexType IN(1,2) AND @CurrentIsComputed = 0 AND @CurrentIsTimestamp = 0 THEN 'RESUMABLE = ON' ELSE 'RESUMABLE = OFF' END
          END

          IF (@Version >= 14 OR SERVERPROPERTY('EngineEdition') IN (5,8)) AND @CurrentAction = 'INDEX_REBUILD_ONLINE' AND @CurrentResumableIndexOperation = 0 AND @Resumable = 'Y'  AND @CurrentIndexType IN(1,2) AND @CurrentIsComputed = 0 AND @CurrentIsTimestamp = 0 AND @TimeLimit IS NOT NULL
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'MAX_DURATION = ' + CAST(DATEDIFF(MINUTE,SYSDATETIME(),DATEADD(SECOND,@TimeLimit,@StartTime)) AS nvarchar(max))
          END

          IF @CurrentAction IN('INDEX_REORGANIZE') AND @LOBCompaction = 'Y'
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'LOB_COMPACTION = ON'
          END

          IF @CurrentAction IN('INDEX_REORGANIZE') AND @LOBCompaction = 'N'
          BEGIN
            INSERT INTO @CurrentAlterIndexWithClauseArguments (Argument)
            SELECT 'LOB_COMPACTION = OFF'
          END

          IF EXISTS (SELECT * FROM @CurrentAlterIndexWithClauseArguments)
          BEGIN
            SET @CurrentAlterIndexWithClause = ' WITH ('

            WHILE (1 = 1)
            BEGIN
              SELECT TOP 1 @CurrentAlterIndexArgumentID = ID,
                           @CurrentAlterIndexArgument = Argument
              FROM @CurrentAlterIndexWithClauseArguments
              WHERE Added = 0
              ORDER BY ID ASC

              IF @@ROWCOUNT = 0
              BEGIN
                BREAK
              END

              SET @CurrentAlterIndexWithClause += @CurrentAlterIndexArgument + ', '

              UPDATE @CurrentAlterIndexWithClauseArguments
              SET Added = 1
              WHERE [ID] = @CurrentAlterIndexArgumentID
            END

            SET @CurrentAlterIndexWithClause = RTRIM(@CurrentAlterIndexWithClause)

            SET @CurrentAlterIndexWithClause = LEFT(@CurrentAlterIndexWithClause,LEN(@CurrentAlterIndexWithClause) - 1)

            SET @CurrentAlterIndexWithClause = @CurrentAlterIndexWithClause + ')'
          END

          IF @CurrentAlterIndexWithClause IS NOT NULL SET @CurrentCommand += @CurrentAlterIndexWithClause

          EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseName, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 2, @Comment = @CurrentComment, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @IndexName = @CurrentIndexName, @IndexType = @CurrentIndexType, @PartitionNumber = @CurrentPartitionNumber, @ExtendedInfo = @CurrentExtendedInfo, @LockMessageSeverity = @LockMessageSeverity, @ExecuteAsUser = @ExecuteAsUser, @LogToTable = @LogToTable, @Execute = @Execute
          SET @Error = @@ERROR
          IF @Error <> 0 SET @CurrentCommandOutput = @Error
          IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput

          IF @Delay > 0
          BEGIN
            SET @CurrentDelay = DATEADD(ss,@Delay,'1900-01-01')
            WAITFOR DELAY @CurrentDelay
          END
        END

        SET @CurrentMaxDOP = @MaxDOP

        -- Create statistics comment
        IF @CurrentStatisticsID IS NOT NULL
        BEGIN
          SET @CurrentComment = 'ObjectType: ' + CASE WHEN @CurrentObjectType = 'U' THEN 'Table' WHEN @CurrentObjectType = 'V' THEN 'View' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'IndexType: ' + CASE WHEN @CurrentIndexID IS NOT NULL THEN 'Index' ELSE 'Column' END + ', '
          IF @CurrentIndexID IS NOT NULL SET @CurrentComment += 'IndexType: ' + CASE WHEN @CurrentIndexType = 1 THEN 'Clustered' WHEN @CurrentIndexType = 2 THEN 'NonClustered' WHEN @CurrentIndexType = 3 THEN 'XML' WHEN @CurrentIndexType = 4 THEN 'Spatial' WHEN @CurrentIndexType = 5 THEN 'Clustered Columnstore' WHEN @CurrentIndexType = 6 THEN 'NonClustered Columnstore' WHEN @CurrentIndexType = 7 THEN 'NonClustered Hash' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'Incremental: ' + CASE WHEN @CurrentIsIncremental = 1 THEN 'Y' WHEN @CurrentIsIncremental = 0 THEN 'N' ELSE 'N/A' END + ', '
          SET @CurrentComment += 'RowCount: ' + ISNULL(CAST(@CurrentRowCount AS nvarchar),'N/A') + ', '
          SET @CurrentComment += 'ModificationCounter: ' + ISNULL(CAST(@CurrentModificationCounter AS nvarchar),'N/A')
        END

        IF @CurrentStatisticsID IS NOT NULL AND (@CurrentRowCount IS NOT NULL OR @CurrentModificationCounter IS NOT NULL)
        BEGIN
        SET @CurrentExtendedInfo = (SELECT *
                                    FROM (SELECT CAST(@CurrentRowCount AS nvarchar) AS [RowCount],
                                                 CAST(@CurrentModificationCounter AS nvarchar) AS ModificationCounter
                                    ) ExtendedInfo FOR XML RAW('ExtendedInfo'), ELEMENTS)
        END

        IF @CurrentStatisticsID IS NOT NULL AND @CurrentUpdateStatistics = 'Y' AND (SYSDATETIME() < DATEADD(SECOND,@TimeLimit,@StartTime) OR @TimeLimit IS NULL)
        BEGIN
          SET @CurrentDatabaseContext = @CurrentDatabaseName

          SET @CurrentCommandType = 'UPDATE_STATISTICS'

          SET @CurrentCommand = ''
          IF @LockTimeout IS NOT NULL SET @CurrentCommand = 'SET LOCK_TIMEOUT ' + CAST(@LockTimeout * 1000 AS nvarchar) + '; '
          SET @CurrentCommand += 'UPDATE STATISTICS ' + QUOTENAME(@CurrentSchemaName) + '.' + QUOTENAME(@CurrentObjectName) + ' ' + QUOTENAME(@CurrentStatisticsName)

          IF @CurrentMaxDOP IS NOT NULL AND ((@Version >= 12.06024 AND @Version < 13) OR (@Version >= 13.05026 AND @Version < 14) OR @Version >= 14.030154)
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT 'MAXDOP = ' + CAST(@CurrentMaxDOP AS nvarchar)
          END

          IF @CurrentStatisticsSample = 100
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT 'FULLSCAN'
          END

          IF @CurrentStatisticsSample IS NOT NULL AND @CurrentStatisticsSample <> 100
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT 'SAMPLE ' + CAST(@CurrentStatisticsSample AS nvarchar) + ' PERCENT'
          END

          IF @CurrentStatisticsResample = 'Y'
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT 'RESAMPLE'
          END

          IF @CurrentNoRecompute = 1
          BEGIN
            INSERT INTO @CurrentUpdateStatisticsWithClauseArguments (Argument)
            SELECT 'NORECOMPUTE'
          END

          IF EXISTS (SELECT * FROM @CurrentUpdateStatisticsWithClauseArguments)
          BEGIN
            SET @CurrentUpdateStatisticsWithClause = ' WITH'

            WHILE (1 = 1)
            BEGIN
              SELECT TOP 1 @CurrentUpdateStatisticsArgumentID = ID,
                           @CurrentUpdateStatisticsArgument = Argument
              FROM @CurrentUpdateStatisticsWithClauseArguments
              WHERE Added = 0
              ORDER BY ID ASC

              IF @@ROWCOUNT = 0
              BEGIN
                BREAK
              END

              SET @CurrentUpdateStatisticsWithClause = @CurrentUpdateStatisticsWithClause + ' ' + @CurrentUpdateStatisticsArgument + ','

              UPDATE @CurrentUpdateStatisticsWithClauseArguments
              SET Added = 1
              WHERE [ID] = @CurrentUpdateStatisticsArgumentID
            END

            SET @CurrentUpdateStatisticsWithClause = LEFT(@CurrentUpdateStatisticsWithClause,LEN(@CurrentUpdateStatisticsWithClause) - 1)
          END

          IF @CurrentUpdateStatisticsWithClause IS NOT NULL SET @CurrentCommand += @CurrentUpdateStatisticsWithClause

          IF @PartitionLevelStatistics = 1 AND @CurrentIsIncremental = 1 AND @CurrentPartitionNumber IS NOT NULL SET @CurrentCommand += ' ON PARTITIONS(' + CAST(@CurrentPartitionNumber AS nvarchar(max)) + ')'

          EXECUTE @CurrentCommandOutput = dbo.CommandExecute @DatabaseContext = @CurrentDatabaseName, @Command = @CurrentCommand, @CommandType = @CurrentCommandType, @Mode = 2, @Comment = @CurrentComment, @DatabaseName = @CurrentDatabaseName, @SchemaName = @CurrentSchemaName, @ObjectName = @CurrentObjectName, @ObjectType = @CurrentObjectType, @IndexName = @CurrentIndexName, @IndexType = @CurrentIndexType, @StatisticsName = @CurrentStatisticsName, @ExtendedInfo = @CurrentExtendedInfo, @LockMessageSeverity = @LockMessageSeverity, @ExecuteAsUser = @ExecuteAsUser, @LogToTable = @LogToTable, @Execute = @Execute
          SET @Error = @@ERROR
          IF @Error <> 0 SET @CurrentCommandOutput = @Error
          IF @CurrentCommandOutput <> 0 SET @ReturnCode = @CurrentCommandOutput
        END

        NoAction:

        -- Update that the index or statistics is completed
        UPDATE @tmpIndexesStatistics
        SET Completed = 1
        WHERE Selected = 1
        AND Completed = 0
        AND [Order] = @CurrentIxOrder
        AND ID = @CurrentIxID

        -- Clear variables
        SET @CurrentDatabaseContext = NULL

        SET @CurrentCommand = NULL
        SET @CurrentCommandOutput = NULL
        SET @CurrentCommandType = NULL
        SET @CurrentComment = NULL
        SET @CurrentExtendedInfo = NULL

        SET @CurrentIxID = NULL
        SET @CurrentIxOrder = NULL
        SET @CurrentSchemaID = NULL
        SET @CurrentSchemaName = NULL
        SET @CurrentObjectID = NULL
        SET @CurrentObjectName = NULL
        SET @CurrentObjectType = NULL
        SET @CurrentIsMemoryOptimized = NULL
        SET @CurrentIndexID = NULL
        SET @CurrentIndexName = NULL
        SET @CurrentIndexType = NULL
        SET @CurrentStatisticsID = NULL
        SET @CurrentStatisticsName = NULL
        SET @CurrentPartitionID = NULL
        SET @CurrentPartitionNumber = NULL
        SET @CurrentPartitionCount = NULL
        SET @CurrentIsPartition = NULL
        SET @CurrentIndexExists = NULL
        SET @CurrentStatisticsExists = NULL
        SET @CurrentIsImageText = NULL
        SET @CurrentIsNewLOB = NULL
        SET @CurrentIsFileStream = NULL
        SET @CurrentIsColumnStore = NULL
        SET @CurrentIsComputed = NULL
        SET @CurrentIsTimestamp = NULL
        SET @CurrentAllowPageLocks = NULL
        SET @CurrentNoRecompute = NULL
        SET @CurrentIsIncremental = NULL
        SET @CurrentRowCount = NULL
        SET @CurrentModificationCounter = NULL
        SET @CurrentOnReadOnlyFileGroup = NULL
        SET @CurrentResumableIndexOperation = NULL
        SET @CurrentFragmentationLevel = NULL
        SET @CurrentPageCount = NULL
        SET @CurrentFragmentationGroup = NULL
        SET @CurrentAction = NULL
        SET @CurrentMaxDOP = NULL
        SET @CurrentUpdateStatistics = NULL
        SET @CurrentStatisticsSample = NULL
        SET @CurrentStatisticsResample = NULL
        SET @CurrentAlterIndexArgumentID = NULL
        SET @CurrentAlterIndexArgument = NULL
        SET @CurrentAlterIndexWithClause = NULL
        SET @CurrentUpdateStatisticsArgumentID = NULL
        SET @CurrentUpdateStatisticsArgument = NULL
        SET @CurrentUpdateStatisticsWithClause = NULL

        DELETE FROM @CurrentActionsAllowed
        DELETE FROM @CurrentAlterIndexWithClauseArguments
        DELETE FROM @CurrentUpdateStatisticsWithClauseArguments

      END

    END

    IF @CurrentDatabaseState = 'SUSPECT'
    BEGIN
      SET @ErrorMessage = 'The database ' + QUOTENAME(@CurrentDatabaseName) + ' is in a SUSPECT state.'
      RAISERROR('%s',16,1,@ErrorMessage) WITH NOWAIT
      RAISERROR(@EmptyLine,10,1) WITH NOWAIT
      SET @Error = @@ERROR
    END

    -- Update that the database is completed
    IF @DatabasesInParallel = 'Y'
    BEGIN
      UPDATE dbo.QueueDatabase
      SET DatabaseEndTime = SYSDATETIME()
      WHERE QueueID = @QueueID
      AND DatabaseName = @CurrentDatabaseName
    END
    ELSE
    BEGIN
      UPDATE @tmpDatabases
      SET Completed = 1
      WHERE Selected = 1
      AND Completed = 0
      AND ID = @CurrentDBID
    END

    -- Clear variables
    SET @CurrentDBID = NULL
    SET @CurrentDatabaseName = NULL

    SET @CurrentDatabase_sp_executesql = NULL

    SET @CurrentExecuteAsUserExists = NULL
    SET @CurrentUserAccess = NULL
    SET @CurrentIsReadOnly = NULL
    SET @CurrentDatabaseState = NULL
    SET @CurrentInStandby = NULL
    SET @CurrentRecoveryModel = NULL

    SET @CurrentIsDatabaseAccessible = NULL
    SET @CurrentReplicaID = NULL
    SET @CurrentAvailabilityGroupID = NULL
    SET @CurrentAvailabilityGroup = NULL
    SET @CurrentAvailabilityGroupRole = NULL
    SET @CurrentDatabaseMirroringRole = NULL

    SET @CurrentCommand = NULL

    DELETE FROM @tmpIndexesStatistics

  END

  ----------------------------------------------------------------------------------------------------
  --// Log completing information                                                                 //--
  ----------------------------------------------------------------------------------------------------

  Logging:
  SET @EndMessage = 'Date and time: ' + CONVERT(nvarchar,SYSDATETIME(),120)
  RAISERROR('%s',10,1,@EndMessage) WITH NOWAIT

  RAISERROR(@EmptyLine,10,1) WITH NOWAIT

  IF @ReturnCode <> 0
  BEGIN
    RETURN @ReturnCode
  END

  ----------------------------------------------------------------------------------------------------

END

GO

/****** Object:  StoredProcedure [dbo].[Indexreport]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

Create PROCEDURE [dbo].[Indexreport] 
AS
BEGIN

SELECT S.name as 'Schema', T.name as 'Table', I.name as 'Index', DDIPS.avg_fragmentation_in_percent, DDIPS.page_count FROM sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL, NULL, NULL) AS DDIPS INNER JOIN sys.tables T on T.object_id = DDIPS.object_id INNER JOIN sys.schemas S on T.schema_id = S.schema_id INNER JOIN sys.indexes I ON I.object_id = DDIPS.object_id AND DDIPS.index_id = I.index_id WHERE DDIPS.database_id = DB_ID() and I.name is not null --AND DDIPS.avg_fragmentation_in_percent > 0 ORDER BY t.name asc;
end
GO

/****** Object:  StoredProcedure [dbo].[Log_File_Size_Data_Collection]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE [dbo].[Log_File_Size_Data_Collection] 
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @DBName NVARCHAR(100) = NULL, --Provide DBName if looking for a specific database or leave to get all databases details
            @Drive NVARCHAR(2) = NULL; --Mention drive letter if you are concerned of only a single drive where you are running out of space
 
    DECLARE @cmd NVARCHAR(4000);
    IF (SELECT OBJECT_ID('tempdb.dbo.#DBName')) IS NOT NULL
        DROP TABLE #DBName;
    CREATE TABLE #DBName (Name NVARCHAR(100));
 
    IF @DBName IS NOT NULL
        INSERT INTO #DBName SELECT @DBName;
    ELSE
        INSERT INTO #DBName SELECT Name FROM sys.databases WHERE state_desc = 'ONLINE';
 
    IF (SELECT OBJECT_ID('tempdb.dbo.##FileStats')) IS NOT NULL
        DROP TABLE ##FileStats;
    CREATE TABLE ##FileStats (DBName NVARCHAR(100), [Autogrowth Inc MB] nvarchar(100), [Autogrowth Inc %] nvarchar(50),
    [AutogrowthStatus] varchar(100), DiskDrive varchar(10), DiskFreeSpaceMB varchar(20), FileType NVARCHAR(100), 
    FileName NVARCHAR(100), TotalLogfileSizeMB FLOAT, FreeSpaceMB FLOAT, PercentMBFree FLOAT, FileLocation NVARCHAR(1000), 
    AutoGrowthMB varchar(60), LogDate DATETIME Default GetDate(), LastTlogBackupTime1 DATETIME, LastTlogBackupTime2 DATETIME);

    WHILE (SELECT TOP 1 * FROM #DBName) IS NOT NULL
    BEGIN
        SELECT @DBName = MIN(Name) FROM #DBName;

        SET @cmd = 'USE [' + @DBName + ']
        INSERT INTO ##FileStats
        SELECT DB_NAME() AS DbName,
        mf.growth/128 as [Autogrowth Inc MB],
        CASE
            WHEN mf.is_percent_growth = 0 THEN 0
            WHEN mf.is_percent_growth = 1 THEN growth
        END as [Autogrowth Inc %],
        CASE 
            WHEN mf.max_size = ''-1'' THEN ''Autogrowth ON''
            WHEN mf.max_size = ''268435456'' THEN ''Autogrowth ON''
            ELSE ''Autogrowth OFF''
        END as [AutogrowthStatus],
        REPLACE(vs.volume_mount_point, '':'', '''') AS Drive,
        ROUND(vs.available_bytes / 1048576.0, 2) AS DiskFreeSpaceMB,  -- Changed to MB
        CASE WHEN type = 0 THEN ''DATA'' ELSE ''LOG'' END AS FileType,
        name AS FileName, 
        size/128.0 AS CurrentSizeMB,  
        size/128.0 - CAST(FILEPROPERTY(name, ''SpaceUsed'') AS INT)/128.0 AS FreeSpaceMB,
        100*(1 - ((CAST(FILEPROPERTY(name, ''SpaceUsed'') AS INT)/128.0)/(size/128.0))) AS PercentMBFree,
        physical_name AS FileLocation,
        CASE WHEN mf.max_size = -1 THEN ''Unlimited'' ELSE CAST(ROUND(CAST(max_size * 8.0 / 1024.0 AS DECIMAL(18, 2)), 2) AS VARCHAR(20))  END AS AutoGrowthMB,
        GetDate(), 

        -- Get the Last Two Log Backup Times
        (SELECT MAX(backup_finish_date) 
         FROM (SELECT TOP 2 backup_finish_date
               FROM msdb.dbo.backupset 
               WHERE database_name = ''' + @DBName + ''' AND type = ''L''
               ORDER BY backup_finish_date DESC) AS RecentBackups) AS LastTlogBackupTime1,
        
        (SELECT MIN(backup_finish_date) 
         FROM (SELECT TOP 2 backup_finish_date
               FROM msdb.dbo.backupset 
               WHERE database_name = ''' + @DBName + ''' AND type = ''L''
               ORDER BY backup_finish_date DESC) AS RecentBackups) AS LastTlogBackupTime2

        FROM sys.database_files mf
        CROSS APPLY sys.dm_os_volume_stats(DB_ID(), mf.file_id) vs
        WHERE type_desc =''log''';

        IF @Drive IS NOT NULL
            SET @cmd = @cmd + ' WHERE physical_name LIKE ''' + @Drive + ':\%''';

        EXEC sp_executesql @cmd;

        DELETE FROM #DBName WHERE Name = @DBName;
    END

    -- Insert data into your final table
    INSERT INTO DBADB..Log_File_Size
    SELECT * 
    FROM ##FileStats
    ORDER BY FreeSpaceMB DESC;

    DROP TABLE #DBName;
    DROP TABLE ##FileStats;
END
GO

/****** Object:  StoredProcedure [dbo].[LOGFILEALERT]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[LOGFILEALERT] 
AS
BEGIN

SET NOCOUNT ON
DECLARE @DBName NVARCHAR(100) = NULL, --Provide DBName if looking for a specific database or leave to get all databases details
        @Drive NVARCHAR(2) = NULL --Mention drive letter if you are concerned of only a single drive where you are running out of space
 
DECLARE @cmd NVARCHAR(4000)
IF (SELECT OBJECT_ID('tempdb.dbo.#DBName')) IS NOT NULL
DROP TABLE #DBName
CREATE TABLE #DBName (Name NVARCHAR(100))
 
IF @DBName IS NOT NULL
INSERT INTO #DBName SELECT @DBName
ELSE
INSERT INTO #DBName SELECT Name FROM sys.databases WHERE state_desc = 'ONLINE'
 
IF (SELECT OBJECT_ID('tempdb.dbo.##FileStats')) IS NOT NULL
DROP TABLE ##FileStats
CREATE TABLE ##FileStats (ServerName NVARCHAR(100), DBName NVARCHAR(100), DiskDrive varchar(10), DiskFreeSpace varchar(20),FileType NVARCHAR(100), 
FileName NVARCHAR(100), CurrentSizeMB FLOAT, FreeSpaceMB FLOAT, PercentMBFree FLOAT, FileLocation NVARCHAR(1000),AutoGrowthGB varchar(60))
 
WHILE (SELECT TOP 1 * FROM #DBName) IS NOT NULL
BEGIN
 
    SELECT @DBName = MIN(Name) FROM #DBName
 
    SET @cmd = 'USE [' + @DBName + ']
    INSERT INTO ##FileStats
    SELECT @@ServerName AS ServerName, DB_NAME() AS DbName, 
REPLACE(vs.volume_mount_point,'':'', '''') AS Drive,
    ROUND(vs.available_bytes / 1073741824.0, 2) AS FreeSpaceGB,
    CASE WHEN type = 0 THEN ''DATA'' ELSE ''LOG'' END AS FileType,
    name AS FileName, 
    size/128.0 AS CurrentSizeMB,  
    size/128.0 - CAST(FILEPROPERTY(name, ''SpaceUsed'') AS INT)/128.0 AS FreeSpaceMB,
    100*(1 - ((CAST(FILEPROPERTY(name, ''SpaceUsed'') AS INT)/128.0)/(size/128.0))) AS PercentMBFree,
    physical_name AS FileLocation,
	CASE WHEN mf.max_size = -1 THEN ''Unlimited'' ELSE CAST(ROUND(CAST(max_size*8.0/1024.0/1024.0 AS DECIMAL(18, 2)), 2) AS VARCHAR(20)) END AS AutoGrowthGB
    FROM sys.database_files mf
	CROSS APPLY sys.dm_os_volume_stats(DB_ID(), mf.file_id) vs
	where type_desc =''log'''
     
    IF @Drive IS NOT NULL
    SET @cmd = @cmd + ' WHERE physical_name LIKE ''' + @Drive + ':\%'''
 
    EXEC sp_executesql @cmd
     
    DELETE FROM #DBName WHERE Name = @DBName
     
END
 
SELECT * FROM ##FileStats
ORDER BY FreeSpaceMB DESC

DROP TABLE #DBName
DROP TABLE ##FileStats
END
GO

/****** Object:  StoredProcedure [dbo].[monitor_job_failures]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[monitor_job_failures]
	@minutes_to_monitor SMALLINT = 1440
AS
BEGIN
	SET NOCOUNT ON;
	-- Determine UTC offset so that all times can easily be converted to UTC.
	DECLARE @utc_offset INT;
	SELECT
		@utc_offset = -1 * DATEDIFF(HOUR, GETUTCDATE(), GETDATE());
		MERGE INTO dbo.sql_server_agent_job AS TARGET
		USING (SELECT
					sysjobs.job_id AS sql_server_agent_job_id_guid,
					sysjobs.name AS sql_server_agent_job_name,
					sysjobs.date_created AS job_create_datetime_utc,
					sysjobs.date_modified AS job_last_modified_datetime_utc,
					sysjobs.enabled AS is_enabled,
					0 AS is_deleted,
					ISNULL(syscategories.name, '') AS job_category_name
			   FROM msdb.dbo.sysjobs
			   LEFT JOIN msdb.dbo.syscategories
			   ON syscategories.category_id = sysjobs.category_id) AS SOURCE
		ON (SOURCE.sql_server_agent_job_id_guid = TARGET.sql_server_agent_job_id_guid)
		WHEN NOT MATCHED BY TARGET
			THEN INSERT
				(sql_server_agent_job_id_guid, sql_server_agent_job_name, job_create_datetime_utc, job_last_modified_datetime_utc,
				 is_enabled, is_deleted, job_category_name)
			VALUES	(
				SOURCE.sql_server_agent_job_id_guid,
				SOURCE.sql_server_agent_job_name,
				SOURCE.job_create_datetime_utc,
				SOURCE.job_last_modified_datetime_utc,
				SOURCE.is_enabled,
				SOURCE.is_deleted,
				SOURCE.job_category_name)
		WHEN MATCHED AND SOURCE.job_last_modified_datetime_utc > TARGET.job_last_modified_datetime_utc
			THEN UPDATE
				SET sql_server_agent_job_name = SOURCE.sql_server_agent_job_name,
					job_create_datetime_utc = SOURCE.job_create_datetime_utc,
					job_last_modified_datetime_utc = SOURCE.job_last_modified_datetime_utc,
					is_enabled = SOURCE.is_enabled,
					is_deleted = SOURCE.is_deleted,
					job_category_name = SOURCE.job_category_name;
					UPDATE sql_server_agent_job
		SET is_enabled = 0,
			is_deleted = 1
	FROM dbo.sql_server_agent_job
	LEFT JOIN msdb.dbo.sysjobs
	ON sysjobs.Job_Id = sql_server_agent_job.sql_server_agent_job_id_guid
	WHERE sysjobs.Job_Id IS NULL AND sysjobs.enabled = 1;
	WITH CTE_NORMALIZE_DATETIME_DATA AS (
		SELECT
			sysjobhistory.job_id AS sql_server_agent_job_id_guid,
			CAST(sysjobhistory.run_date AS VARCHAR(MAX)) AS run_date_string, 
			REPLICATE('0', 6 - LEN(CAST(sysjobhistory.run_time AS VARCHAR(MAX)))) + CAST(sysjobhistory.run_time AS VARCHAR(MAX)) AS run_time_string,
			REPLICATE('0', 6 - LEN(CAST(sysjobhistory.run_duration AS VARCHAR(MAX)))) + CAST(sysjobhistory.run_duration AS VARCHAR(MAX)) AS run_duration_string,
			sysjobhistory.run_status,
			sysjobhistory.message,
			sysjobhistory.instance_id
		FROM msdb.dbo.sysjobhistory WITH (NOLOCK)
		WHERE sysjobhistory.run_status = 0
		AND sysjobhistory.step_id = 0),
	CTE_GENERATE_DATETIME_DATA AS (
		SELECT
			CTE_NORMALIZE_DATETIME_DATA.sql_server_agent_job_id_guid,
			CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_date_string, 5, 2) + '/' + SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_date_string, 7, 2) + '/' + SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_date_string, 1, 4) AS DATETIME) +
			CAST(STUFF(STUFF(CTE_NORMALIZE_DATETIME_DATA.run_time_string, 5, 0, ':'), 3, 0, ':') AS DATETIME) AS job_start_datetime,
			CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_duration_string, 1, 2) AS INT) * 3600 +
				CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_duration_string, 3, 2) AS INT) * 60 + 
				CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_duration_string, 5, 2) AS INT) AS job_duration_seconds,
			CASE CTE_NORMALIZE_DATETIME_DATA.run_status
				WHEN 0 THEN 'Failure'
				WHEN 1 THEN 'Success'
				WHEN 2 THEN 'Retry'
				WHEN 3 THEN 'Canceled'
				ELSE 'Unknown'
			END AS job_status,
			CTE_NORMALIZE_DATETIME_DATA.message,
			CTE_NORMALIZE_DATETIME_DATA.instance_id
		FROM CTE_NORMALIZE_DATETIME_DATA)
	SELECT
		CTE_GENERATE_DATETIME_DATA.sql_server_agent_job_id_guid,
		DATEADD(HOUR, @utc_offset, CTE_GENERATE_DATETIME_DATA.job_start_datetime) AS job_start_time_utc,
		DATEADD(HOUR, @utc_offset, DATEADD(SECOND, ISNULL(CTE_GENERATE_DATETIME_DATA.job_duration_seconds, 0), CTE_GENERATE_DATETIME_DATA.job_start_datetime)) AS job_failure_time_utc,
		ISNULL(CTE_GENERATE_DATETIME_DATA.message, '') AS job_failure_message,
		CTE_GENERATE_DATETIME_DATA.instance_id
	INTO #job_failure
	FROM CTE_GENERATE_DATETIME_DATA
	WHERE DATEADD(HOUR, @utc_offset, CTE_GENERATE_DATETIME_DATA.job_start_datetime) > DATEADD(MINUTE, -1 * @minutes_to_monitor, GETUTCDATE());
	WITH CTE_NORMALIZE_DATETIME_DATA AS (
		SELECT
			sysjobhistory.job_id AS sql_server_agent_job_id_guid,
			CAST(sysjobhistory.run_date AS VARCHAR(MAX)) AS run_date_string, 
			REPLICATE('0', 6 - LEN(CAST(sysjobhistory.run_time AS VARCHAR(MAX)))) + CAST(sysjobhistory.run_time AS VARCHAR(MAX)) AS run_time_string,
			REPLICATE('0', 6 - LEN(CAST(sysjobhistory.run_duration AS VARCHAR(MAX)))) + CAST(sysjobhistory.run_duration AS VARCHAR(MAX)) AS run_duration_string,
			sysjobhistory.run_status,
			sysjobhistory.step_id,
			sysjobhistory.step_name,
			sysjobhistory.message,
			sysjobhistory.retries_attempted,
			sysjobhistory.sql_severity,
			sysjobhistory.sql_message_id,
			sysjobhistory.instance_id
		FROM msdb.dbo.sysjobhistory WITH (NOLOCK)
		WHERE sysjobhistory.run_status = 0
		AND sysjobhistory.step_id > 0),
	CTE_GENERATE_DATETIME_DATA AS (
		SELECT
			CTE_NORMALIZE_DATETIME_DATA.sql_server_agent_job_id_guid,
			CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_date_string, 5, 2) + '/' + SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_date_string, 7, 2) + '/' + SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_date_string, 1, 4) AS DATETIME) +
			CAST(STUFF(STUFF(CTE_NORMALIZE_DATETIME_DATA.run_time_string, 5, 0, ':'), 3, 0, ':') AS DATETIME) AS job_start_datetime,
			CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_duration_string, 1, 2) AS INT) * 3600 +
				CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_duration_string, 3, 2) AS INT) * 60 + 
				CAST(SUBSTRING(CTE_NORMALIZE_DATETIME_DATA.run_duration_string, 5, 2) AS INT) AS job_duration_seconds,
			CASE CTE_NORMALIZE_DATETIME_DATA.run_status
				WHEN 0 THEN 'Failure'
				WHEN 1 THEN 'Success'
				WHEN 2 THEN 'Retry'
				WHEN 3 THEN 'Canceled'
				ELSE 'Unknown'
			END AS job_status,
			CTE_NORMALIZE_DATETIME_DATA.step_id,
			CTE_NORMALIZE_DATETIME_DATA.step_name,
			CTE_NORMALIZE_DATETIME_DATA.message,
			CTE_NORMALIZE_DATETIME_DATA.retries_attempted,
			CTE_NORMALIZE_DATETIME_DATA.sql_severity,
			CTE_NORMALIZE_DATETIME_DATA.sql_message_id,
			CTE_NORMALIZE_DATETIME_DATA.instance_id
		FROM CTE_NORMALIZE_DATETIME_DATA)
	SELECT
		CTE_GENERATE_DATETIME_DATA.sql_server_agent_job_id_guid,
		DATEADD(HOUR, @utc_offset, CTE_GENERATE_DATETIME_DATA.job_start_datetime) AS job_start_time_utc,
		DATEADD(HOUR, @utc_offset, DATEADD(SECOND, ISNULL(CTE_GENERATE_DATETIME_DATA.job_duration_seconds, 0), CTE_GENERATE_DATETIME_DATA.job_start_datetime)) AS job_failure_time_utc,
		CTE_GENERATE_DATETIME_DATA.step_id AS job_failure_step_number,
		ISNULL(CTE_GENERATE_DATETIME_DATA.message, '') AS job_step_failure_message,
		CTE_GENERATE_DATETIME_DATA.sql_severity AS job_step_severity,
		CTE_GENERATE_DATETIME_DATA.retries_attempted,
		CTE_GENERATE_DATETIME_DATA.step_name,
		CTE_GENERATE_DATETIME_DATA.sql_message_id,
		CTE_GENERATE_DATETIME_DATA.instance_id
	INTO #job_step_failure
	FROM CTE_GENERATE_DATETIME_DATA
	WHERE DATEADD(HOUR, @utc_offset, CTE_GENERATE_DATETIME_DATA.job_start_datetime) > DATEADD(MINUTE, -1 * @minutes_to_monitor, GETUTCDATE());
	WITH CTE_FAILURE_STEP AS (
		SELECT
			*,
			ROW_NUMBER() OVER (PARTITION BY job_step_failure.sql_server_agent_job_id_guid, job_step_failure.job_failure_time_utc ORDER BY job_step_failure.job_failure_step_number DESC) AS recent_step_rank
		FROM #job_step_failure job_step_failure)
	INSERT INTO dbo.sql_server_agent_job_failure
		(sql_server_agent_job_id, sql_server_agent_instance_id, job_start_time_utc, job_failure_time_utc, job_failure_step_number, job_failure_step_name,
		 job_failure_message, job_step_failure_message, job_step_severity, job_step_message_id, retries_attempted, has_email_been_sent_to_operator)
	SELECT
		sql_server_agent_job.sql_server_agent_job_id,
		CTE_FAILURE_STEP.instance_id,
		job_failure.job_start_time_utc,
		CTE_FAILURE_STEP.job_failure_time_utc,
		CTE_FAILURE_STEP.job_failure_step_number,
		CTE_FAILURE_STEP.step_name AS job_failure_step_name,
		job_failure.job_failure_message,
		CTE_FAILURE_STEP.job_step_failure_message,
		CTE_FAILURE_STEP.job_step_severity,
		CTE_FAILURE_STEP.sql_message_id AS job_step_message_id,
		CTE_FAILURE_STEP.retries_attempted,
		0 AS has_email_been_sent_to_operator
	FROM #job_failure job_failure
	INNER JOIN dbo.sql_server_agent_job
	ON job_failure.sql_server_agent_job_id_guid = sql_server_agent_job.sql_server_agent_job_id_guid
	INNER JOIN CTE_FAILURE_STEP
	ON job_failure.sql_server_agent_job_id_guid = CTE_FAILURE_STEP.sql_server_agent_job_id_guid
	AND job_failure.job_failure_time_utc = CTE_FAILURE_STEP.job_failure_time_utc
	WHERE CTE_FAILURE_STEP.recent_step_rank = 1
	AND CTE_FAILURE_STEP.instance_id NOT IN (SELECT sql_server_agent_job_failure.sql_server_agent_instance_id FROM dbo.sql_server_agent_job_failure)
	AND sql_server_agent_job.job_category_name <> 'Unmonitored';
	INSERT INTO dbo.sql_server_agent_job_failure
		(sql_server_agent_job_id, sql_server_agent_instance_id, job_start_time_utc, job_failure_time_utc, job_failure_step_number, job_failure_step_name,
		 job_failure_message, job_step_failure_message, job_step_severity, job_step_message_id, retries_attempted, has_email_been_sent_to_operator)
	SELECT
		sql_server_agent_job.sql_server_agent_job_id,
		job_failure.instance_id,
		job_failure.job_start_time_utc,
		job_failure.job_failure_time_utc,
		0 AS job_failure_step_number,
		'' AS job_failure_step_name,
		job_failure.job_failure_message,
		'' AS job_step_failure_message,
		-1 AS job_step_severity,
		-1 AS job_step_message_id,
		0 AS retries_attempted,
		0 AS has_email_been_sent_to_operator
	FROM #job_failure job_failure
	INNER JOIN dbo.sql_server_agent_job
	ON job_failure.sql_server_agent_job_id_guid = sql_server_agent_job.sql_server_agent_job_id_guid
	WHERE job_failure.instance_id NOT IN (SELECT sql_server_agent_job_failure.sql_server_agent_instance_id FROM dbo.sql_server_agent_job_failure)
	AND NOT EXISTS (SELECT * FROM #job_step_failure job_step_failure WHERE job_failure.sql_server_agent_job_id_guid = job_step_failure.sql_server_agent_job_id_guid	AND job_failure.job_failure_time_utc = job_step_failure.job_failure_time_utc);
	WITH CTE_FAILURE_STEP AS (
		SELECT
			*,
			ROW_NUMBER() OVER (PARTITION BY job_step_failure.sql_server_agent_job_id_guid, job_step_failure.job_failure_time_utc ORDER BY job_step_failure.job_failure_step_number DESC) AS recent_step_rank
		FROM #job_step_failure job_step_failure)
	INSERT INTO dbo.sql_server_agent_job_failure
		(sql_server_agent_job_id, sql_server_agent_instance_id, job_start_time_utc, job_failure_time_utc, job_failure_step_number, job_failure_step_name,
		 job_failure_message, job_step_failure_message, job_step_severity, job_step_message_id, retries_attempted, has_email_been_sent_to_operator)
	SELECT
		sql_server_agent_job.sql_server_agent_job_id,
		CTE_FAILURE_STEP.instance_id,
		CTE_FAILURE_STEP.job_start_time_utc,
		CTE_FAILURE_STEP.job_failure_time_utc,
		CTE_FAILURE_STEP.job_failure_step_number,
		CTE_FAILURE_STEP.step_name AS job_failure_step_name,
		'' AS job_failure_message,
		CTE_FAILURE_STEP.job_step_failure_message,
		CTE_FAILURE_STEP.job_step_severity,
		CTE_FAILURE_STEP.sql_message_id AS job_step_message_id,
		CTE_FAILURE_STEP.retries_attempted,
		0 AS has_email_been_sent_to_operator
	FROM CTE_FAILURE_STEP
	INNER JOIN dbo.sql_server_agent_job
	ON CTE_FAILURE_STEP.sql_server_agent_job_id_guid = sql_server_agent_job.sql_server_agent_job_id_guid
	LEFT JOIN #job_failure job_failure
	ON job_failure.sql_server_agent_job_id_guid = CTE_FAILURE_STEP.sql_server_agent_job_id_guid
	AND job_failure.job_failure_time_utc = CTE_FAILURE_STEP.job_failure_time_utc
	WHERE CTE_FAILURE_STEP.recent_step_rank = 1
	AND job_failure.sql_server_agent_job_id_guid IS NULL
	AND CTE_FAILURE_STEP.instance_id NOT IN (SELECT sql_server_agent_job_failure.sql_server_agent_instance_id FROM dbo.sql_server_agent_job_failure);
	DECLARE @profile_name VARCHAR(MAX) = 'DBA';
	DECLARE @email_to_address VARCHAR(MAX) = 'mssqlsupport@geopits.com;dbasupport@geopits.freshdesk.com;retheesh.pillai@thyrocare.com;aswin.kumarvpkothuru@thyrocare.com;db@thyrocare.com';
	DECLARE @email_subject VARCHAR(MAX);
	DECLARE @email_body VARCHAR(MAX);
	DECLARE @job_failure_count INT;
	SELECT
		@job_failure_count = COUNT(*)
	FROM dbo.sql_server_agent_job_failure
	WHERE sql_server_agent_job_failure.has_email_been_sent_to_operator = 0;
 
	-- Send an email to an operator if any new errors are found.
	IF EXISTS (SELECT * FROM dbo.sql_server_agent_job_failure WHERE sql_server_agent_job_failure.has_email_been_sent_to_operator = 0)
	BEGIN
		SELECT @email_subject = 'Failed Job Alert: ' + ISNULL(@@SERVERNAME, CAST(SERVERPROPERTY('ServerName') AS VARCHAR(MAX)));
		SELECT @email_body = 'At least one failure has occurred on ' + ISNULL(@@SERVERNAME, CAST(SERVERPROPERTY('ServerName') AS VARCHAR(MAX))) + ':
<html><body><table border=1>
<tr>
	<th colspan="6" bgcolor="#F29C89" align="left">Total Failed Jobs: ' + CAST(@job_failure_count AS VARCHAR(MAX)) + '</th>
</tr>
<tr>
	<th bgcolor="#F29C89">Job Name</th>
	<th bgcolor="#F29C89">Server Job Start Time</th>
	<th bgcolor="#F29C89">Server Job Failure Time</th>
	<th bgcolor="#F29C89">Failure Step Name</th>
	<th bgcolor="#F29C89">Job Failure Message</th>
	<th bgcolor="#F29C89">Job Step Failure Message</th>
</tr>';
		SELECT @email_body = @email_body + CAST((SELECT CAST(sql_server_agent_job.sql_server_agent_job_name AS VARCHAR(MAX)) AS 'td', '',
										  CAST(DATEADD(HOUR, -1 * @utc_offset, sql_server_agent_job_failure.job_start_time_utc) AS VARCHAR(MAX)) AS 'td', '',
										  CAST(DATEADD(HOUR, -1 * @utc_offset, sql_server_agent_job_failure.job_failure_time_utc) AS VARCHAR(MAX)) AS 'td', '',
										  sql_server_agent_job_failure.job_failure_step_name AS 'td', '',
										  sql_server_agent_job_failure.job_failure_message AS 'td', '',
										  sql_server_agent_job_failure.job_step_failure_message AS 'td'
		FROM dbo.sql_server_agent_job_failure
		INNER JOIN dbo.sql_server_agent_job
		ON sql_server_agent_job.sql_server_agent_job_id = sql_server_agent_job_failure.sql_server_agent_job_id
		WHERE sql_server_agent_job_failure.has_email_been_sent_to_operator = 0
		ORDER BY sql_server_agent_job_failure.job_failure_time_utc ASC
		FOR XML PATH('tr'), ELEMENTS) AS VARCHAR(MAX));
 
		SELECT @email_body = @email_body + '</table></body></html>';
		SELECT @email_body = REPLACE(@email_body, '<td>', '<td valign="top">');
 
		EXEC msdb.dbo.sp_send_dbmail
			@profile_name = @profile_name,
			@recipients = @email_to_address,
			@subject = @email_subject,
			@body_format = 'html',
			@body = @email_body;
 
		UPDATE sql_server_agent_job_failure
			SET has_email_been_sent_to_operator = 1
		FROM dbo.sql_server_agent_job_failure
		WHERE sql_server_agent_job_failure.has_email_been_sent_to_operator = 0;
	END
	END
GO

/****** Object:  StoredProcedure [dbo].[MonitorLogFiles]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO



/****************************************************************************************
* Author: Mike Eastland *
* *
* Purpose: This procedure will check the local instance for databases running low *
* on available transaction log file space. *
****************************************************************************************/
CREATE PROCEDURE [dbo].[MonitorLogFiles] (
@db_name VARCHAR(128) = NULL,
/* Name of specific database to analyze */
@debug_mode BIT = 0,
/* Determines if alerts are sent or just printed */
@growth_cnt INT = 2,
/* Minimum number of file growth operations */
@log_pct FLOAT = 80.00
/* transaction log percent full threshold */
)
AS

SET NOCOUNT ON;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

DECLARE @cmd NVARCHAR(MAX),
@db VARCHAR(128),
@list VARCHAR(MAX),
@msg VARCHAR(MAX),
@sev TINYINT,
@used DECIMAL(5,2);

-- Default parameter values
SELECT @cmd = 'DBCC SQLPERF (LOGSPACE) WITH NO_INFOMSGS',
@growth_cnt = CASE @growth_cnt WHEN 0 THEN 1 ELSE @growth_cnt END,
@sev = CASE @debug_mode WHEN 1 THEN 0 ELSE 16 END;

-- Parameter validation
IF @db_name IS NOT NULL AND DB_ID(@db_name) IS NULL
BEGIN
SELECT @msg = 'Database [' + @db_name + '] not found on ' + @@SERVERNAME +
'. All databases will be analyzed.', @db_name = NULL;
RAISERROR(@msg, 0, 0) WITH NOWAIT;
END

IF @log_pct > 100 OR (@debug_mode = 0 AND @log_pct < 50)
BEGIN
SELECT @msg = 'Invalid log percent used threshold. Default value of 80 will be used.',
@log_pct = 80;
RAISERROR(@msg, 0, 0) WITH NOWAIT;
END

DECLARE @log_used TABLE (
DatabaseName VARCHAR(128),
LogSize FLOAT,
LogSpaceUsed DECIMAL(5,2),
[Status] INT
);

DECLARE @db_logfiles TABLE (
LogicalName VARCHAR(128),
FileID SMALLINT,
PhysicalName VARCHAR(256),
FileGroupName VARCHAR(128),
FileSize VARCHAR(32),
MaxFileSize VARCHAR(32),
GrowthValue VARCHAR(32),
FileUsage VARCHAR(16)
);

DECLARE @svr_logfiles TABLE (
DatabaseName VARCHAR(128),
LogicalName VARCHAR(128),
PhysicalName VARCHAR(256),
PercentUsed DECIMAL(5,2),
FileSize BIGINT,
MaxFileSize BIGINT,
GrowthValue BIGINT
);

DECLARE @svr_drives TABLE (
DriveLetter CHAR(1),
FreeSpace BIGINT
);

-- Populate temp table with free space of all local drives
INSERT INTO @svr_drives
EXEC [master].dbo.xp_fixeddrives;

-- Convert FreeSpace value from MB to KB
UPDATE @svr_drives SET FreeSpace = FreeSpace * 1024;

INSERT INTO @log_used
EXEC sp_ExecuteSQL @cmd;

DECLARE db_csr CURSOR FAST_FORWARD READ_ONLY FOR
SELECT d.name, l.LogSpaceUsed
FROM [master].sys.databases d
INNER JOIN @log_used l ON d.name = l.DatabaseName
WHERE LOWER(d.name) = LOWER(ISNULL(@db_name, d.name))
AND LOWER(d.name) NOT IN ('model', 'northwind', 'pubs')
AND LOWER(d.name) NOT LIKE 'adventurework%'
AND DATABASEPROPERTYEX(d.name, 'Status') = 'ONLINE'
AND DATABASEPROPERTYEX(d.name, 'Updateability') <> 'READ_ONLY'
ORDER BY d.name;

OPEN db_csr;

WHILE 0 = 0
BEGIN
FETCH NEXT FROM db_csr INTO @db, @used;

IF @@FETCH_STATUS <> 0
BREAK;

DELETE FROM @db_logfiles;

SELECT @cmd = '[' + @db + '].dbo.sp_helpfile';

INSERT INTO @db_logfiles
EXEC sp_ExecuteSQL @cmd;

INSERT INTO @svr_logfiles
SELECT @db [DatabaseName],
LogicalName,
PhysicalName,
@used [PercentUsed],
CONVERT(FLOAT, SUBSTRING(FileSize, 1, (CHARINDEX('KB', FileSize)) - 1)) [FileSize],
CASE MaxFileSize
WHEN 'Unlimited' THEN 2147483648
ELSE CONVERT(FLOAT, SUBSTRING(MaxFileSize, 1, (CHARINDEX('KB', MaxFileSize)) - 1))
END [MaxFileSize],
CASE CHARINDEX('%', GrowthValue)
WHEN 0 THEN CONVERT(FLOAT, SUBSTRING(GrowthValue, 1, (CHARINDEX('KB', GrowthValue)) - 1))
ELSE CONVERT(FLOAT, ((CONVERT(DECIMAL(16, 2), SUBSTRING(GrowthValue, 1, (CHARINDEX('%', GrowthValue)) - 1)) / 100) * (CONVERT(FLOAT, SUBSTRING(FileSize, 1, (CHARINDEX('KB', FileSize)) - 1)))))
END [GrowthValue]
FROM @db_logfiles
WHERE LOWER(FileUsage) = 'log only';
END

CLOSE db_csr;
DEALLOCATE db_csr;

IF @debug_mode = 1
SELECT s.DatabaseName
, s.LogicalName
, s.PhysicalName
, s.PercentUsed
, s.FileSize
, s.MaxFileSize
, s.GrowthValue
FROM @svr_logfiles s
INNER JOIN @log_used l ON l.DatabaseName = s.DatabaseName
ORDER BY l.LogSpaceUsed DESC, s.DatabaseName;

-- Remove databases with sufficient log space available from alert consideration
DELETE s
FROM @svr_logfiles s
INNER JOIN @log_used l ON l.DatabaseName = s.DatabaseName
WHERE CONVERT(INT, l.LogSpaceUsed) < @log_pct;

-- No logs can autogrow
SET @list = NULL;

SELECT @list = COALESCE(@list + ', ', '') + a.DatabaseName
FROM @svr_logfiles a
WHERE ( a.GrowthValue = 0
OR a.FileSize = a.MaxFileSize
OR (a.FileSize + (@growth_cnt * a.GrowthValue) >= a.MaxFileSize))
AND NOT EXISTS ( SELECT *
FROM @svr_logfiles b
WHERE b.DatabaseName = a.DatabaseName
AND b.GrowthValue > 0
AND (b.FileSize + (@growth_cnt * b.GrowthValue)) < b.MaxFileSize )
GROUP BY a.DatabaseName;

IF @list IS NOT NULL
BEGIN
SET @msg = 'The following databases are low on available log space and have no log files with proper configuration or sufficient space to autogrow: ' + @list;
RAISERROR(64003, @sev, 1, @msg) WITH LOG, NOWAIT;
END

-- Check for available log growth space on physical drives
SET @list = NULL;

SELECT @list = COALESCE(@list + ', ', '') + d.DriveLetter
FROM @svr_logfiles f
INNER JOIN @svr_drives d ON d.DriveLetter = UPPER(LEFT(f.PhysicalName, 1))
GROUP BY d.DriveLetter, d.FreeSpace
HAVING d.FreeSpace <= SUM(@growth_cnt * f.GrowthValue)
ORDER BY d.DriveLetter;

SET @msg = 'The following drives on ' + @@SERVERNAME + ' do not have enough free space for all files ' +
'to grow by the current value of their respective AutoGrowth parameter: ' + @list;

IF @msg IS NOT NULL
RAISERROR(64003, @sev, 2, @msg) WITH LOG, NOWAIT;

GO

/****** Object:  StoredProcedure [dbo].[report_aut_add_data_section]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS OFF
GO

SET QUOTED_IDENTIFIER ON
GO



--CREATE TYPE [dbo].[Report_Data_Query]
--AS TABLE (query_name SYSNAME, extraction_query NVARCHAR(MAX));
--GO

 
CREATE PROCEDURE [dbo].[report_aut_add_data_section](
    @QUERY NVARCHAR(MAX),
    @QUERYName SYSNAME,
    @resOUTPUT NVARCHAR(MAX) OUTPUT
)
AS
BEGIN
 
    DECLARE @xmlOutput NVARCHAR(MAX)
    DECLARE @xml NVARCHAR(MAX)
    DECLARE @sql NVARCHAR(MAX)
    SET @sql =  N'
        SELECT @xmlOutput = (
            '+@QUERY+'
            FOR XML RAW, ROOT('''+@QUERYName+''')
        )
    '
    exec sp_executesql @sql, N'@xmlOutput NVARCHAR(MAX) OUTPUT', @xmlOutput = @xml OUTPUT;
    SET @resOUTPUT = ISNULL(@resOUTPUT, '') + ISNULL(@xml, '');
 
 
END;
GO

/****** Object:  StoredProcedure [dbo].[report_aut_send_data]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

 

CREATE PROCEDURE [dbo].[report_aut_send_data](
	@Client_Slug VARCHAR(50),
	@profile_name VARCHAR(50),
	@recipients VARCHAR(255)
)
AS
BEGIN
DECLARE query_data_cursor CURSOR FOR
SELECT query_name, query, run_on, renderConfig FROM dbo.report_data_queries
order by [order];
OPEN query_data_cursor
DECLARE @query_name SYSNAME, @run_on SYSNAME, @query VARCHAR(MAX), @renderConfig VARCHAR(MAX);
FETCH NEXT FROM query_data_cursor
INTO @query_name, @query, @run_on, @renderConfig;

DECLARE @SQLString NVARCHAR(MAX);
DECLARE @xmlData VARCHAR(MAX), @resOutput VARCHAR(MAX);
DECLARE @ITEM NVARCHAR(MAX) = N'';
WHILE @@FETCH_STATUS=0
BEGIN
	SET @SQLString = N'
		USE '+ @run_on + ';
		SELECT @xmlOutput = (
            '+@query+'
            FOR XML RAW, ROOT(''data'')
        )
		' + @query+ ';
	';
 

	EXEC sp_executesql @SQLString, N'@xmlOutput NVARCHAR(MAX) OUTPUT', @xmlOutput = @xmlData OUTPUT;
	SET @resOUTPUT = ISNULL(@resOUTPUT, '') + ISNULL(@xmlData, '<data></data>');
	SET @ITEM += '
<Item name="'+@query_name+'" >
'+@renderConfig+'
'+@resOUTPUT+'
</Item>
	';
 

FETCH NEXT FROM query_data_cursor
INTO @query_name, @query, @run_on, @renderConfig;
END
CLOSE query_data_cursor
DEALLOCATE query_data_cursor
SET @ITEM = '<?xml version="1.0" encoding="UTF-8"?>
<ReportData 
		client="'+@Client_Slug+'"
		generatedOn="'+(SELECT CONVERT(VARCHAR, GETDATE(), 126))+'"
		database="MSSQL"
		instanceName="'+ @@SERVERNAME +'"
>
	'+@ITEM+'
</ReportData>
';

SET @ITEM = REPLACE(
    @ITEM,
    '><',
    '>' + CHAR(13) + CHAR(10) + '<'
);

SET @ITEM = REPLACE(@ITEM, '&#x00;', ''); 
DECLARE @FINAL_QUERY NVARCHAR(MAX) = '
PRINT '''+@ITEM+''';
';
DECLARE @SUBJECT VARCHAR(200) ='REPORT_DATA/MSSQL/'+ UPPER(@Client_Slug) + '/' + @@SERVERNAME;
EXEC msdb.dbo.sp_send_dbmail  @profile_name=@profile_name,
@recipients=@recipients,
@subject=@SUBJECT,
@body=@ITEM;
END;
GO

/****** Object:  StoredProcedure [dbo].[report_aut_send_extracted_data]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS OFF
GO

SET QUOTED_IDENTIFIER ON
GO



CREATE PROCEDURE [dbo].[report_aut_send_extracted_data](
    @company_name SYSNAME,
    @extraction_queries [dbo].Report_Data_Query READONLY,
    @profile_name SYSNAME,
    @recipients NVARCHAR(MAX),
	@report_type VARCHAR(2) = 'BW'
)
AS
BEGIN
 
    DECLARE @RES NVARCHAR(MAX)
    DECLARE @Subject NVARCHAR(300)
 
    -- Get the server details
    EXEC report_aut_add_data_section
        @QUERY = '
            SELECT
                @@SERVERNAME AS [Server Name],
                @@VERSION AS [Version],
                sqlserver_start_time AS [Last Recycle],  
                GETDATE() AS [Current Datetime],  
                DATEDIFF(DAY, sqlserver_start_time, GETDATE()) AS [Uptime in Days]
            FROM sys.dm_os_sys_info ',
        @QUERYName = 'header',
        @resOUTPUT = @RES OUTPUT
    
    SET @RES = @RES + CHAR(10)
 
    -- Set the subject of the email
    SET @Subject = '{' + '"company": "' + @company_name + '", "server_name": "' +@@SERVERNAME + '", "report_type":' + '"'+ @report_type +'"' +'}'  
 
    -- Get the query insights
    DECLARE @query_name SYSNAME;
    DECLARE @extract_query NVARCHAR(MAX);
    
 
    
    -- Create a cursor to iterate over the database names
    DECLARE QueryCursor CURSOR LOCAL FOR
        SELECT * FROM @extraction_queries;
 
 
    -- For each database, retrieve the top 5 queries by total logical reads and total CPU time
    OPEN QueryCursor;
 
    FETCH NEXT FROM QueryCursor INTO @query_name, @extract_query;
    WHILE @@FETCH_STATUS=0
    BEGIN
 
        EXEC report_aut_add_data_section
            @QUERY = @extract_query,
            @QUERYName = @query_name,
            @resOUTPUT = @RES OUTPUT
 
        FETCH NEXT FROM QueryCursor INTO @query_name, @extract_query;
        
    END;
 
    CLOSE QueryCursor;
    DEALLOCATE QueryCursor;

    SET @RES = '<data>' + @RES + '</data>';
 
    -- Send the email with the extracted data
    EXEC msdb.dbo.sp_send_dbmail
        @profile_name=@profile_name,
        @recipients = @recipients,
        @subject = @Subject,
        @body = @RES,
        @body_format='TEXT'
END;
GO

/****** Object:  StoredProcedure [dbo].[sp_BlockingDetectionAlert]    Script Date: 2/9/2026 8:31:43 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE [dbo].[sp_BlockingDetectionAlert]
    @BlockingThresholdSeconds INT = 120,
    @EmailProfile NVARCHAR(128) = 'DBA',
    @EmailRecipients NVARCHAR(MAX) = 'aswin.kumarvpkothuru@thyrocare.com;sivaramakrishnan.a@thyrocare.com',
    @SendEmail BIT = 1,
    @ExcludeDistribution BIT = 0,
    @Debug BIT = 0
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Variables for email and processing
    DECLARE @EmailBody NVARCHAR(MAX);
    DECLARE @EmailSubject NVARCHAR(255);
    DECLARE @BlockingCount INT;
    DECLARE @TotalBlockedSessions INT;
    DECLARE @ServerName NVARCHAR(128) = @@SERVERNAME;
    DECLARE @CurrentTime DATETIME = GETDATE();
    
    -- Create temp table for blocking details
    CREATE TABLE #BlockingDetails (
        lead_session_id INT,
        sessions_blocked INT,
        max_blocking_depth INT,
        last_request_start_time DATETIME,
        blocking_duration_seconds INT,
        session_status NVARCHAR(50),
        current_command NVARCHAR(50),
        wait_type NVARCHAR(100),
        wait_resource NVARCHAR(256),
        percent_complete DECIMAL(5,2),
        sql_text NVARCHAR(MAX),
        database_list NVARCHAR(MAX),
        client_net_address NVARCHAR(48),
        login_name NVARCHAR(128),
        program_name NVARCHAR(128),
        host_name NVARCHAR(128),
        cpu_time_ms INT,
        logical_reads BIGINT,
        writes BIGINT,
        longest_blocking_chain NVARCHAR(MAX)
    );
    
    -- Step 1: Detect blocking sessions using recursive CTE
    WITH BlockingHierarchy AS (
        -- Find lead blockers (sessions that block others but aren't blocked themselves)
        SELECT 
            r.blocking_session_id AS lead_session_id,
            r.blocking_session_id AS blocking_session_id,
            r.session_id AS blocked_session_id,
            0 AS level,
            CAST(r.blocking_session_id AS NVARCHAR(MAX)) AS blocking_chain
        FROM sys.dm_exec_requests r
        WHERE r.blocking_session_id <> 0
          AND r.blocking_session_id NOT IN (
              SELECT session_id 
              FROM sys.dm_exec_requests 
              WHERE blocking_session_id <> 0
          )
        
        UNION ALL
        
        -- Recursively find all blocked sessions in the chain
        SELECT 
            bh.lead_session_id,
            r.blocking_session_id,
            r.session_id,
            bh.level + 1,
            bh.blocking_chain + ' -> ' + CAST(r.session_id AS NVARCHAR(MAX))
        FROM sys.dm_exec_requests r
        INNER JOIN BlockingHierarchy bh ON bh.blocked_session_id = r.blocking_session_id
        WHERE bh.level < 10 -- Prevent infinite recursion
    ),
    BlockingSummary AS (
        -- Aggregate blocking information
        SELECT 
            lead_session_id,
            COUNT(DISTINCT blocked_session_id) as sessions_blocked,
            MAX(level) as max_blocking_depth,
            MAX(blocking_chain) as longest_blocking_chain
        FROM BlockingHierarchy
        GROUP BY lead_session_id
    )
    
    -- Step 2: Insert detailed session information into temp table
    INSERT INTO #BlockingDetails
    SELECT 
        bs.lead_session_id,
        bs.sessions_blocked,
        bs.max_blocking_depth,
        s.last_request_start_time,
        DATEDIFF(SECOND, s.last_request_start_time, @CurrentTime) as blocking_duration_seconds,
        ISNULL(r.status, 'sleeping') as session_status,
        ISNULL(r.command, 'N/A') as current_command,
        ISNULL(r.wait_type, 'N/A') as wait_type,
        ISNULL(r.wait_resource, 'N/A') as wait_resource,
        ISNULL(r.percent_complete, 0) as percent_complete,
        ISNULL(st.text, 'N/A') as sql_text,
        -- Get database list for locks held by this session
        ISNULL(STUFF((
            SELECT DISTINCT ', ' + db.name
            FROM sys.databases db
            INNER JOIN sys.dm_tran_locks l ON db.database_id = l.resource_database_id
            WHERE l.request_session_id = s.session_id
              AND db.database_id > 4 -- Exclude system databases
            ORDER BY ', ' + db.name
            FOR XML PATH(''), TYPE
        ).value('.', 'NVARCHAR(MAX)'), 1, 2, ''), 'N/A') as database_list,
        c.client_net_address,
        s.login_name,
        s.program_name,
        s.host_name,
        ISNULL(r.cpu_time, 0) as cpu_time_ms,
        ISNULL(r.reads, 0) as logical_reads,
        ISNULL(r.writes, 0) as writes,
        bs.longest_blocking_chain
    FROM BlockingSummary bs
    INNER JOIN sys.dm_exec_sessions s ON bs.lead_session_id = s.session_id
    LEFT JOIN sys.dm_exec_requests r ON s.session_id = r.session_id
    LEFT JOIN sys.dm_exec_connections c ON s.session_id = c.session_id
    OUTER APPLY sys.dm_exec_sql_text(c.most_recent_sql_handle) st
    WHERE bs.sessions_blocked >= 1
      AND DATEDIFF(SECOND, s.last_request_start_time, @CurrentTime) > @BlockingThresholdSeconds
      --AND (@ExcludeDistribution = 0 OR ISNULL(database_list, '') <> 'distribution');
    
    -- Get counts for summary
    SELECT 
        @BlockingCount = COUNT(*),
        @TotalBlockedSessions = SUM(sessions_blocked)
    FROM #BlockingDetails;
    
    -- Debug output
    IF @Debug = 1
    BEGIN
        PRINT 'Debug: Found ' + CAST(@BlockingCount AS NVARCHAR(10)) + ' blocking session(s)';
        SELECT * FROM #BlockingDetails ORDER BY sessions_blocked DESC, blocking_duration_seconds DESC;
    END
    
    -- Step 3: Process results and send email if blocking sessions found
    IF @BlockingCount > 0
    BEGIN
        -- Console output
        PRINT 'Blocking alert triggered at ' + CONVERT(NVARCHAR(50), @CurrentTime, 121);
        PRINT 'Found ' + CAST(@BlockingCount AS NVARCHAR(10)) + ' lead blocking session(s) affecting ' + 
              CAST(@TotalBlockedSessions AS NVARCHAR(10)) + ' session(s).';
        
        -- Display results in console for immediate review
        SELECT 
            lead_session_id,
            sessions_blocked,
            blocking_duration_seconds,
            session_status,
            wait_type,
            database_list,
            client_net_address,
            login_name,
            LEFT(sql_text, 100) + CASE WHEN LEN(sql_text) > 100 THEN '...' ELSE '' END as sql_preview
        FROM #BlockingDetails
        ORDER BY sessions_blocked DESC, blocking_duration_seconds DESC;
        
        -- Send email if requested
        IF @SendEmail = 1
        BEGIN
            SET @EmailSubject = @ServerName + ' - BLOCKING ALERT: ' + 
                               CAST(@BlockingCount AS NVARCHAR(10)) + ' Lead Blocker(s) Affecting ' + 
                               CAST(@TotalBlockedSessions AS NVARCHAR(10)) + ' Session(s)';
            
            -- Build HTML email body with enhanced formatting
            SET @EmailBody = '
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    .header { background-color: #dc3545; color: white; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
                    .summary { background-color: #f8f9fa; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
                    .blocking-query { background-color: #fff3cd; border: 2px solid #ffc107; padding: 10px; border-radius: 5px; margin-bottom: 15px; }
                    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
                    th { background-color: #007bff; color: white; padding: 8px; text-align: left; }
                    td { padding: 8px; border-bottom: 1px solid #ddd; }
                    .highlight { background-color: #ffeb3b; font-weight: bold; }
                    .sql-text { font-family: "Courier New", monospace; background-color: #f8f9fa; padding: 5px; border-radius: 3px; max-height: 200px; overflow-y: auto; }
                    .warning { color: #dc3545; font-weight: bold; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2> SQL Server Blocking Alert</h2>
                    <p>Server: ' + @ServerName + ' | Time: ' + CONVERT(NVARCHAR(50), @CurrentTime, 121) + '</p>
                </div>
                
                <div class="summary">
                    <h3>Summary</h3>
                    <ul>
                        <li><strong>Lead Blocking Sessions:</strong> ' + CAST(@BlockingCount AS NVARCHAR(10)) + '</li>
                        <li><strong>Total Blocked Sessions:</strong> ' + CAST(@TotalBlockedSessions AS NVARCHAR(10)) + '</li>
                        <li><strong>Detection Threshold:</strong> ' + CAST(@BlockingThresholdSeconds AS NVARCHAR(10)) + ' seconds</li>
                    </ul>
                </div>
                
                <h3>Blocking Session Details</h3>
                <table border="1">
                    <tr>
                        <th>Lead Session</th>
                        <th>Sessions Blocked</th>
                        <th>Duration (sec)</th>
                        <th>Status</th>
                        <th>Wait Type</th>
                        <th>Database(s)</th>
                        <th>Client IP</th>
                        <th>Login</th>
                        <th>Host/Program</th>
                    </tr>';
            
            -- Add blocking session rows
            SELECT @EmailBody += (
                SELECT
                    '<tr>' +
                    '<td class="highlight">' + CAST(lead_session_id AS NVARCHAR(MAX)) + '</td>' +
                    '<td class="warning">' + CAST(sessions_blocked AS NVARCHAR(MAX)) + '</td>' +
                    '<td>' + CAST(blocking_duration_seconds AS NVARCHAR(MAX)) + '</td>' +
                    '<td>' + session_status + '</td>' +
                    '<td>' + wait_type + '</td>' +
                    '<td>' + database_list + '</td>' +
                    '<td>' + ISNULL(client_net_address, 'N/A') + '</td>' +
                    '<td>' + ISNULL(login_name, 'N/A') + '</td>' +
                    '<td>' + ISNULL(host_name, 'N/A') + ' / ' + ISNULL(program_name, 'N/A') + '</td>' +
                    '</tr>'
                FROM #BlockingDetails
                FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)');
            
            SET @EmailBody += '</table>';
            
            -- Add the blocking queries section with highlighting
            SET @EmailBody += '<h3> Blocking Queries (Primary Cause Highlighted)</h3>';
            
            SELECT @EmailBody += (
                SELECT
                    '<div class="blocking-query">' +
                    '<h4>Session ' + CAST(lead_session_id AS NVARCHAR(MAX)) + 
                    ' - Blocking ' + CAST(sessions_blocked AS NVARCHAR(MAX)) + ' session(s)</h4>' +
                    '<p><strong>Started:</strong> ' + CONVERT(NVARCHAR(50), last_request_start_time, 121) + ' ' +
                    '(<span class="warning">' + CAST(blocking_duration_seconds AS NVARCHAR(MAX)) + ' seconds ago</span>)</p>' +
                    '<p><strong>Command:</strong> ' + current_command + '</p>' +
                    '<p><strong>Wait Resource:</strong> ' + wait_resource + '</p>' +
                    CASE 
                        WHEN percent_complete > 0 THEN '<p><strong>Progress:</strong> ' + CAST(percent_complete AS NVARCHAR(MAX)) + '%</p>'
                        ELSE ''
                    END +
                    '<div class="sql-text"><strong>SQL Text:</strong><br/>' + 
                    REPLACE(REPLACE(sql_text, '<', '&lt;'), CHAR(13) + CHAR(10), '<br/>') + 
                    '</div>' +
                    CASE 
                        WHEN longest_blocking_chain IS NOT NULL THEN 
                            '<p><strong>Blocking Chain:</strong> ' + longest_blocking_chain + '</p>'
                        ELSE ''
                    END +
                    '</div>'
                FROM #BlockingDetails
                ORDER BY sessions_blocked DESC, blocking_duration_seconds DESC
                FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)');
            
            SET @EmailBody += '
                <div class="summary">
                    <h4> Recommended Actions</h4>
                    <ul>
                        <li>Review the highlighted blocking queries above</li>
                        <li>Consider killing the blocking session if appropriate: <code>KILL [session_id]</code></li>
                        <li>Investigate why the query is running for an extended time</li>
                        <li>Check for missing indexes or query optimization opportunities</li>
                        <li>Review transaction isolation levels if applicable</li>
                    </ul>
                </div>
                
                <p><em>This alert was generated automatically by the SQL Server blocking detection stored procedure.</em></p>
                <p><em>Procedure: dbadb.dbo.sp_BlockingDetectionAlert</em></p>
            </body>
            </html>';
            
            -- Send the email
            EXEC msdb.dbo.sp_send_dbmail  
                @profile_name = @EmailProfile,
                @recipients = @EmailRecipients,
                @subject = @EmailSubject,
                @body = @EmailBody,
                @body_format = 'HTML';
            
            PRINT 'Blocking alert email sent successfully to: ' + @EmailRecipients;
        END
        ELSE
        BEGIN
            PRINT 'Email sending disabled (@SendEmail = 0)';
        END
    END
    ELSE
    BEGIN
        PRINT 'No blocking sessions detected above the threshold of ' + CAST(@BlockingThresholdSeconds AS NVARCHAR(10)) + ' seconds at ' + CONVERT(NVARCHAR(50), @CurrentTime, 121);
    END
    
    -- Cleanup
    DROP TABLE #BlockingDetails;
    
END
GO

/****** Object:  StoredProcedure [dbo].[SQLhealthcheck_report]    Script Date: 2/9/2026 8:31:44 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


 
 
 
 
/****************************************************************************/  
/*************** SQL SERVER HEALTH CHECK REPORT - HTML **********************/
/****************************************************************************/  
-- Tested: SQL Server 2008 R2, 2012, 2014 and 2016  
-- Report Type: HTML Report Delivers to Mail Box  
-- Parameters: DBMail Profile Name *, Email ID *, Server Name (Optional);   
-- Reports: SQL Server Instance Details  
--   Last 4 days Critical Errors from ErrorLog  
--   Instance Last Recycle Information  
--   Tempdb File Usage  
--             Free Disk Space Report
--   CPU Usage  
--   Memory Usage  
--   Performance Counters Data  
--   Missing Backup Report  
--   Connection Information  
--   Log Space Usage Report  
--   Job Status Report  
--   Blocking Report  
--   Long running Transactions
--   Failed Jobs in Last 24Hrs
/****************************************************************************/  
/****************************************************************************/  
CREATE    PROCEDURE [dbo].[SQLhealthcheck_report] (  
  @MailProfile NVARCHAR(200),   
  @MailID NVARCHAR(2000),  
  @Server VARCHAR(100) = NULL)  
AS  
BEGIN  
SET NOCOUNT ON;  
SET ARITHABORT ON;  
  
DECLARE @ServerName VARCHAR(100);  
SET @ServerName = ISNULL(@Server,@@SERVERNAME);  
  
/*************************************************************/  
/****************** Server Reboot Details ********************/  
/*************************************************************/  
  
CREATE TABLE #RebootDetails                                
(                                
 LastRecycle datetime,                                
 CurrentDate datetime,                                
 UpTimeInDays varchar(100)                          
)                        
Insert into #RebootDetails          
SELECT sqlserver_start_time 'Last Recycle',GetDate() 'Current Date', DATEDIFF(DD, sqlserver_start_time,GETDATE())'Up Time in Days'  
FROM sys.dm_os_sys_info;  
  
/*************************************************************/  
/****************** Errors audit for last 4 Days *************/  
/*************************************************************/  
  
--CREATE TABLE #ErrorLogInfo                                
--(                                
-- LogDate  datetime,  
-- processinfo varchar(500),                                
-- LogInfo  varchar(1000)                                 
--)      
  
--DECLARE @A VARCHAR(10), @B VARCHAR(10);  
--SELECT @A = CONVERT(VARCHAR(20),GETDATE()-1,112);  
--SELECT @B = CONVERT(VARCHAR(20),GETDATE()+1,112);  
--Insert into #ErrorLogInfo  
--EXEC xp_ReadErrorLog 0, 1,N'Login', N'Failed', @A,@B,'DESC';  
 
 
  
/***********************************************************/  
/************* Windows Disk Space Details ******************/  
/***********************************************************/  
 
DECLARE @Result INT
                , @objFSO INT
                , @Drv INT
                , @cDrive VARCHAR(13)
                , @Size VARCHAR(50)
                , @Free VARCHAR(50)
                , @Label varchar(10);
 
CREATE TABLE ##_DriveSpace
                (
                DriveLetter CHAR(1) not null
                , FreeSpace VARCHAR(10) not null
 
                )
 
CREATE TABLE ##_DriveInfo
                (
                DriveLetter CHAR(1)
                , TotalSpace bigint
                , FreeSpace bigint
                , Label varchar(10)
                )
 
INSERT INTO ##_DriveSpace
                EXEC master.dbo.xp_fixeddrives;
 
 
-- Iterate through drive letters.
DECLARE curDriveLetters CURSOR
                FOR SELECT driveletter FROM ##_DriveSpace
 
DECLARE @DriveLetter char(1)
                OPEN curDriveLetters
 
FETCH NEXT FROM curDriveLetters INTO @DriveLetter
WHILE (@@fetch_status <> -1)
BEGIN
                IF (@@fetch_status <> -2)
                BEGIN
 
                                SET @cDrive = 'GetDrive("' + @DriveLetter + '")'
 
                                                EXEC @Result = sp_OACreate 'Scripting.FileSystemObject', @objFSO OUTPUT
 
                                                                IF @Result = 0
 
                                                                                EXEC @Result = sp_OAMethod @objFSO, @cDrive, @Drv OUTPUT
 
                                                                IF @Result = 0
 
                                                                                EXEC @Result = sp_OAGetProperty @Drv,'TotalSize', @Size OUTPUT
 
                                                                IF @Result = 0
 
                                                                                EXEC @Result = sp_OAGetProperty @Drv,'FreeSpace', @Free OUTPUT
 
                                                                IF @Result = 0
 
                                                                                EXEC @Result = sp_OAGetProperty @Drv,'VolumeName', @Label OUTPUT
 
                                                                IF @Result <> 0
 
                                                                                EXEC sp_OADestroy @Drv
                                                                                EXEC sp_OADestroy @objFSO
 
                                                SET @Size = (CONVERT(BIGINT,@Size) / 1048576 )
 
                                                SET @Free = (CONVERT(BIGINT,@Free) / 1048576 )
 
                                                INSERT INTO ##_DriveInfo
                                                                VALUES (@DriveLetter, @Size, @Free, @Label)
 
                END
                FETCH NEXT FROM curDriveLetters INTO @DriveLetter
END
 
CLOSE curDriveLetters
DEALLOCATE curDriveLetters
 
PRINT 'Drive information for server ' + @@SERVERNAME + '.'
PRINT ''
 
-- Produce report.
create table ##temp( DriveLetter VARCHAR(10),FreeSpace_GB VARCHAR(100),UsedSpace_GB varchar(100), TotalSpace_GB VARCHAR(100), Percentage_Free varchar(100))
 
INSERT INTO ##temp
SELECT DriveLetter
                , FreeSpace/1024 AS [FreeSpace_GB]
                , (TotalSpace - FreeSpace)/1024 AS [UsedSpace_GB]
                , TotalSpace/1024 AS [TotalSpace_GB]
                , (convert(INT, (CONVERT(NUMERIC(9,2),FreeSpace) / CONVERT(NUMERIC(9,2),TotalSpace)) * 100)) AS [Percentage_Free]
FROM ##_DriveInfo
ORDER BY [DriveLetter] ASC
  
/*************************************************************/  
/************* SQL Server CPU Usage Details ******************/  
/*************************************************************/  
Create table #CPU(               
servername varchar(100),                           
EventTime2 datetime,                            
SQLProcessUtilization varchar(50),                           
SystemIdle varchar(50),  
OtherProcessUtilization varchar(50),  
load_date datetime                            
)      
DECLARE @ts BIGINT;  DECLARE @lastNmin TINYINT;  
SET @lastNmin = 240;  
SELECT @ts =(SELECT cpu_ticks/(cpu_ticks/ms_ticks) FROM sys.dm_os_sys_info);   
insert into #CPU  
SELECT TOP 10 * FROM (  
SELECT TOP(@lastNmin)  
  @ServerName AS 'ServerName',  
  DATEADD(ms,-1 *(@ts - [timestamp]),GETDATE())AS [Event_Time],   
  SQLProcessUtilization AS [SQLServer_CPU_Utilization],   
  SystemIdle AS [System_Idle_Process],   
  100 - SystemIdle - SQLProcessUtilization AS [Other_Process_CPU_Utilization],  
  GETDATE() AS 'LoadDate'  
FROM (SELECT record.value('(./Record/@id)[1]','int')AS record_id,   
record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]','int')AS [SystemIdle],   
record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]','int')AS [SQLProcessUtilization],   
[timestamp]        
FROM (SELECT[timestamp], convert(xml, record) AS [record]               
FROM sys.dm_os_ring_buffers               
WHERE ring_buffer_type =N'RING_BUFFER_SCHEDULER_MONITOR'AND record LIKE'%%')AS x )AS y   
ORDER BY SystemIdle ASC) d  
  
/*************************************************************/  
/************* SQL Server Memory Usage Details ***************/  
/*************************************************************/  
  
CREATE TABLE #Memory_BPool (  
BPool_Committed_MB VARCHAR(50),  
BPool_Commit_Tgt_MB VARCHAR(50),  
BPool_Visible_MB VARCHAR(50));  
  
-- SQL server 2008 / 2008 R2  
/****  
-- SQL server 2012 / 2014 / 2016  
INSERT INTO #Memory_BPool   
SELECT  
      (committed_kb)/1024.0 as BPool_Committed_MB,  
      (committed_target_kb)/1024.0 as BPool_Commit_Tgt_MB,  
      (visible_target_kb)/1024.0 as BPool_Visible_MB  
FROM  sys.dm_os_sys_info;  
****/  
CREATE TABLE #Memory_sys (  
total_physical_memory_mb VARCHAR(50),  
available_physical_memory_mb VARCHAR(50),  
total_page_file_mb VARCHAR(50),  
available_page_file_mb VARCHAR(50),  
Percentage_Used VARCHAR(50),  
system_memory_state_desc VARCHAR(50));  
  
INSERT INTO #Memory_sys  
select  
      total_physical_memory_kb/1024 AS total_physical_memory_mb,  
      available_physical_memory_kb/1024 AS available_physical_memory_mb,  
      total_page_file_kb/1024 AS total_page_file_mb,  
      available_page_file_kb/1024 AS available_page_file_mb,  
      100 - (100 * CAST(available_physical_memory_kb AS DECIMAL(18,3))/CAST(total_physical_memory_kb AS DECIMAL(18,3)))   
      AS 'Percentage_Used',  
      system_memory_state_desc  
from  sys.dm_os_sys_memory;  
  
  
CREATE TABLE #Memory_process(  
physical_memory_in_use_GB VARCHAR(50),  
locked_page_allocations_GB VARCHAR(50),  
virtual_address_space_committed_GB VARCHAR(50),  
available_commit_limit_GB VARCHAR(50),  
page_fault_count VARCHAR(50))  
  
INSERT INTO #Memory_process  
select  
      physical_memory_in_use_kb/1048576.0 AS 'physical_memory_in_use(GB)',  
      locked_page_allocations_kb/1048576.0 AS 'locked_page_allocations(GB)',  
      virtual_address_space_committed_kb/1048576.0 AS 'virtual_address_space_committed(GB)',  
      available_commit_limit_kb/1048576.0 AS 'available_commit_limit(GB)',  
      page_fault_count as 'page_fault_count'  
from  sys.dm_os_process_memory;  
  
  
CREATE TABLE #Memory(  
Parameter VARCHAR(200),  
Value VARCHAR(100));  
  
INSERT INTO #Memory   
SELECT 'BPool_Committed_MB',BPool_Committed_MB FROM #Memory_BPool  
UNION  
SELECT 'BPool_Commit_Tgt_MB', BPool_Commit_Tgt_MB FROM #Memory_BPool  
UNION   
SELECT 'BPool_Visible_MB', BPool_Visible_MB FROM #Memory_BPool  
UNION  
SELECT 'total_physical_memory_mb',total_physical_memory_mb FROM #Memory_sys  
UNION  
SELECT 'available_physical_memory_mb',available_physical_memory_mb FROM #Memory_sys  
UNION  
SELECT 'total_page_file_mb',total_page_file_mb FROM #Memory_sys  
UNION  
SELECT 'available_page_file_mb',available_page_file_mb FROM #Memory_sys  
UNION  
SELECT 'Percentage_Used',Percentage_Used FROM #Memory_sys  
UNION  
SELECT 'system_memory_state_desc',system_memory_state_desc FROM #Memory_sys  
UNION  
SELECT 'physical_memory_in_use_GB',physical_memory_in_use_GB FROM #Memory_process  
UNION  
SELECT 'locked_page_allocations_GB',locked_page_allocations_GB FROM #Memory_process  
UNION  
SELECT 'virtual_address_space_committed_GB',virtual_address_space_committed_GB FROM #Memory_process  
UNION  
SELECT 'available_commit_limit_GB',available_commit_limit_GB FROM #Memory_process  
UNION  
SELECT 'page_fault_count',page_fault_count FROM #Memory_process;  
  
  
/******************************************************************/  
/*************** Performance Counter Details **********************/  
/******************************************************************/  
  
CREATE TABLE #PerfCntr_Data(  
Parameter VARCHAR(300),  
Value VARCHAR(100));  
  
-- Get size of SQL Server Page in bytes  
DECLARE @pg_size INT, @Instancename varchar(50)  
SELECT @pg_size = low from master..spt_values where number = 1 and type = 'E'  
  
-- Extract perfmon counters to a temporary table  
IF OBJECT_ID('tempdb..#perfmon_counters') is not null DROP TABLE #perfmon_counters  
SELECT * INTO #perfmon_counters FROM sys.dm_os_performance_counters;  
  
-- Get SQL Server instance name as it require for capturing Buffer Cache hit Ratio  
SELECT  @Instancename = LEFT([object_name], (CHARINDEX(':',[object_name])))   
FROM    #perfmon_counters   
WHERE   counter_name = 'Buffer cache hit ratio';  
  
INSERT INTO #PerfCntr_Data  
SELECT CONVERT(VARCHAR(300),Cntr) AS Parameter, CONVERT(VARCHAR(100),Value) AS Value  
FROM  
(  
SELECT  'Total Server Memory (GB)' as Cntr,  
        (cntr_value/1048576.0) AS Value   
FROM    #perfmon_counters   
WHERE   counter_name = 'Total Server Memory (KB)'  
UNION ALL  
SELECT  'Target Server Memory (GB)',   
        (cntr_value/1048576.0)   
FROM    #perfmon_counters   
WHERE   counter_name = 'Target Server Memory (KB)'  
UNION ALL  
SELECT  'Connection Memory (MB)',   
        (cntr_value/1024.0)   
FROM    #perfmon_counters   
WHERE   counter_name = 'Connection Memory (KB)'  
UNION ALL  
SELECT  'Lock Memory (MB)',   
        (cntr_value/1024.0)   
FROM    #perfmon_counters   
WHERE   counter_name = 'Lock Memory (KB)'  
UNION ALL  
SELECT  'SQL Cache Memory (MB)',   
        (cntr_value/1024.0)   
FROM    #perfmon_counters   
WHERE   counter_name = 'SQL Cache Memory (KB)'  
UNION ALL  
SELECT  'Optimizer Memory (MB)',   
        (cntr_value/1024.0)   
FROM    #perfmon_counters   
WHERE   counter_name = 'Optimizer Memory (KB) '  
UNION ALL  
SELECT  'Granted Workspace Memory (MB)',   
        (cntr_value/1024.0)   
FROM    #perfmon_counters   
WHERE   counter_name = 'Granted Workspace Memory (KB) '  
UNION ALL  
SELECT  'Cursor memory usage (MB)',   
        (cntr_value/1024.0)   
FROM    #perfmon_counters   
WHERE   counter_name = 'Cursor memory usage' and instance_name = '_Total'  
UNION ALL  
SELECT  'Total pages Size (MB)',   
        (cntr_value*@pg_size)/1048576.0   
FROM    #perfmon_counters   
WHERE   object_name= @Instancename+'Buffer Manager'   
        and counter_name = 'Total pages'  
UNION ALL  
SELECT  'Database pages (MB)',   
        (cntr_value*@pg_size)/1048576.0   
FROM    #perfmon_counters   
WHERE   object_name = @Instancename+'Buffer Manager' and counter_name = 'Database pages'  
UNION ALL  
SELECT  'Free pages (MB)',   
        (cntr_value*@pg_size)/1048576.0   
FROM    #perfmon_counters   
WHERE   object_name = @Instancename+'Buffer Manager'   
        and counter_name = 'Free pages'  
UNION ALL  
SELECT  'Reserved pages (MB)',   
        (cntr_value*@pg_size)/1048576.0   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Buffer Manager'   
        and counter_name = 'Reserved pages'  
UNION ALL  
SELECT  'Stolen pages (MB)',   
        (cntr_value*@pg_size)/1048576.0   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Buffer Manager'   
        and counter_name = 'Stolen pages'  
UNION ALL  
SELECT  'Cache Pages (MB)',   
        (cntr_value*@pg_size)/1048576.0   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Plan Cache'   
        and counter_name = 'Cache Pages' and instance_name = '_Total'  
UNION ALL  
SELECT  'Page Life Expectency in seconds',  
        cntr_value   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Buffer Manager'   
        and counter_name = 'Page life expectancy'  
UNION ALL  
SELECT  'Free list stalls/sec',  
        cntr_value   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Buffer Manager'   
        and counter_name = 'Free list stalls/sec'  
UNION ALL  
SELECT  'Checkpoint pages/sec',  
        cntr_value   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Buffer Manager'   
        and counter_name = 'Checkpoint pages/sec'  
UNION ALL  
SELECT  'Lazy writes/sec',  
        cntr_value   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Buffer Manager'   
        and counter_name = 'Lazy writes/sec'  
UNION ALL  
SELECT  'Memory Grants Pending',  
        cntr_value   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Memory Manager'   
        and counter_name = 'Memory Grants Pending'  
UNION ALL  
SELECT  'Memory Grants Outstanding',  
        cntr_value   
FROM    #perfmon_counters   
WHERE   object_name=@Instancename+'Memory Manager'   
        and counter_name = 'Memory Grants Outstanding'  
UNION ALL  
SELECT  'process_physical_memory_low',  
        process_physical_memory_low   
FROM    sys.dm_os_process_memory WITH (NOLOCK)  
UNION ALL  
SELECT  'process_virtual_memory_low',  
        process_virtual_memory_low   
FROM    sys.dm_os_process_memory WITH (NOLOCK)  
UNION ALL  
SELECT  'Max_Server_Memory (MB)' ,  
        [value_in_use]   
FROM    sys.configurations   
WHERE   [name] = 'max server memory (MB)'  
UNION ALL  
SELECT  'Min_Server_Memory (MB)' ,  
        [value_in_use]   
FROM    sys.configurations   
WHERE   [name] = 'min server memory (MB)'  
UNION ALL  
SELECT  'BufferCacheHitRatio',  
        (a.cntr_value * 1.0 / b.cntr_value) * 100.0   
FROM    sys.dm_os_performance_counters a  
        JOIN (SELECT cntr_value,OBJECT_NAME FROM sys.dm_os_performance_counters  
              WHERE counter_name = 'Buffer cache hit ratio base' AND   
                    OBJECT_NAME = @Instancename+'Buffer Manager') b ON   
                    a.OBJECT_NAME = b.OBJECT_NAME WHERE a.counter_name = 'Buffer cache hit ratio'   
                    AND a.OBJECT_NAME = @Instancename+'Buffer Manager') AS P;  
  
  
  
/******************************************************************/  
/*************** Database Backup Report ***************************/  
/******************************************************************/  
  
CREATE TABLE #Backup_Report(  
Database_Name VARCHAR(300),  
Last_Backup_Date VARCHAR(50));  
  
INSERT INTO #Backup_Report  
--Databases with data backup over 48 hours old   
SELECT Database_Name, last_db_backup_date AS Last_Backup_Date FROM (  
SELECT CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server,   
  msdb.dbo.backupset.database_name,   
  MAX(msdb.dbo.backupset.backup_finish_date) AS last_db_backup_date,   
  DATEDIFF(hh, MAX(msdb.dbo.backupset.backup_finish_date), GETDATE()) AS [Backup Age (Hours)]   
FROM msdb.dbo.backupset   
WHERE   msdb.dbo.backupset.type = 'D'    
GROUP BY msdb.dbo.backupset.database_name   
HAVING (MAX(msdb.dbo.backupset.backup_finish_date) < DATEADD(DD, -7, GETDATE()))    
UNION    
--Databases without any backup history   
SELECT CONVERT(CHAR(100), SERVERPROPERTY('Servername')) AS Server,    
  sd.NAME AS database_name,    
  NULL AS [Last Data Backup Date],    
  9999 AS [Backup Age (Hours)]    
FROM master.dbo.sysdatabases sd   
  LEFT JOIN msdb.dbo.backupset bs  
  ON sd.name  = bs.database_name   
WHERE bs.database_name IS NULL AND sd.name <> 'tempdb' ) AS B   
ORDER BY Database_Name;   
  
/*************************************************************/  
/****************** Failed Jobs in Last 24Hrs ********************/  
/*************************************************************/
 
create table #Failed_jobs(date_time varchar(100),
job_name varchar(200),
job_step varchar(10),
error_message varchar(max))
 
insert into #Failed_jobs
SELECT MSDB.dbo.agent_datetime(jh.run_date,jh.run_time) as date_time
,j.name as job_name,js.step_id as job_step,jh.message as error_message
FROM msdb.dbo.sysjobs AS j
INNER JOIN msdb.dbo.sysjobsteps AS js ON js.job_id = j.job_id
INNER JOIN msdb.dbo.sysjobhistory AS jh ON jh.job_id = j.job_id AND jh.step_id = js.step_id
WHERE jh.run_status = 0 AND MSDB.dbo.agent_datetime(jh.run_date,jh.run_time) >= GETDATE()-1
ORDER BY MSDB.dbo.agent_datetime(jh.run_date,jh.run_time) DESC
  
/*************************************************************/  
/************** Currently Running Jobs Info ******************/  
/*************************************************************/  
Create table #JobInfo(               
spid varchar(10),                           
lastwaittype varchar(100),                           
dbname varchar(100),                           
login_time varchar(100),                           
status varchar(100),                           
opentran varchar(100),                           
hostname varchar(100),                          
JobName varchar(100),                          
command nvarchar(2000),  
domain varchar(100),   
loginname varchar(100)     
)   
insert into #JobInfo  
SELECT  distinct p.spid,p.lastwaittype,DB_NAME(p.dbid),p.login_time,p.status,p.open_tran,p.hostname,J.name,  
p.cmd,p.nt_domain,p.loginame  
FROM master..sysprocesses p  
INNER JOIN msdb..sysjobs j ON   
substring(left(j.job_id,8),7,2) + substring(left(j.job_id,8),5,2) + substring(left(j.job_id,8),3,2) + substring(left(j.job_id,8),1,2) = substring(p.program_name, 32, 8)   
Inner join msdb..sysjobactivity sj on j.job_id=sj.job_id  
WHERE program_name like'SQLAgent - TSQL JobStep (Job %' and sj.stop_execution_date is null  
  
/*************************************************************/  
/****************** Tempdb File Info *************************/  
/*************************************************************/  
-- tempdb file usage  
Create table #tempdbfileusage(               
servername varchar(100),                           
databasename varchar(100),                           
filename varchar(100),                           
physicalName varchar(100),                           
filesizeMB varchar(100),                           
availableSpaceMB varchar(100),                           
percentfull varchar(100)   
)   
  
DECLARE @TEMPDBSQL NVARCHAR(4000);  
SET @TEMPDBSQL = ' USE Tempdb;  
SELECT  CONVERT(VARCHAR(100), @@SERVERNAME) AS [server_name]  
                ,db.name AS [database_name]  
                ,mf.[name] AS [file_logical_name]  
                ,mf.[filename] AS[file_physical_name]  
                ,convert(FLOAT, mf.[size]/128) AS [file_size_mb]               
                ,convert(FLOAT, (mf.[size]/128 - (CAST(FILEPROPERTY(mf.[name], ''SpaceUsed'') AS int)/128))) as [available_space_mb]  
                ,convert(DECIMAL(38,2), (CAST(FILEPROPERTY(mf.[name], ''SpaceUsed'') AS int)/128.0)/(mf.[size]/128.0))*100 as [percent_full]      
FROM   tempdb.dbo.sysfiles mf  
JOIN      master..sysdatabases db  
ON         db.dbid = db_id()';  
--PRINT @TEMPDBSQL;  
insert into #tempdbfileusage  
EXEC SP_EXECUTESQL @TEMPDBSQL;  
  
  
/*************************************************************/  
/****************** Database Log Usage ***********************/  
/*************************************************************/  
CREATE TABLE #LogSpace(  
DBName VARCHAR(100),  
LogSize VARCHAR(50),  
LogSpaceUsed_Percent VARCHAR(100),   
LStatus CHAR(1));  
  
INSERT INTO #LogSpace  
EXEC ('DBCC SQLPERF(LOGSPACE) WITH NO_INFOMSGS;');  
  
 
  
/*************************************************************/  
/****************** HTML Preparation *************************/  
/*************************************************************/  
  
DECLARE @TableHTML  VARCHAR(MAX),                                    
  @StrSubject VARCHAR(100),                                    
  @Oriserver VARCHAR(100),                                
  @Version VARCHAR(250),                                
  @Edition VARCHAR(100),                                
  @ISClustered VARCHAR(100),                                
  @SP VARCHAR(100),                                
  @ServerCollation VARCHAR(100),                                
  @SingleUser VARCHAR(5),                                
  @LicenseType VARCHAR(100),                                
  @Cnt int,           
  @URL varchar(1000),                                
  @Str varchar(1000),                                
  @NoofCriErrors varchar(3)       
  
-- Variable Assignment              
  
SELECT @Version = @@version                                
SELECT @Edition = CONVERT(VARCHAR(100), serverproperty('Edition'))                                
SET @Cnt = 0                                
IF serverproperty('IsClustered') = 0                                 
BEGIN                                
 SELECT @ISClustered = 'No'                                
END                                
ELSE        
BEGIN                                
 SELECT @ISClustered = 'YES'                                
END                                
SELECT @SP = CONVERT(VARCHAR(100), SERVERPROPERTY ('productlevel'))                                
SELECT @ServerCollation = CONVERT(VARCHAR(100), SERVERPROPERTY ('Collation'))                                 
SELECT @LicenseType = CONVERT(VARCHAR(100), SERVERPROPERTY ('LicenseType'))                                 
SELECT @SingleUser = CASE SERVERPROPERTY ('IsSingleUser')                                
      WHEN 1 THEN 'Yes'                                
      WHEN 0 THEN 'No'                                
      ELSE                                
      'null' END                                
SELECT @OriServer = CONVERT(VARCHAR(50), SERVERPROPERTY('servername'))                                  
SELECT @strSubject = 'Database Server Health Check ('+ CONVERT(VARCHAR(100), @SERVERNAME) + ')'                                    
   
  
  
SET @TableHTML =                                    
 '<font face="Verdana" size="4">Health Check</font>                                  
 <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="47%" id="AutoNumber1" height="50">                                  
 <tr>                                  
 <td width="39%" height="22" bgcolor="#000080"><b>                           
 <font face="Verdana" size="2" color="#FFFFFF">Server Name</font></b></td>                                  
 </tr>                                  
 <tr>                                  
 <td width="39%" height="27"><font face="Verdana" size="2">' + @ServerName +'</font></td>                                  
 </tr>                                  
 </table>                                 
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                
 <tr>                                
 <td align="Center" width="50%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Version</font></b></td>                                
 <td align="Center" width="17%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Edition</font></b></td>                                
 <td align="Center" width="35%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Service Pack</font></b></td>                                
 <td align="Center" width="60%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Collation</font></b></td>                                
 <td align="Center" width="93%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">LicenseType</font></b></td>                                
 <td align="Center" width="40%" bgColor="#000080" height="15"><b>                                
<font face="Verdana" color="#ffffff" size="1">SingleUser</font></b></td>                                
 <td align="Center" width="93%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Clustered</font></b></td>                                
 </tr>                                
 <tr>                                
 <td align="Center" width="50%" height="27"><font face="Verdana" size="1">'+@version +'</font></td>                                
 <td align="Center" width="17%" height="27"><font face="Verdana" size="1">'+@edition+'</font></td>                                
 <td align="Center" width="18%" height="27"><font face="Verdana" size="1">'+@SP+'</font></td>                                
 <td align="Center" width="17%" height="27"><font face="Verdana" size="1">'+@ServerCollation+'</font></td>                                
 <td align="Center" width="25%" height="27"><font face="Verdana" size="1">'+@LicenseType+'</font></td>                                
 <td align="Center" width="25%" height="27"><font face="Verdana" size="1">'+@SingleUser+'</font></td>                                
 <td align="Center" width="93%" height="27"><font face="Verdana" size="1">'+@isclustered+'</font></td>                                
 </tr>                                
 </table>                   
     
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                
 <font face="Verdana" size="4">SQL ErrorLog Summary in Last 24 Hours</font>' +                                    
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="933" bgColor="#ffffff" borderColorLight="#000000" border="1">                                  
 <tr>                                
 <td width="20%" bgColor="#000080" height="15"><b>                        
 <font face="Verdana" color="#ffffff" size="1">Number of Critical Errors</font></b></td>                                
 </tr>                                
 </table>                                
 <table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="933" bgColor="#ffffff" borderColorLight="#000000" border="1">                                  
 <tr>                                
 <td width="20%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Error Log DateTime</font></b></td>                     
 <td width="80%" bgColor="#000080" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Error Message</font></b></td>                                
 </tr>'                                
                
  
--SELECT                                 
-- @TableHTML = @TableHTML + '<tr>                                
-- <td width="20%" height="27"><font face="Verdana" size="1">'+ ISNULL(CONVERT(VARCHAR(50),LogDate ),'') +'</font></td>                                
-- <td width="80%" height="27"><font face="Verdana" size="1">'+ISNULL(CONVERT(VARCHAR(500),LogInfo ),'')+'</font></td>                                
-- </tr>'                                
--FROM  #ErrorLogInfo   ORDER BY      LogDate DESC   
  
  
 SELECT                                   
 @TableHTML = @TableHTML +                                     
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Instance last Recycled</font>                                  
 <table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="933" bgColor="#ffffff" borderColorLight="#000000" border="1">                                      
 <tr>                                      
 <th align="Center" width="50" bgColor="#000080">                                      
  <font face="Verdana" size="1" color="#FFFFFF">Last Recycle</font></th>                                      
 <th align="Center" width="50" bgColor="#000080">                                      
  <font face="Verdana" size="1" color="#FFFFFF">Current DateTime</font></th>                                      
 <th align="Center" width="50" bgColor="#000080">                                   
 <font face="Verdana" size="1" color="#FFFFFF">UpTimeInDays</font></th>                                      
  </tr>'                                  
                                  
SELECT                                   
 @TableHTML =  @TableHTML +                                       
 '<tr>                                    
 <td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), LastRecycle ), '')  +'</font></td>' +                                        
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  CurrentDate ), '')  +'</font></td>' +                                   
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  UpTimeInDays ), '')  +'</font></td>' +                                        
  '</tr>'                                  
FROM                                   
 #RebootDetails   
  
 
/***** Free Disk Space Report ****/  
 
SELECT                                   
 @TableHTML = @TableHTML +                                   
 '</table>                          
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Disk Space Report</font>' +                                      
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="933" bgColor="#ffffff" borderColorLight="#000000" border="1">                                    
 <tr>                                    
 <th align="left" width="30" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">DriveLetter</font></th>   
 <th align="left" width="30" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">FreeSpace_GB</font></th>                                    
 <th align="left" width="30" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">UsedSpace_GB</font></th>                                    
 <th align="left" width="30" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">TotalSpace_GB</font></th>
<th align="left" width="30" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Percentage_Free</font></th>                                                                 
 </tr>'                                    
                                  
SELECT                                   
 @TableHTML = @TableHTML +   
 CASE WHEN Percentage_Free < 10 THEN
   '<tr bgcolor="#ffe6e6">'
ELSE
'<tr>'
END +
'<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), DriveLetter),'') + '</font></td>' +                       
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), FreeSpace_GB),'') + '</font></td>' +                                  
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), UsedSpace_GB),'') +'</font></td>' +     
  '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(max), TotalSpace_GB),'') +'</font></td>' +
--'<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(max), Percentage_Free),'') +'</font></td></tr>'
CASE WHEN Percentage_Free < 10 THEN
  '<td align="Center"><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(CONVERT(VARCHAR(100),  Percentage_Free), '')  +'</font></td>'
ELSE
  '<td align="Center"><font face="Verdana" size="1" color="#40C211"><b>' + ISNULL(CONVERT(VARCHAR(100),  Percentage_Free), '')  +'</font></td>'
  END +
  '</tr>'
FROM ##temp
 
  
/**** Tempdb File Usage *****/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Tempdb File Usage</font>                                  
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="Center" width="300" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Database Name</font></th>               
 <th align="Center" width="300" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">File Name</font></th>               
 <th align="Center" width="250" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Physical Name</font></th>               
 <th align="Center" width="250" bgColor="#000080">                                
 <font face="Verdana" size="1" color="#FFFFFF">FileSize MB</font></th>               
 <th align="Center" width="200" bgColor="#000080">               
 <font face="Verdana" size="1" color="#FFFFFF">Available MB</font></th>               
 <th align="Center" width="200" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Percent_full </font></th>               
   </tr>'                                  
select                                   
@TableHTML =  @TableHTML +                                     
 '<tr>' +                                      
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(databasename, '') + '</font></td>' +                                      
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(FileName, '') +'</font></td>' +                                      
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(physicalName, '') +'</font></td>' +                                      
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(filesizeMB, '') +'</font></td>' +                                  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(availableSpaceMB, '') +'</font></td>' +  
 CASE WHEN CONVERT(DECIMAL(10,3),percentfull) >80.00 THEN    
'<td align="Center"><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(percentfull, '') +'</b></font></td></tr>'                                               
 ELSE  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(percentfull, '') +'</font></td></tr>' END                                
from                                   
 #tempdbfileusage       
  
  
/**** CPU Usage *****/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">CPU Usage Currently</font>                                  
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="Center" width="300" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">System Time</font></th>               
 <th align="Center" width="300" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">SQLProcessUtilization</font></th>               
 <th align="Center" width="250" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">SystemIdle</font></th>               
 <th align="Center" width="250" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">OtherProcessUtilization</font></th>               
 <th align="Center" width="200" bgColor="#000080">               
 <font face="Verdana" size="1" color="#FFFFFF">load DateTime</font></th>               
   </tr>'                                  
SELECT                                   
 @TableHTML =  @TableHTML +                                     
 '<tr>' +                                      
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), EventTime2 ), '')  +'</font></td>' +    
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), SQLProcessUtilization ), '')  +'</font></td>' +    
   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), SystemIdle ), '')  +'</font></td>' +                              
   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), OtherProcessUtilization ), '')  +'</font></td>' +                              
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), load_date ), '')  +'</font></td> </tr>'                                  
FROM                                   
 #CPU   
  
/***** Memory Usage ****/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Memory Usage </font>                                  
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Parameter</font></th>                              
  <th align="left" width="200" bgColor="#000080">               
 <font face="Verdana" size="1" color="#FFFFFF">Value</font></th>              
   </tr>'                                  
SELECT                                   
 @TableHTML =  @TableHTML +                                       
 '<tr>                                    
 <td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(200),  Parameter ), '')  +'</font></td>' +                                        
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  Value ), '')  +'</font></td>' +                                     
  '</tr>'                                  
FROM                                   
 #Memory;   
  
/***** Performance Counter Values ****/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Performance Counter Data</font>                                  
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Performance_Counter</font></th>                              
  <th align="left" width="200" bgColor="#000080">               
 <font face="Verdana" size="1" color="#FFFFFF">Value</font></th>              
   </tr>'                                  
SELECT                                   
 @TableHTML =  @TableHTML +                                       
 '<tr>                                    
 <td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(300),  Parameter ), '')  +'</font></td>' +                                        
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  Value ), '')  +'</font></td>' +                                     
  '</tr>'                                  
FROM                                   
 #PerfCntr_Data;   
   
/***** Database Backup Report ****/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Missing Backup Report</font>                                  
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Database_Name</font></th>                              
  <th align="left" width="200" bgColor="#000080">               
 <font face="Verdana" size="1" color="#FFFFFF">Last_Backup_Date</font></th>              
   </tr>'                                  
SELECT      
 @TableHTML =  @TableHTML +                                       
 '<tr>                                    
 <td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  Database_Name ), '')  +'</font></td>' +                                        
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  Last_Backup_Date), '')  +'</font></td>' +                                     
  '</tr>'                                  
FROM             
 #Backup_Report  
  
 /****** Connection Information *****/  
  
       
      
--/***** Log Space Usage ****/  
--SELECT                                   
-- @TableHTML =  @TableHTML +                              
-- '</table>                                  
-- <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
-- <font face="Verdana" size="4">Log Space Usage </font>                                  
-- <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
--   <tr>                
-- <th align="left" width="136" bgColor="#000080">                                    
-- <font face="Verdana" size="1" color="#FFFFFF">DatabaseName</font></th>                              
--  <th align="left" width="200" bgColor="#000080">               
-- <font face="Verdana" size="1" color="#FFFFFF">Log_Space_Used</font></th>                              
--  <th align="left" width="200" bgColor="#000080">               
-- <font face="Verdana" size="1" color="#FFFFFF">Log_Usage_%</font></th>              
--   </tr>'                                  
--SELECT                                   
-- @TableHTML =  @TableHTML +                                       
-- '<tr>                                    
-- <td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  DBName ), '')  +'</font></td>' +                                        
-- '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  LogSize ), '')  +'</font></td>' +   
-- CASE WHEN CONVERT(DECIMAL(10,3),LogSpaceUsed_Percent) >80.00 THEN  
--  '<td><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(  SUBSTRING( LogSpaceUsed_Percent,1,charindex('.',LogSpaceUsed_Percent)-1), '')  +'</b></font></td>'  
-- ELSE  
-- '<td><font face="Verdana" size="1">' + ISNULL(  SUBSTRING( LogSpaceUsed_Percent,1,charindex('.',LogSpaceUsed_Percent)-1) ,'' )  +'</font></td>'   
-- END +                                     
--  '</tr>'                               
--FROM                                   
-- #LogSpace   

 /***** Log Space Usage ****/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
<p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
<font face="Verdana" size="4">Log Space Usage </font>                                  
<table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                
   <tr>                
 <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">DatabaseName</font></th>                              
  <th align="left" width="200" bgColor="#000080">               
 <font face="Verdana" size="1" color="#FFFFFF">Log_Space_Used</font></th>                              
  <th align="left" width="200" bgColor="#000080">               
 <font face="Verdana" size="1" color="#FFFFFF">Log_Usage_%</font></th>              
   </tr>'                                  
SELECT                                   
 @TableHTML =  @TableHTML +                                       
 '<tr>                                    
 <td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  DBName ), '')  +'</font></td>' +                                        
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  LogSize), '')  +'</font></td>' +   
 CASE WHEN CONVERT(DECIMAL(10,3),LogSpaceUsed_Percent) >80.00 THEN  
  '<td><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(CONVERT(VARCHAR(100),  LogSpaceUsed_Percent ), '')  +'</b></font></td>'  
 ELSE  
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  LogSpaceUsed_Percent ), '')  +'</font></td>'   
 END +                                     
  '</tr>'                               
FROM                                   
 #LogSpace  
 
 /*****Failed Jobs in Last 24Hrs*********/
 
SELECT                                   
 @TableHTML = @TableHTML +                                   
 '</table>                          
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Failed Jobs in Last 24Hrs</font>' +                                      
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="933" bgColor="#ffffff" borderColorLight="#000000" border="1">                                    
 <tr>                                    
 <th align="left" width="430" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">date_time</font></th>   
 <th align="left" width="70" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">job_name</font></th>                                    
 <th align="left" width="85" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">job_step</font></th>                                   
 <th align="left" width="183" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">error_message</font></th>                                                                    
 </tr>'                                    
                                  
SELECT                                   
 @TableHTML = @TableHTML +                                      
'<tr><td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), date_time),'') + '</font></td>' +                       
 '<td><font face="Verdana" size="1" color="#FF0000">' + ISNULL(CONVERT(VARCHAR(50), job_name),'') + '</font></td>' +                                  
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), job_step),'') +'</font></td>' +     
  '<td><font face="Verdana" size="1" color="#FF0000">' + ISNULL(CONVERT(VARCHAR(max), error_message),'') +'</font></td></tr>'      
FROM #Failed_jobs
  
  
/******** Job Info *******/  
SELECT                                   
 @TableHTML = @TableHTML +                                   
 '</table>                          
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4">Job Status</font>' +                                      
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="933" bgColor="#ffffff" borderColorLight="#000000" border="1">                                    
 <tr>                                    
 <th align="left" width="430" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">spid</font></th>   
 <th align="left" width="70" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">latwaittype</font></th>                                    
 <th align="left" width="85" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">dbname</font></th>                                    
 <th align="left" width="183" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Process Login time</font></th>                                    
 <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">status</font></th>                                    
 <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">opentran</font></th>      
  <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">hostname</font></th>    
  <th align="left" width="146" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">JobName</font></th>    
  <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">command</font></th>    
  <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">domain</font></th>     
   <th align="left" width="136" bgColor="#000080">                                    
 <font face="Verdana" size="1" color="#FFFFFF">LoginName</font></th>                                 
 </tr>'                                    
                                  
SELECT                                   
 @TableHTML = ISNULL(CONVERT(VARCHAR(MAX), @TableHTML), 'No Job Running') + '<tr><td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), spid), '') +'</font></td>' +                                      
'<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), lastwaittype),'') + '</font></td>' +                       
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), dbname),'') + '</font></td>' +                                  
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), login_time),'') +'</font></td>' +     
  '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), status),'') +'</font></td>' +     
   '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), opentran),'') +'</font></td>' +     
    '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), hostname),'') +'</font></td>' +     
     '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(500), JobName),'') +'</font></td>' +     
      '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(200), command),'') +'</font></td>' +     
        '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), domain),'') +'</font></td>' +     
 '<td><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50),loginname ),'') + '</font></td></tr>'      
FROM                                   
 #JobInfo  
  
   
   
 /****** Blocking Information ****/  
  
 
  
/**** Long running Transactions*****/  
 
    
EXEC msdb.dbo.sp_send_dbmail                                    
 @profile_name = @MailProfile,                       
 @recipients=@MailID,                                   
 @subject = @strSubject,                                   
 @body = @TableHTML,                                      
 @body_format = 'HTML' ;                               
  
  
DROP TABLE  #RebootDetails  
--DROP TABLE  #ErrorLogInfo  
DROP TABLE  #CPU  
DROP TABLE  #Memory_BPool;  
DROP TABLE  #Memory_sys;  
DROP TABLE  #Memory_process;  
DROP TABLE  #Memory;  
DROP TABLE  #perfmon_counters;  
DROP TABLE  #PerfCntr_Data;  
DROP TABLE  #Backup_Report;  
DROP TABLE  #JobInfo;  
DROP TABLE  #tempdbfileusage;  
DROP TABLE  #LogSpace;  
DROP TABLE  #Failed_jobs;
DROP TABLE ##_DriveSpace;
DROP TABLE ##_DriveInfo;
DROP TABLE ##temp;
  
SET NOCOUNT OFF;  
SET ARITHABORT OFF;  
END  
 
GO

/****** Object:  StoredProcedure [dbo].[SQLhealthcheck_report_new2]    Script Date: 2/9/2026 8:31:44 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO




 
/**************************/  
/***** SQL SERVER HEALTH CHECK REPORT - HTML ********/
/**************************/  
-- Tested: SQL Server 2008 R2, 2012, 2014, 2016, 2017, 2019 and 2022  
-- Report Type: HTML Report Delivers to Mail Box  
-- Parameters: DBMail Profile Name *, Email ID *, Server Name (Optional);   
-- Reports: SQL Server Instance Details
--   AG Status
--   Log Shipping 
--	 Mirroring DB 
--   Instance Last Recycle Information 
--   CPU Usage 
--   PLE Usage
--   Disk Space Usage
--   Tempdb File Usage
--   User DB File Usage
--   Backup Report for User DB 
--   Wait Statistics Report
--   Failed Jobs in Last 24Hrs
--   Long Running Queries Summary
--	 Blocked Queries Summary
--   Index Maintenance Summary

/**************************/  
/**************************/  
CREATE   PROCEDURE [dbo].[SQLhealthcheck_report_new2] (  
  @MailProfile NVARCHAR(50),   
  @MailID NVARCHAR(2000),  
  @Server VARCHAR(max) = NULL,
  @ClientName VARCHAR(max) = NULL)
AS  
BEGIN  
SET NOCOUNT ON;  
SET ARITHABORT ON;  
  
DECLARE @ServerName VARCHAR(max);  
SET @ServerName = ISNULL(@Server,@@SERVERNAME);  
    
/*********************/
/****** Server Reboot Details ********/
/*********************/

IF OBJECT_ID('tempdb..#RebootDetails') IS NOT NULL
    DROP TABLE #RebootDetails;

CREATE TABLE #RebootDetails
(
    ServiceName     VARCHAR(100),
    ServiceStatus   VARCHAR(50),
    RestartTime     VARCHAR(25),
    CurrentTime     VARCHAR(25),
    UpTimeInDays    INT
);

;WITH AgentStartTime AS
(
    SELECT MAX(agent_start_date) AS AgentLastStartTime
    FROM msdb.dbo.syssessions
)
INSERT INTO #RebootDetails
SELECT  
    s.servicename,
    s.status_desc,
    FORMAT(s.last_startup_time, 'yyyy-MM-dd hh:mmtt') AS RestartTime,
    FORMAT(GETDATE(), 'yyyy-MM-dd hh:mmtt')           AS CurrentTime,
    DATEDIFF(DAY, s.last_startup_time, GETDATE())     AS UpTimeInDays
FROM sys.dm_server_services s
WHERE s.servicename LIKE '%SQL Server (%'

UNION ALL

SELECT
    s.servicename,
    s.status_desc,
    FORMAT(ast.AgentLastStartTime, 'yyyy-MM-dd hh:mmtt') AS RestartTime,
    FORMAT(GETDATE(), 'yyyy-MM-dd hh:mmtt')              AS CurrentTime,
    CASE 
        WHEN ast.AgentLastStartTime IS NULL THEN NULL
        ELSE DATEDIFF(DAY, ast.AgentLastStartTime, GETDATE())
    END AS UpTimeInDays
FROM sys.dm_server_services s
CROSS JOIN AgentStartTime ast
WHERE s.servicename LIKE '%SQL Server Agent%';

/*********************/  
/***** Windows Disk Space Details ******/  
/*********************/  
 
 IF OBJECT_ID('tempdb..#output') IS NOT NULL DROP TABLE #output;
IF OBJECT_ID('tempdb..#driveinfo') IS NOT NULL DROP TABLE #driveinfo;
CREATE TABLE #driveinfo (
    Drive_Letter VARCHAR(5),
    TotalSpace_GB    DECIMAL(10,2),
    UsedSpace_GB    DECIMAL(10,2),
    FreeSpace_GB  DECIMAL(10,2),
    Percentage_Full DECIMAL(5,2)
);
declare @svrName varchar(255)
declare @sql varchar(400)
set @svrName = @@SERVERNAME
set @sql = 'powershell.exe -c "Get-WmiObject -ComputerName ' + QUOTENAME(@svrName,'''') + '-Class Win32_Volume -Filter ''DriveType = 3'' | select name,capacity,freespace | foreach{$_.name+''|''+$_.capacity/1048576+''%''+$_.freespace/1048576+''*''}"'
CREATE TABLE #output
(line varchar(255))
insert #output
EXEC xp_cmdshell @sql
insert into #driveinfo
select rtrim(ltrim(SUBSTRING(line,1,CHARINDEX('|',line) -1))) as drivename
   ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('|',line)+1,
   (CHARINDEX('%',line) -1)-CHARINDEX('|',line)) )) as Float)/1024,0) as 'capacity(GB)'
   ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('|',line)+1,
   (CHARINDEX('%',line) -1)-CHARINDEX('|',line)) )) as Float)/1024,0) - round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('%',line)+1,
   (CHARINDEX('*',line) -1)-CHARINDEX('%',line)) )) as Float) /1024 ,0) as 'usedspace(GB)'
   ,round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('%',line)+1,
   (CHARINDEX('*',line) -1)-CHARINDEX('%',line)) )) as Float) /1024 ,0)as 'freespace(GB)'
   ,
   
   cast(
   (round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('|',line)+1,
   (CHARINDEX('%',line) -1)-CHARINDEX('|',line)) )) as Float),0) - 
   round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('%',line)+1,
   (CHARINDEX('*',line) -1)-CHARINDEX('%',line)) )) as Float),0)) /
   round(cast(rtrim(ltrim(SUBSTRING(line,CHARINDEX('|',line)+1,
   (CHARINDEX('%',line) -1)-CHARINDEX('|',line)) )) as Float),0)
    as decimal(18,2)
	)*100 as 'Used %'
from #output where line like '[A-Z][:]%'
order by drivename

/*********************/
/***** SQL Server CPU Usage Summary (Last 24 Hours) ******/
/*********************/
IF OBJECT_ID('tempdb..#CPU') IS NOT NULL
    DROP TABLE #CPU;

CREATE TABLE #CPU
(
    servername         SYSNAME,
    Max_Total_CPU      INT,
    Min_Total_CPU      INT,
    Avg_Total_CPU      INT,
    Max_CPU_Hit_Count  INT,
    load_date          DATETIME
);

;WITH CPUStats AS
(
    SELECT
        SQLUtilisedCPU + Otherprosses AS TotalCPU
    FROM DBADB.dbo.CPUUtilisationdata
    WHERE Time >= DATEADD(HOUR, -24, GETDATE())
),
MaxCPU AS
(
    SELECT MAX(TotalCPU) AS MaxCPUValue
    FROM CPUStats
)
INSERT INTO #CPU
(
    servername,
    Max_Total_CPU,
    Min_Total_CPU,
    Avg_Total_CPU,
    Max_CPU_Hit_Count,
    load_date
)
SELECT
    @@SERVERNAME                                    AS servername,
    MAX(cs.TotalCPU)                               AS Max_Total_CPU,
    MIN(cs.TotalCPU)                               AS Min_Total_CPU,
    AVG(cs.TotalCPU)                               AS Avg_Total_CPU,
    SUM(CASE WHEN cs.TotalCPU = m.MaxCPUValue 
             THEN 1 ELSE 0 END)                    AS Max_CPU_Hit_Count,
    GETDATE()                                      AS load_date
FROM CPUStats cs
CROSS JOIN MaxCPU m;



/*********************/  
/***** SQL Server Memory Usage Details *****/  
/*********************/  
IF OBJECT_ID('tempdb..#PLE') IS NOT NULL
    DROP TABLE #PLE;

CREATE TABLE #PLE
(
    ServerName                 SYSNAME,
    MinPLE                     BIGINT,
    MaxPLE                     BIGINT,
    AvgPLE                     DECIMAL(18,2),
    PLE_Less_Than_300_Count    INT,
    LoadDate                   DATETIME
);

;WITH PLEData AS
(
    SELECT 
        CAST(PageLifeExpectancy AS BIGINT) AS PLE
    FROM DBADB.dbo.PageLifeExpectancyLog
    WHERE LoggedAt >= DATEADD(HOUR, -24, GETDATE())
)
INSERT INTO #PLE
(
    servername,
    MinPLE,
    MaxPLE,
    AvgPLE,
    PLE_Less_Than_300_Count,
    LoadDate
)
SELECT
    @@SERVERNAME                                       AS ServerName,
    MIN(PLE)                                          AS MinPLE,
    MAX(PLE)                                          AS MaxPLE,
    AVG(PLE)                                    AS AvgPLE,
    SUM(CASE WHEN PLE < 300 THEN 1 ELSE 0 END)        AS PLE_Less_Than_300_Count,
    GETDATE()                                         AS LoadDate
FROM PLEData;

/****************************************************
 AG Status Report
****************************************************/
--IF OBJECT_ID('tempdb..#AG_DB_Status') IS NOT NULL
--    DROP TABLE #AG_DB_Status;

--CREATE TABLE #AG_DB_Status
--(
--    AG_Name                     SYSNAME,
--    DatabaseName                SYSNAME,
--    PrimaryServer               SYSNAME,
--    SecondaryServer             SYSNAME,
--    AvailabilityMode            VARCHAR(50),
--    FailoverMode                VARCHAR(50),
--    SynchronizationState        VARCHAR(50),
--    SynchronizationHealth       VARCHAR(50),
--    SuspendReason               VARCHAR(100),
--    LogSendQueue_KB             BIGINT,
--    LogSendRate_KB_per_sec      BIGINT,
--    RedoQueue_KB                BIGINT,
--    RedoRate_KB_per_sec         BIGINT,
--    SecondaryLag_Seconds        BIGINT
--);

--INSERT INTO #AG_DB_Status
--(
--    AG_Name,
--    DatabaseName,
--    PrimaryServer,
--    SecondaryServer,
--    AvailabilityMode,
--    FailoverMode,
--    SynchronizationState,
--    SynchronizationHealth,
--    SuspendReason,
--    LogSendQueue_KB,
--    LogSendRate_KB_per_sec,
--    RedoQueue_KB,
--    RedoRate_KB_per_sec,
--    SecondaryLag_Seconds
--)
--SELECT
--    ag.name                                         AS AG_Name,
--    adc.database_name                               AS DatabaseName,
--    pri.replica_server_name                         AS PrimaryServer,
--    sec.replica_server_name                         AS SecondaryServer,
--    ar.availability_mode_desc                       AS AvailabilityMode,
--    ar.failover_mode_desc                           AS FailoverMode,
--    drs.synchronization_state_desc                  AS SynchronizationState,
--    drs.synchronization_health_desc                 AS SynchronizationHealth,
--    drs.suspend_reason_desc                         AS SuspendReason,
--    drs.log_send_queue_size                         AS LogSendQueue_KB,
--    drs.log_send_rate                               AS LogSendRate_KB_per_sec,
--    drs.redo_queue_size                             AS RedoQueue_KB,
--    drs.redo_rate                                   AS RedoRate_KB_per_sec,
--    drs.secondary_lag_seconds                       AS SecondaryLag_Seconds
--FROM sys.availability_groups ag
--JOIN sys.availability_replicas ar
--    ON ag.group_id = ar.group_id
--JOIN sys.dm_hadr_database_replica_states drs
--    ON ar.replica_id = drs.replica_id
--JOIN sys.availability_databases_cluster adc
--    ON drs.group_database_id = adc.group_database_id
--LEFT JOIN sys.availability_replicas pri
--    ON ag.group_id = pri.group_id
--   AND pri.replica_id = drs.replica_id
--LEFT JOIN sys.availability_replicas sec
--    ON ag.group_id = sec.group_id
--   AND sec.replica_id = drs.replica_id
--   AND drs.is_primary_replica = 0;


/****************************************************
 Log Shipping Report
****************************************************/

IF OBJECT_ID('tempdb..#LogShippingStatus') IS NOT NULL
    DROP TABLE #LogShippingStatus;

CREATE TABLE #LogShippingStatus
(
    PrimaryServer          SYSNAME,
    PrimaryDatabase        SYSNAME,
    BackupDirectory        NVARCHAR(MAX),
    BackupShare            NVARCHAR(MAX),
    LastBackupFile         NVARCHAR(MAX),
    LastBackupDate         VARCHAR(MAX),
    BackupCompression      BIT,

    SecondaryServer        SYSNAME,
    SecondaryDatabase      SYSNAME,
    LastCopiedFile         NVARCHAR(MAX),
    LastCopiedDate         VARCHAR(MAX),
    LastRestoredFile       NVARCHAR(MAX),
    LastRestoredDate       VARCHAR(MAX),
    LastRestoredLatency    INT,

    HealthStatus           VARCHAR(50)
);
INSERT INTO #LogShippingStatus
(
    PrimaryServer,
    PrimaryDatabase,
    BackupDirectory,
    BackupShare,
    LastBackupFile,
    LastBackupDate,
    BackupCompression,
    SecondaryServer,
    SecondaryDatabase,
    LastCopiedFile,
    LastCopiedDate,
    LastRestoredFile,
    LastRestoredDate,
    LastRestoredLatency,
    HealthStatus
)
SELECT
    lsm.primary_server,
    lsp.primary_database,
    lsp.backup_directory,
    lsp.backup_share,
    lsp.last_backup_file,
    lsp.last_backup_date,
    lsp.backup_compression,
    lsm.secondary_server,
    lsm.secondary_database,
    lsm.last_copied_file,
    lsm.last_copied_date,
    lsm.last_restored_file,
    lsm.last_restored_date,
    lsm.last_restored_latency,

    /* Health Status Calculation */
CASE
        WHEN lsm.last_restored_date IS NULL
            THEN 'Restore Not Happening'

        WHEN lsm.last_restored_latency > 60 -- according to client 
            THEN 'Restore Lagging (>60 mins)'

        ELSE 'Healthy'
    END AS HealthStatus

FROM msdb.dbo.log_shipping_primary_databases lsp
JOIN [MISSERVER].msdb.dbo.log_shipping_secondary_databases lss 
    ON lsp.primary_database = lss.secondary_database
JOIN [MISSERVER].msdb.dbo.log_shipping_monitor_secondary lsm 
    ON lss.secondary_id = lsm.secondary_id
WHERE EXISTS
(
    SELECT 1
    FROM sys.databases d
    WHERE d.name = lsp.primary_database
);

/****************************************************
Mirroring Report
****************************************************/

--IF OBJECT_ID('tempdb..#DBMirroringStatus') IS NOT NULL
--    DROP TABLE #DBMirroringStatus;

--CREATE TABLE #DBMirroringStatus
--(
--    DatabaseName            SYSNAME,
--    Role                    VARCHAR(50),
--    State                   VARCHAR(50),
--    MirrorServer            SYSNAME,
--    MirrorServerInstance    SYSNAME,
--    SafetyLevel             VARCHAR(50)
--);

--INSERT INTO #DBMirroringStatus
--(
--    DatabaseName,
--    Role,
--    State,
--    MirrorServer,
--    MirrorServerInstance,
--    SafetyLevel
--)
--SELECT
--    d.name                          AS DatabaseName,
--    dm.mirroring_role_desc          AS Role,
--    dm.mirroring_state_desc         AS State,
--    dm.mirroring_partner_name       AS MirrorServer,
--    dm.mirroring_partner_instance   AS MirrorServerInstance,
--    dm.mirroring_safety_level_desc  AS SafetyLevel
--FROM sys.database_mirroring dm
--JOIN sys.databases d
--    ON dm.database_id = d.database_id
--WHERE dm.mirroring_guid IS NOT NULL;

/*********************/  
/****** Tempdb File Info *********/  
/*********************/  
-- tempdb file usage  
IF OBJECT_ID('tempdb..#tempdbfileusage') IS NOT NULL
    DROP TABLE #tempdbfileusage;

CREATE TABLE #tempdbfileusage
(
    servername        VARCHAR(MAX),
    databasename      VARCHAR(MAX),
    filename          VARCHAR(MAX),
    physicalName      VARCHAR(MAX),
    filesizeGB        DECIMAL(18,2),
    availableSpaceGB  DECIMAL(18,2),
    percentfull       DECIMAL(5,2),
    diskTotalGB       DECIMAL(18,2),
    diskFreeGB        DECIMAL(18,2),
    AutoGrowth        VARCHAR(10),
    AutoGrowthSetting VARCHAR(20),
    MaxSize           VARCHAR(20)
);

DECLARE @TEMPDBSQL NVARCHAR(MAX);

SET @TEMPDBSQL = '
Use tempdb
SELECT
    @@SERVERNAME AS servername,
    ''tempdb'' AS databasename,
    mf.name AS filename,
    mf.physical_name AS physicalName,

    CAST(mf.size * 8.0 / 1024 / 1024 AS DECIMAL(18,2)) AS filesizeGB,
    CAST((mf.size - FILEPROPERTY(mf.name, ''SpaceUsed'')) * 8.0 / 1024 / 1024 AS DECIMAL(18,2)) AS availableSpaceGB,
    CAST(FILEPROPERTY(mf.name, ''SpaceUsed'') * 100.0 / mf.size AS DECIMAL(5,2)) AS percentfull,
    CAST(vs.total_bytes / 1024.0 / 1024 / 1024 AS DECIMAL(18,2)) AS diskTotalGB,
    CAST(vs.available_bytes / 1024.0 / 1024 / 1024 AS DECIMAL(18,2)) AS diskFreeGB,

    CASE 
        WHEN mf.growth = 0 THEN ''OFF''
        ELSE ''ON''
    END AS AutoGrowth,

   CASE 
    WHEN mf.is_percent_growth = 1 
        THEN CAST(mf.growth AS VARCHAR(10)) + ''%''
    ELSE FORMAT(mf.growth * 8 / 1024.0, ''N0'') + '' MB''
END AS AutoGrowthSetting,

CASE 
    WHEN mf.max_size = -1 THEN ''UNLIMITED''
    ELSE FORMAT(mf.max_size * 8.0 / 1024 / 1024, ''N2'') + '' GB''
END AS MaxSize


FROM tempdb.sys.database_files mf
CROSS APPLY sys.dm_os_volume_stats(DB_ID(''tempdb''), mf.file_id) vs;
';

-- Insert data into temp table
INSERT INTO #tempdbfileusage
EXEC sp_executesql @TEMPDBSQL;


/*********************/  
/****** User DB File Info *********/  
/*********************/  
IF OBJECT_ID('tempdb..#UserDBFileUsage') IS NOT NULL
    DROP TABLE #UserDBFileUsage;

CREATE TABLE #UserDBFileUsage
(
    servername        VARCHAR(MAX),
    databasename      VARCHAR(MAX),
    filename          VARCHAR(MAX),
    filetype          VARCHAR(10),
    physicalName      VARCHAR(MAX),
    filesizeGB        DECIMAL(18,2),
    availableSpaceGB  DECIMAL(18,2),
    percentfull       DECIMAL(5,2),
    diskTotalGB       DECIMAL(18,2),
    diskFreeGB        DECIMAL(18,2),
    AutoGrowth        VARCHAR(10),
    AutoGrowthSetting VARCHAR(20),
    MaxSize           VARCHAR(20)
);

DECLARE @SQL1 NVARCHAR(MAX) = N'';
DECLARE @dbname SYSNAME;

DECLARE db_cursor CURSOR FOR
SELECT name
FROM sys.databases
WHERE database_id > 4
  AND state_desc = 'ONLINE';

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @dbname;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @SQL1 += '
	USE ' + QUOTENAME(@dbname) + ';
    INSERT INTO #UserDBFileUsage
    SELECT
        @@SERVERNAME AS servername,
        ''' + @dbname + ''' AS databasename,
        mf.name AS filename,
        CASE mf.type WHEN 0 THEN ''DATA'' WHEN 1 THEN ''LOG'' END AS filetype,
        mf.physical_name AS physicalName,

        CAST(mf.size * 8.0 / 1024 / 1024 AS DECIMAL(18,2)) AS filesizeGB,

        CAST((mf.size - FILEPROPERTY(mf.name, ''SpaceUsed'')) * 8.0 / 1024 / 1024 AS DECIMAL(18,2)) AS availableSpaceGB,

        CAST(FILEPROPERTY(mf.name, ''SpaceUsed'') * 100.0 / mf.size AS DECIMAL(5,2)) AS percentfull,

        CAST(vs.total_bytes / 1024.0 / 1024 / 1024 AS DECIMAL(18,2)) AS diskTotalGB,
        CAST(vs.available_bytes / 1024.0 / 1024 / 1024 AS DECIMAL(18,2)) AS diskFreeGB,

        CASE WHEN mf.growth = 0 THEN ''OFF'' ELSE ''ON'' END AS AutoGrowth,

        CASE 
            WHEN mf.is_percent_growth = 1 THEN CAST(mf.growth AS VARCHAR(10)) + ''%''
            ELSE FORMAT(mf.growth * 8 / 1024.0, ''N0'') + '' MB''
        END AS AutoGrowthSetting,

        CASE 
            WHEN mf.max_size = -1 THEN ''UNLIMITED''
            ELSE FORMAT(mf.max_size * 8.0 / 1024 / 1024, ''N2'') + '' GB''
        END AS MaxSize

    FROM sys.master_files mf
    CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.file_id) vs
    WHERE mf.database_id = DB_ID(''' + @dbname + ''');
    ';

    FETCH NEXT FROM db_cursor INTO @dbname;
END

CLOSE db_cursor;
DEALLOCATE db_cursor;

EXEC sys.sp_executesql @SQL1;

/****************************************************
 Combined Backup Status Report (NO DATE CONDITION)
****************************************************/

IF OBJECT_ID('tempdb..#Backup_Report') IS NOT NULL
    DROP TABLE #Backup_Report;

CREATE TABLE #Backup_Report
(
    DatabaseName           SYSNAME,

    LastFullBackupTime     DATETIME,
    FullBackupSize_GB      DECIMAL(18,2),

    LastDiffBackupTime     DATETIME,
    DiffBackupSize_GB      DECIMAL(18,2),

    LastLogBackupTime      DATETIME,
    LogBackupSize_MB       DECIMAL(18,2)
);

;WITH BackupCTE AS
(
    SELECT
        bs.database_name,
        bs.type,
        bs.backup_finish_date,
        CAST(bs.compressed_backup_size / 1024.0 / 1024.0 / 1024.0 AS DECIMAL(18,2)) AS BackupSize_GB,
        ROW_NUMBER() OVER
        (
            PARTITION BY bs.database_name, bs.type
            ORDER BY bs.backup_finish_date DESC
        ) AS rn
    FROM msdb.dbo.backupset bs
    INNER JOIN msdb.dbo.backupmediaset bms
        ON bs.media_set_id = bms.media_set_id
)
INSERT INTO #Backup_Report
(
    DatabaseName,
    LastFullBackupTime,
    FullBackupSize_GB,
    LastDiffBackupTime,
    DiffBackupSize_GB,
    LastLogBackupTime,
    LogBackupSize_MB
)
SELECT
    d.name AS DatabaseName,

    fb.backup_finish_date AS LastFullBackupTime,
    fb.BackupSize_GB      AS FullBackupSize_GB,

    db.backup_finish_date AS LastDiffBackupTime,
    db.BackupSize_GB      AS DiffBackupSize_GB,

    lb.backup_finish_date AS LastLogBackupTime,
    lb.BackupSize_GB*1024      AS LogBackupSize_MB

FROM sys.databases d
LEFT JOIN BackupCTE fb
    ON d.name = fb.database_name
   AND fb.type = 'D'
   AND fb.rn = 1

LEFT JOIN BackupCTE db
    ON d.name = db.database_name
   AND db.type = 'I'
   AND db.rn = 1

LEFT JOIN BackupCTE lb
    ON d.name = lb.database_name
   AND lb.type = 'L'
   AND lb.rn = 1

WHERE d.database_id > 4 and DB_NAME(d.database_id) NOT IN ('DBADB')
ORDER BY d.name;

/*********************/  
/****** Job Failure Last 24 hours *********/  
/*********************/  

IF OBJECT_ID('tempdb..#JobFailureSummary') IS NOT NULL
    DROP TABLE #JobFailureSummary;

CREATE TABLE #JobFailureSummary
(
    JobName                NVARCHAR(255),
    FailureCount_Last24Hrs INT,
    FirstFailureTime_UTC   NVARCHAR(255),
    LastFailureTime_UTC    NVARCHAR(255),
    LastFailedStep         NVARCHAR(255),
    JobOwner               NVARCHAR(255),
    JobCategory            NVARCHAR(255),
    JobStatus              NVARCHAR(20)
);

INSERT INTO #JobFailureSummary
(
    JobName,
    FailureCount_Last24Hrs,
    FirstFailureTime_UTC,
    LastFailureTime_UTC,
    LastFailedStep,
    JobOwner,
    JobCategory,
    JobStatus
)
SELECT
    j.sql_server_agent_job_name AS JobName,
    COUNT(f.sql_server_agent_job_failure_id) AS FailureCount_Last24Hrs,
    FORMAT(MIN(f.job_failure_time_utc), 'yyyy-MM-dd hh:mm tt') AS FirstFailureTime_UTC,
    FORMAT(MAX(f.job_failure_time_utc), 'yyyy-MM-dd hh:mm tt') AS LastFailureTime_UTC,
    MAX(f.job_failure_step_name) AS LastFailedStep,
    MAX(j.owner_login_name) AS JobOwner,
    MAX(j.job_category_name) AS JobCategory,
    CASE 
        WHEN MAX(CAST(j.is_enabled AS INT)) = 1 THEN 'Enabled'
        ELSE 'Disabled'
    END AS JobStatus
FROM DBADB.dbo.sql_server_agent_job_failure f
JOIN DBADB.dbo.sql_server_agent_job j
    ON f.sql_server_agent_job_id = j.sql_server_agent_job_id
WHERE f.job_failure_time_utc >= DATEADD(HOUR, -24, GETUTCDATE())
  AND j.is_deleted = 0
GROUP BY
    j.sql_server_agent_job_name
ORDER BY
    FailureCount_Last24Hrs DESC,
    LastFailureTime_UTC DESC;

/*********************/  
/****** Hourly Wait Stats Last 24 Hours *********/  
/*********************/  

-- Drop temp table if exists
IF OBJECT_ID('tempdb..#WaitStatsHourly') IS NOT NULL
    DROP TABLE #WaitStatsHourly;

-- Create temp table
CREATE TABLE #WaitStatsHourly
(
    DateHour    DATETIME,
    CPU_Pct     DECIMAL(10,2),
    IO_Data_Pct DECIMAL(10,2),
    IO_Log_Pct  DECIMAL(10,2),
    Memory_Pct  DECIMAL(10,2),
    Lock_Pct    DECIMAL(10,2),
	Network_Pct     DECIMAL(10,2) 
);

-- Insert aggregated hourly wait stats
;WITH Last24H AS
(
    SELECT
        DATEADD(HOUR, DATEDIFF(HOUR, 0, Date), 0) AS DateHour,
        WaitType,
        Percentage
    FROM dbo.WaitStatData
    WHERE Date >= DATEADD(HOUR,-24,GETDATE())
      AND WaitType NOT IN ('SOS_WORK_DISPATCHER')  -- mandatory exclusion
)
INSERT INTO #WaitStatsHourly (DateHour, CPU_Pct, IO_Data_Pct, IO_Log_Pct, Memory_Pct, Lock_Pct, Network_Pct)
SELECT
    DateHour,

    -- CPU
    SUM(CASE WHEN WaitType = 'SOS_SCHEDULER_YIELD'
             THEN Percentage ELSE 0 END) AS CPU_Pct,

    -- IO (Data)
    SUM(CASE WHEN WaitType LIKE 'PAGEIOLATCH%'
             THEN Percentage ELSE 0 END) AS IO_Data_Pct,

    -- IO (Log)
    SUM(CASE WHEN WaitType = 'WRITELOG'
             THEN Percentage ELSE 0 END) AS IO_Log_Pct,

    -- Memory
    SUM(CASE WHEN WaitType = 'RESOURCE_SEMAPHORE'
             THEN Percentage ELSE 0 END) AS Memory_Pct,

    -- Locking
    SUM(CASE WHEN WaitType LIKE 'LCK_%'
             THEN Percentage ELSE 0 END) AS Lock_Pct,
	-- Network
    SUM(CASE WHEN WaitType = 'ASYNC_NETWORK_IO'
             THEN Percentage ELSE 0 END) AS Network_Pct

FROM Last24H
GROUP BY DateHour
ORDER BY DateHour;

/*********************/  
/****** Long Running Queries Summary Last 24 Hours *********/  
/*********************/  

-- Drop temp table if exists
IF OBJECT_ID('tempdb..#LongRunningSummary') IS NOT NULL
    DROP TABLE #LongRunningSummary;

-- Create temp table
CREATE TABLE #LongRunningSummary
(
    Less_5_Min        INT,
    Between_5_10_Min  INT,
    Between_10_25_Min INT,
    Greater_25_Min    INT,
    TotalQueries      INT,
    SummaryDate       DATETIME DEFAULT GETDATE()
);

-- Insert aggregated counts into temp table
;WITH DistinctQueries AS
(
    -- Remove duplicates: same query text + database, pick only first occurrence
    SELECT 
        InstanceName,
        StartTime,
        SPID,
        UserName,
        ProgramName,
        DatabaseName,
        ExecutingSQL,
        WaitType,
        logdate,
        StatementText,
        StoredProcedure,
        is_closed,
        -- Convert HH:MM:SS string to total seconds
        DATEDIFF(SECOND, 0, CAST(ElapsedTime AS TIME)) AS ElapsedSeconds,
        ROW_NUMBER() OVER(
            PARTITION BY DatabaseName, ExecutingSQL ,SPID
            ORDER BY logdate DESC
        ) AS rn
    FROM DBADB.dbo.longqrydetails
    WHERE logdate >= DATEADD(HOUR,-24,GETDATE()) AND DatabaseName !='DBADB' -- only last 24 hours
)
INSERT INTO #LongRunningSummary (Less_5_Min, Between_5_10_Min, Between_10_25_Min, Greater_25_Min, TotalQueries)
SELECT
    COUNT(CASE WHEN ElapsedSeconds < 300 THEN 1 END) AS Less_5_Min,
    COUNT(CASE WHEN ElapsedSeconds >= 300 AND ElapsedSeconds < 600 THEN 1 END) AS Between_5_10_Min,
    COUNT(CASE WHEN ElapsedSeconds >= 600 AND ElapsedSeconds < 1500 THEN 1 END) AS Between_10_25_Min,
    COUNT(CASE WHEN ElapsedSeconds >= 1500 THEN 1 END) AS Greater_25_Min,
    COUNT(*) AS TotalQueries
FROM DistinctQueries
WHERE rn = 1;  -- only first occurrence per query

/*********************/  
/****** Head Blocker Queries Info *********/  
/*********************/  
IF OBJECT_ID('tempdb..#HeadBlockerSummary') IS NOT NULL
    DROP TABLE #HeadBlockerSummary;

CREATE TABLE #HeadBlockerSummary
(
    head_blocker_session_id   INT,
    head_blocker_query        NVARCHAR(500),
    blocking_queries_count    INT,
    BlockingDuration_HHMMSS   VARCHAR(20),
    BlockingDuration_Minutes  INT,
    logdate                   DATETIME,
    Status                    VARCHAR(20)
);
;WITH DedupHeadBlockers AS
(
    SELECT
        head_blocker_session_id,
        LEFT(head_blocker_query, 500) AS head_blocker_query,
        blocking_queries_count,
        duration,
        DATEDIFF(MINUTE, 0, CAST(duration AS TIME)) AS BlockingDuration_Minutes,
        logdate,
        ROW_NUMBER() OVER
        (
            PARTITION BY head_blocker_session_id
            ORDER BY logdate DESC
        ) AS rn
    FROM DBADB.dbo.HeadBlockingInfo
    WHERE logdate >= DATEADD(HOUR,-24,GETDATE()) --CAST(logdate AS DATE) = '2025-12-09'
    
    -- 🚫 Exclude maintenance / system activity
    AND head_blocker_query NOT LIKE '%ALTER INDEX%'
    AND head_blocker_query NOT LIKE '%CREATE%INDEX%'
    AND head_blocker_query NOT LIKE '%DBCC%'
    AND head_blocker_query NOT LIKE '%BACKUP%'
    AND head_blocker_query NOT LIKE '%CHECKDB%'
    AND head_blocker_query NOT LIKE '%UPDATE STATISTICS%'
    AND head_blocker_query NOT LIKE '%sp_updatestats%'
    AND head_blocker_query NOT LIKE '%IndexOptimize%'
    AND head_blocker_query NOT LIKE '%Maintenance%'
)
INSERT INTO #HeadBlockerSummary
(
    head_blocker_session_id,
    head_blocker_query,
    blocking_queries_count,
    BlockingDuration_HHMMSS,
    BlockingDuration_Minutes,
    logdate,
    Status
)
SELECT
    head_blocker_session_id,
    head_blocker_query,
    blocking_queries_count,
    duration AS BlockingDuration_HHMMSS,
    BlockingDuration_Minutes,
    logdate,
    CASE
        WHEN BlockingDuration_Minutes >= 10 
             OR blocking_queries_count >= 5 THEN 'ACTION REQUIRED'
        WHEN BlockingDuration_Minutes BETWEEN 5 AND 9 
             OR blocking_queries_count BETWEEN 2 AND 4 THEN 'WATCH'
        ELSE 'OK'
    END AS Status
FROM DedupHeadBlockers
WHERE rn = 1;

/*********************/  
/****** Index  Maintenance *********/  
/*********************/  

IF OBJECT_ID('tempdb..#HealthCheck_IndexMaintenance') IS NOT NULL
    DROP TABLE #HealthCheck_IndexMaintenance;

CREATE TABLE #HealthCheck_IndexMaintenance
(
    HealthCheckItem VARCHAR(100),
    Status          VARCHAR(20),
    FirstRunTime    VARCHAR(20),
    LastRunTime     VARCHAR(20)
);
INSERT INTO #HealthCheck_IndexMaintenance
(
    HealthCheckItem,
    Status,
    FirstRunTime,
    LastRunTime
)
SELECT
    'ALTER_INDEX' AS HealthCheckItem,
    CASE 
        WHEN COUNT(*) > 0 THEN 'DONE'
        ELSE 'NOT DONE'
    END AS Status,
    MIN(StartTime) AS FirstRunTime,
    MAX(EndTime)   AS LastRunTime
FROM DBADB.dbo.CommandLog WITH (NOLOCK)
WHERE CommandType = 'ALTER_INDEX'
  AND StartTime >= DATEADD(HOUR, -24, GETDATE());
INSERT INTO #HealthCheck_IndexMaintenance
SELECT
    'UPDATE_STATISTICS' AS HealthCheckItem,
    CASE 
        WHEN COUNT(*) > 0 THEN 'DONE'
        ELSE 'NOT DONE'
    END AS Status,
    MIN(StartTime) AS FirstRunTime,
    MAX(EndTime)   AS LastRunTime
FROM DBADB.dbo.CommandLog WITH (NOLOCK)
WHERE CommandType = 'UPDATE_STATISTICS'
  AND StartTime >= DATEADD(HOUR, -24, GETDATE());  
  
  
/*********************/  
/****** HTML Preparation *********/  
/*********************/  
  
DECLARE @TableHTML  VARCHAR(MAX),                                    
  @StrSubject VARCHAR(100),                                 
  @Version VARCHAR(250),                                
  @Edition VARCHAR(100),                                
  @SP VARCHAR(100),          
  @URL varchar(1000),                                
  @Str varchar(1000),                                
  @NoofCriErrors varchar(3)       
           
  
SELECT @Version = @@version                                
SELECT @Edition = CONVERT(VARCHAR(50), serverproperty('Edition'))                                                               
SELECT @SP = CONVERT(VARCHAR(50), SERVERPROPERTY ('productlevel'))                                                                 
SELECT @strSubject = ISNULL(@ClientName, 'ClientName') + ' Database Server Health Check Report (' + ISNULL(@Server, @@SERVERNAME)+ ')';
                                    


SET @TableHTML = 
'<font face="Verdana" size="2">
My Dear DBA,<br><br>
Good Morning,<br><br>
Please review the SQL Server health check information below.  
This report provides key observations and analysis collected during the health check window.  
Kindly review and take necessary action where required.<br><br>
</font>';


 SET                                   
 @TableHTML =     @TableHTML +                                
 '</table>                                  
 <font face="Verdana" size="4"><b>SQL Server Details  </b></font>  
 <table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                
 <tr>                                
 <td align="Center" width="50%" bgColor="001F3D" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Version</font></b></td>                                
 <td align="Center" width="17%" bgColor="001F3D" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Edition</font></b></td>                                
 <td align="Center" width="35%" bgColor="001F3D" height="15"><b>                                
 <font face="Verdana" color="#ffffff" size="1">Service Pack</font></b></td>                                                                
 </tr>                                
 <tr>                                
 <td align="Center" width="50%" height="27"><font face="Verdana" size="1">'+@version +'</font></td>                                
 <td align="Center" width="17%" height="27"><font face="Verdana" size="1">'+@edition+'</font></td>                                
 <td align="Center" width="18%" height="27"><font face="Verdana" size="1">'+@SP+'</font></td>                                
 </tr> '                               
 
 --AG Report

--  IF EXISTS (SELECT 1 FROM #AG_DB_Status)
--BEGIN					
--SELECT                                   
-- @TableHTML = @TableHTML +                                   
-- '</table>                          
-- <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
-- <font face="Verdana" size="4">High Availability Database Status </font><br><br>' +
   
-- '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="1500" bgColor="#ffffff" borderColorLight="#000000" border="1"> 
 
-- <tr>                                    
-- <th align="Center" width="300" bgColor="001F3D">                                    
-- <font face="Verdana" size="1" color="#FFFFFF">AG_Name</font></th>   
-- <th align="Center" width="300" bgColor="001F3D">                                   
-- <font face="Verdana" size="1" color="#FFFFFF">DatabaseName</font></th>                                    
-- <th align="Center" width="300" bgColor="001F3D">                                    
-- <font face="Verdana" size="1" color="#FFFFFF">PrimaryServer</font></th>                                   
-- <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">SecondaryServer</font></th> 
-- <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">AvailabilityMode</font></th> 
-- <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">FailoverMode</font></th> 
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">SynchronizationState</font></th> 
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">SynchronizationHealth</font></th> 
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">SuspendReason</font></th> 
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">LogSendQueue_KB</font></th>
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">LogSendRate_KB_per_sec</font></th> 
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">RedoQueue_KB</font></th> 
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">RedoRate_KB_per_sec</font></th> 
--  <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">SecondaryLag_Seconds</font></th> 
-- </tr>'                                    
--END

--SELECT                                   
-- @TableHTML = @TableHTML +                                      
--'<tr><td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), AG_Name),'') + '</font></td>' +                       
-- '<td align="Center"><font face="Verdana" size="1" >' + ISNULL(CONVERT(VARCHAR(50), DatabaseName),'') + '</font></td>' +                                  
-- '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), PrimaryServer),'') +'</font></td>' + 
--  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SecondaryServer),'') +'</font></td>' +    
--   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), AvailabilityMode),'') +'</font></td>' +    
--    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), FailoverMode),'') +'</font></td>' +    
--	 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SynchronizationState),'') +'</font></td>' +    
--	  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SynchronizationHealth),'') +'</font></td>' +    
--	   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SuspendReason),'') +'</font></td>' +    
--	    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LogSendQueue_KB),'') +'</font></td>' +    
--		 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LogSendRate_KB_per_sec),'') +'</font></td>' +    
--		  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), RedoQueue_KB),'') +'</font></td>' +    
--		   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), RedoRate_KB_per_sec),'') +'</font></td>' +    
--		   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SecondaryLag_Seconds),'') +'</font></td>'  
--FROM #AG_DB_Status

 /**Log Shipping Status****/
 IF EXISTS (SELECT 1 FROM #LogShippingStatus)
BEGIN

SELECT                                   
 @TableHTML = @TableHTML +                                   
 '</table>                          
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>Log Shipping Database Details</b></font><br><br>' +
   
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="1500" bgColor="#ffffff" borderColorLight="#000000" border="1"> 
 
 <tr>                                    
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">PrimaryServer</font></th>   
 <th align="Center" width="300" bgColor="001F3D">                                   
 <font face="Verdana" size="1" color="#FFFFFF">PrimaryDatabase</font></th> 
 <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">LastBackupDate</font></th>  
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">SecondaryServer</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">SecondaryDatabase</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">LastCopiedDate</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">LastRestoredDate</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">LastRestoredLatency</font></th> 
   <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">HealthStatus</font></th> 
 </tr>'                                    
END

SELECT                                   
 @TableHTML = @TableHTML +                                      
'<tr><td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), PrimaryServer),'') + '</font></td>' +                       
 '<td align="Center"><font face="Verdana" size="1" >' + ISNULL(CONVERT(VARCHAR(50), PrimaryDatabase),'') + '</font></td>' +     
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LastBackupDate),'') +'</font></td>' +      
	  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SecondaryServer),'') +'</font></td>' +    
	   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SecondaryDatabase),'') +'</font></td>' +    
		 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LastCopiedDate),'') +'</font></td>' +      
		   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LastRestoredDate),'') +'</font></td>' +    
		   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LastRestoredLatency),'') +'</font></td>' +  
		   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), HealthStatus),'') +'</font></td>' 
FROM #LogShippingStatus where PrimaryServer IN ('CHARBISERVER')


--IF EXISTS (SELECT 1 FROM #DBMirroringStatus)
--BEGIN

--SELECT                                   
-- @TableHTML = @TableHTML +                                   
-- '</table>                          
-- <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
-- <font face="Verdana" size="4">Mirroring Database Details</font><br><br>' +
   
-- '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="1500" bgColor="#ffffff" borderColorLight="#000000" border="1"> 
 
-- <tr>                                    
-- <th align="Center" width="300" bgColor="001F3D">                                    
-- <font face="Verdana" size="1" color="#FFFFFF">DatabaseName</font></th>   
-- <th align="Center" width="300" bgColor="001F3D">                                   
-- <font face="Verdana" size="1" color="#FFFFFF">Role</font></th>                                    
-- <th align="Center" width="300" bgColor="001F3D">                                    
-- <font face="Verdana" size="1" color="#FFFFFF">State</font></th>                                   
-- <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">MirrorServer</font></th> 
-- <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">MirrorServerInstance</font></th> 
-- <th align="Center" width="300" bgColor="001F3D">                                  
-- <font face="Verdana" size="1" color="#FFFFFF">SafetyLevel</font></th> 
-- </tr>'                                    
--END

--SELECT                                   
-- @TableHTML = @TableHTML +                                      
--'<tr><td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), DatabaseName),'') + '</font></td>' +                       
-- '<td align="Center"><font face="Verdana" size="1" >' + ISNULL(CONVERT(VARCHAR(50), Role),'') + '</font></td>' +                                  
-- '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), State),'') +'</font></td>' + 
--  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), MirrorServer),'') +'</font></td>' +    
--   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), MirrorServerInstance),'') +'</font></td>' +    
--    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), SafetyLevel),'') +'</font></td>' 
--FROM #DBMirroringStatus

  SELECT                                   
 @TableHTML = @TableHTML +                                     
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>Services Last Recycled Status  </b></font>  
 <table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>
 <table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="933" bgColor="#ffffff" borderColorLight="#000000" border="1">                                      
 <tr>                                      
 <th align="Center" width="50" bgColor="001F3D">                                      
  <font face="Verdana" size="1" color="#FFFFFF">Service_Name</font></th> 
  <th align="Center" width="50" bgColor="001F3D">                                      
  <font face="Verdana" size="1" color="#FFFFFF">Service_Status</font></th> 
  <th align="Center" width="50" bgColor="001F3D">                                      
  <font face="Verdana" size="1" color="#FFFFFF">Last Recycle Date & Time</font></th> 
 <th align="Center" width="50" bgColor="001F3D">                                      
  <font face="Verdana" size="1" color="#FFFFFF">Current Date & Time</font></th>                                      
 <th align="Center" width="50" bgColor="001F3D">                                   
 <font face="Verdana" size="1" color="#FFFFFF">UpTimeInDays</font></th>                                      
  </tr>'  
   
SELECT                                   
 @TableHTML =  @TableHTML +                                       
 '<tr>                                    
 <td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100), ServiceName ), '')  +'</font></td>' +                                        
'<td align="Center"><font face="Verdana" size="1" color="' +
        CASE WHEN ServiceStatus = 'Running' THEN '#40C211' ELSE '#FF0000' END + '">' + 
        ISNULL(CONVERT(VARCHAR(10), ServiceStatus), '') +
    '</font></td>' +                                   
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  RestartTime ), '')  +'</font></td>' +  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  CurrentTime ), '')  +'</font></td>' +
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  UpTimeInDays ), '')  +'</font></td>' +
  '</tr>'                                  
FROM                                   
 #RebootDetails 

 /** CPU Usage ***/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>CPU Usage Last 24 Hours </b></font>        
 <table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Minimum_Utilization (%)</font></th>               
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Maximum_Utilization (%)</font></th>               
 <th align="Center" width="250" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Average_Utilization (%)</font></th>               
 <th align="Center" width="250" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Maximum_Utilization Count</font></th>              
   </tr>'                                  
SELECT                                   
 @TableHTML =  @TableHTML +                                     
 '<tr>' +                                      
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), Min_Total_CPU ), '')  +'</font></td>' +    
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), Max_Total_CPU ), '')  +'</font></td>' +                              
   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), Avg_Total_CPU ), '')  +'</font></td>'+   
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), Max_CPU_Hit_Count ), '')  +'</font></td></tr>'
FROM                                   
 #CPU  

  /** PLE Status ***/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>PLE Status Last 24 Hours </b></font>        
 <table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Minimum_PLE (Sec)</font></th>               
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Maximum_PLE (Sec)</font></th>               
 <th align="Center" width="250" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Average_PLE (Sec)</font></th>               
 <th align="Center" width="250" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">PLE < 300 (Sec) Count</font></th>              
   </tr>'                                  
SELECT                                   
 @TableHTML =  @TableHTML +                                     
 '<tr>' +                                      
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), MinPLE ), '')  +'</font></td>' +    
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), MaxPLE ), '')  +'</font></td>' +                              
   '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), AvgPLE ), '')  +'</font></td>'+   
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), PLE_Less_Than_300_Count ), '')  +'</font></td></tr>'
FROM                                   
 #PLE
                                                     
/** Free Disk Space Report ***/  
 
SELECT
@TableHTML = @TableHTML +
'</table>

<p style="margin-top:0; margin-bottom:0">&nbsp;</p>

<font face="Verdana" size="4"><b>Disk Space Usage</b></font>

<!-- Small space after heading -->
<table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr>
        <td height="6">&nbsp;</td>
    </tr>
</table>

<table style="BORDER-COLLAPSE: collapse"
       borderColor="#111111"
       cellPadding="0"
       width="933"
       bgColor="#ffffff"
       borderColorLight="#000000"
       border="1">
<tr>
    <th align="Center" width="150" bgColor="#001F3D">
        <font face="Verdana" size="1" color="#FFFFFF">Drive Letter</font>
    </th>
    <th align="Center" width="150" bgColor="#001F3D">
        <font face="Verdana" size="1" color="#FFFFFF">TotalSpace_GB</font>
    </th>
    <th align="Center" width="150" bgColor="#001F3D">
        <font face="Verdana" size="1" color="#FFFFFF">UsedSpace_GB</font>
    </th>
    <th align="Center" width="150" bgColor="#001F3D">
        <font face="Verdana" size="1" color="#FFFFFF">FreeSpace_GB</font>
    </th>
    <th align="Center" width="150" bgColor="#001F3D">
        <font face="Verdana" size="1" color="#FFFFFF">Percentage_Full</font>
    </th>
</tr>';
                                 
                                  
SELECT                                   
 @TableHTML = @TableHTML +   
'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), Drive_Letter),'') + '</font></td>' +  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), TotalSpace_GB),'') + '</font></td>' +                                  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), UsedSpace_GB),'') +'</font></td>' +     
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(max), FreeSpace_GB),'') +'</font></td>' +
CASE WHEN Percentage_Full > 90 THEN
  '<td align="Center"><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(CONVERT(VARCHAR(100),  Percentage_Full), '')  +'</font></td>'
ELSE  
  '<td align="Center"><font face="Verdana" size="1" color="#40C211"><b>' + ISNULL(CONVERT(VARCHAR(100),  Percentage_Full), '')  +'</font></td>'
  END +
  '</tr>'
FROM #driveinfo order By Drive_Letter ASC
 
  
/** Tempdb File Usage ***/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>Tempdb File Usage</b></font>  
  <table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Database Name</font></th>               
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">File Name</font></th>               
 <th align="Center" width="250" bgColor="001F3D"> 
 <font face="Verdana" size="1" color="#FFFFFF">Physical Name</font></th>               
 <th align="Center" width="250" bgColor="001F3D">                                
 <font face="Verdana" size="1" color="#FFFFFF">FileSize_GB</font></th>               
 <th align="Center" width="200" bgColor="001F3D">               
 <font face="Verdana" size="1" color="#FFFFFF">Available_GB</font></th>               
 <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Percentage_Full </font></th>  
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Total_Disk_Space_GB </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Available_Disk_Space_GB </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Auto_Growth_Status </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Auto_Growth_Value </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Auto_Growth_Max_Limit </font></th> 
   </tr>'                                  
SELECT
    @TableHTML = @TableHTML +
    '<tr>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(databasename, '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(filename, '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(physicalName, '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), filesizeGB), '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), availableSpaceGB), '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1" color="' +
        CASE WHEN percentfull > 80 THEN '#FF0000' ELSE '#40C211' END + '">' +
        ISNULL(CONVERT(VARCHAR(10), percentfull), '') +
    '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), diskTotalGB), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), diskFreeGB), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), AutoGrowth), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), AutoGrowthSetting), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), MaxSize), '') + '</font></td>' +
    '</tr>'
FROM #tempdbfileusage;
     
  
 
 /** UserDB File Usage ***/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>User Database File Usage</b></font> 
  <table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>
<table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>

 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Database Name</font></th>               
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">File Name</font></th> 
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">File Type</font></th>
 <th align="Center" width="250" bgColor="001F3D"> 
 <font face="Verdana" size="1" color="#FFFFFF">Physical Name</font></th>               
 <th align="Center" width="250" bgColor="001F3D">                                
 <font face="Verdana" size="1" color="#FFFFFF">FileSize_GB</font></th>               
 <th align="Center" width="200" bgColor="001F3D">               
 <font face="Verdana" size="1" color="#FFFFFF">Available_GB</font></th>               
 <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Percentage_Full </font></th>  
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Total_Disk_Space_GB </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Available_Disk_Space_GB </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Auto_Growth_Status </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Auto_Growth_Value </font></th> 
  <th align="Center" width="200" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Auto_Growth_Max_Limit </font></th>                
   </tr>'                                  
SELECT
    @TableHTML = @TableHTML +
    '<tr>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(databasename, '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(filename, '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(filetype, '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(physicalName, '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), filesizeGB), '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), availableSpaceGB), '') + '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1" color="' +
        CASE WHEN percentfull > 80 THEN '#FF0000' ELSE '#40C211' END + '">' +
        ISNULL(CONVERT(VARCHAR(10), percentfull), '') +
    '</font></td>' +
    '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), diskTotalGB), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), diskFreeGB), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), AutoGrowth), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), AutoGrowthSetting), '') + '</font></td>' +
	'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), MaxSize), '') + '</font></td>' +
    '</tr>'
FROM #UserDBFileUsage;
   
/** Database Backup Report ***/  
SELECT                                   
 @TableHTML =  @TableHTML +                              
 '</table>                                  
 <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>Backup Report for User Database</b></font>
   <table width="933" cellpadding="0" cellspacing="0" border="0">
    <tr><td height="6">&nbsp;</td></tr>
</table>
 <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
   <tr>                
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Database_Name</font></th>                              
  <th align="Center" width="300" bgColor="001F3D">               
 <font face="Verdana" size="1" color="#FFFFFF">LastFullBackupTime</font></th> 
 <th align="Center" width="300" bgColor="001F3D">               
 <font face="Verdana" size="1" color="#FFFFFF">FullBackupSize_GB</font></th>
 <th align="Center" width="300" bgColor="001F3D">               
 <font face="Verdana" size="1" color="#FFFFFF">LastDiffBackupTime</font></th> 
 <th align="Center" width="300" bgColor="001F3D">              
 <font face="Verdana" size="1" color="#FFFFFF">DiffBackupSize_GB</font></th>
 <th align="Center" width="300" bgColor="001F3D">              
 <font face="Verdana" size="1" color="#FFFFFF">LastLogBackupTime</font></th> 
 <th align="Center" width="300" bgColor="001F3D">               
 <font face="Verdana" size="1" color="#FFFFFF">LogBackupSize_MB</font></th>
   </tr>'                                  
SELECT      
 @TableHTML = @TableHTML +                                       
 '<tr>' +
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(DatabaseName, '') + '</font></td>' +
 CASE WHEN LastFullBackupTime IS NULL OR DATEDIFF(DAY, LastFullBackupTime, GETDATE()) > 7 THEN '<td align="Center"><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(CONVERT(VARCHAR(19), LastFullBackupTime, 120), '') + '</b></font></td>'
 ELSE '<td align="Center"><font face="Verdana" size="1" color="#40C211">'+ CONVERT(VARCHAR(19), LastFullBackupTime, 120) + '</font></td>' END +
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), FullBackupSize_GB), '') + '</font></td>' +
 CASE WHEN LastDiffBackupTime IS NULL OR DATEDIFF(DAY, LastDiffBackupTime, GETDATE()) > 2 THEN '<td align="Center"><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(CONVERT(VARCHAR(19), LastDiffBackupTime, 120), '') + '</b></font></td>'
 ELSE '<td align="Center"><font face="Verdana" size="1" color="#40C211">' + CONVERT(VARCHAR(19), LastDiffBackupTime, 120) + '</font></td>' END +
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), DiffBackupSize_GB), '') + '</font></td>' +
 CASE WHEN LastLogBackupTime IS NULL OR DATEDIFF(HOUR, LastLogBackupTime, GETDATE()) > 2  THEN '<td align="Center"><font face="Verdana" size="1" color="#FF0000"><b>' + ISNULL(CONVERT(VARCHAR(19), LastLogBackupTime, 120), '') + '</b></font></td>'
 ELSE '<td align="Center"><font face="Verdana" size="1" color="#40C211">' + CONVERT(VARCHAR(19), LastLogBackupTime, 120) + '</font></td>' END +
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(20), LogBackupSize_MB), '') + '</font></td>' + '</tr>'
FROM #Backup_Report 
 
   
 /**Failed Jobs in Last 24Hrs****/
 IF EXISTS (SELECT 1 FROM #JobFailureSummary)
BEGIN

SELECT                                   
 @TableHTML = @TableHTML +                                   
 '</table>                          
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>Failed Jobs in Last 24Hrs</b></font><br><br>' +
   
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="1500" bgColor="#ffffff" borderColorLight="#000000" border="1"> 
 
 <tr>                                    
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Job Name</font></th>   
 <th align="Center" width="300" bgColor="001F3D">                                   
 <font face="Verdana" size="1" color="#FFFFFF">Failure_Count</font></th>                                    
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">First_Failure_Time</font></th>                                   
 <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Last_Failure_Time</font></th>   
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Last_Failed_Step</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Job_Owner</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Job_Category</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Job_Status</font></th> 
 </tr>'                                    
END

SELECT                                   
 @TableHTML = @TableHTML +                                      
'<tr><td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), JobName),'') + '</font></td>' +                       
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(5), FailureCount_Last24Hrs),'') + '</font></td>' +                                  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), FirstFailureTime_UTC),'') +'</font></td>' +  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LastFailureTime_UTC),'') +'</font></td>' + 
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LastFailedStep),'') +'</font></td>' + 
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), JobOwner),'') +'</font></td>' + 
'<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), JobCategory),'') +'</font></td>' + 
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), JobStatus),'') +'</font></td></tr>'      
FROM #JobFailureSummary


-- Initialize HTML table variable
SELECT @TableHTML = @TableHTML +
 '</table>                          
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>Wait Statistics Report in Last 24Hrs</b></font><br><br>' +
   
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="1500" bgColor="#ffffff" borderColorLight="#000000" border="1"> 
 
 <tr>                                    
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Date & Time</font></th>   
 <th align="Center" width="300" bgColor="001F3D">                                   
 <font face="Verdana" size="1" color="#FFFFFF">CPU (%)</font></th>                                    
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">IO Data (%)</font></th>                                   
 <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">IO Log (%)</font></th>   
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Memory (%)</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Lock (%)</font></th> 
   <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Network (%)</font></th> 
  <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">Over all Status</font></th> 
 </tr>'  

-- Build table rows with color-coded flags
SELECT @TableHTML = @TableHTML +
'<tr>' +
'<td align="Center"><font face="Verdana" size="1">' + CONVERT(VARCHAR, DateHour, 120) + '</font></td>' +

-- CPU column with color
'<td align="Center"><font face="Verdana" size="1" color="' +
    CASE 
        WHEN CPU_Pct > 40 THEN '#FF0000'       -- red
        WHEN CPU_Pct BETWEEN 20 AND 40 THEN '#FFD700' -- yellow
        ELSE '#40C211'                         -- green
    END + '">' +
    CONVERT(VARCHAR(10), CPU_Pct) +
'</font></td>' +

-- IO_Data column
'<td align="Center"><font face="Verdana" size="1" color="' +
    CASE 
        WHEN IO_Data_Pct > 40 THEN '#FF0000'
        WHEN IO_Data_Pct BETWEEN 25 AND 40 THEN '#FFD700'
        ELSE '#40C211'
    END + '">' +
    CONVERT(VARCHAR(10), IO_Data_Pct) +
'</font></td>' +

-- IO_Log column
'<td align="Center"><font face="Verdana" size="1" color="' +
    CASE 
        WHEN IO_Log_Pct >= 20 THEN '#FF0000'
        ELSE '#40C211'
    END + '">' +
    CONVERT(VARCHAR(10), IO_Log_Pct) +
'</font></td>' +

-- Memory column
'<td align="Center"><font face="Verdana" size="1" color="' +
    CASE 
        WHEN Memory_Pct > 0 THEN '#FFD700'
        ELSE '#40C211'
    END + '">' +
    CONVERT(VARCHAR(10), Memory_Pct) +
'</font></td>' +

-- Lock column
'<td align="Center"><font face="Verdana" size="1" color="' +
    CASE 
        WHEN Lock_Pct >= 10 THEN '#FF0000'
        ELSE '#40C211'
    END + '">' +
    CONVERT(VARCHAR(10), Lock_Pct) +
'</font></td>' +

-- ✅ Network IO
'<td align="Center"><font face="Verdana" size="1" color="' +
    CASE 
        WHEN Network_Pct > 15 THEN '#FF0000'
        WHEN Network_Pct BETWEEN 5 AND 15 THEN '#FFD700'
        ELSE '#40C211'
    END + '">' +
    CONVERT(VARCHAR(10), Network_Pct) +
'</font></td>' +

-- Overall Status
'<td align="Center" style="font-weight:bold;"><font face="Verdana" size="1" color="' +
CASE 
    WHEN CPU_Pct > 40
      OR IO_Data_Pct > 40
      OR IO_Log_Pct >= 20
      OR Lock_Pct >= 10
      OR Network_Pct > 15
        THEN '#FF0000'

    WHEN CPU_Pct BETWEEN 20 AND 40
      OR IO_Data_Pct BETWEEN 25 AND 40
      OR Memory_Pct > 0
      OR Network_Pct BETWEEN 5 AND 15
        THEN '#FFCC00'

    ELSE '#40C211'
END + '">' +

CASE 
    WHEN CPU_Pct > 40
      OR IO_Data_Pct > 40
      OR IO_Log_Pct >= 20
      OR Lock_Pct >= 10
      OR Network_Pct > 15
        THEN 'ACTION'

    WHEN CPU_Pct BETWEEN 20 AND 40
      OR IO_Data_Pct BETWEEN 25 AND 40
      OR Memory_Pct > 0
      OR Network_Pct BETWEEN 5 AND 15
        THEN 'WATCH'

    ELSE 'OK'
END +

'</font></td>' +
'</tr>'
FROM #WaitStatsHourly;

SELECT @TableHTML = @TableHTML + '</table>';



/******** Long Running Transactions ********/

-- ===== Always show heading =====
SELECT @TableHTML = @TableHTML +
'<p style="margin-top:5; margin-bottom:5">&nbsp;</p>
<font face="Verdana" size="4">
<b>Long Running Queries Summary in Last 24 Hours</b>
</font>';

IF EXISTS (SELECT 1 FROM #LongRunningSummary)
BEGIN
    /* ===== Table Header ===== */
    SELECT @TableHTML = @TableHTML +
    '<table width="933" cellpadding="0" cellspacing="0" border="0">
        <tr><td height="6">&nbsp;</td></tr>
     </table>

     <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse"
            borderColor="#111111" cellPadding="0"
            width="933" border="1">
        <tr>
            <th align="Center" bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">SummaryDate</font></th>
            <th align="Center" bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">&lt;5 Min</font></th>
            <th align="Center" bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">5-10 Min</font></th>
            <th align="Center" bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">10-25 Min</font></th>
            <th align="Center" bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">&gt;25 Min</font></th>
            <th align="Center" bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Total Queries</font></th>
        </tr>';

    /* ===== Table Rows ===== */
    SELECT @TableHTML = @TableHTML +
    '<tr>
        <td align="Center"><font face="Verdana" size="1">' + CONVERT(VARCHAR(19), SummaryDate, 120) + '</font></td>
        <td align="Center"><font face="Verdana" size="1">' + CONVERT(VARCHAR(10), Less_5_Min) + '</font></td>
        <td align="Center"><font face="Verdana" size="1">' + CONVERT(VARCHAR(10), Between_5_10_Min) + '</font></td>
        <td align="Center"><font face="Verdana" size="1">' + CONVERT(VARCHAR(10), Between_10_25_Min) + '</font></td>
        <td align="Center"><font face="Verdana" size="1">' + CONVERT(VARCHAR(10), Greater_25_Min) + '</font></td>
        <td align="Center"><font face="Verdana" size="1">' + CONVERT(VARCHAR(10), TotalQueries) + '</font></td>
     </tr>'
    FROM #LongRunningSummary;

    -- Close table
    SELECT @TableHTML = @TableHTML + '</table>';
END
ELSE
BEGIN
    /* ===== No data message ===== */
    SELECT @TableHTML = @TableHTML +
    '<p style="margin-top:10px; margin-bottom:10px">
        <font face="Verdana" size="3" color="#008000">
            No Long Running queries found in the last 24 hours
        </font>
     </p>';
END



 /** Head Blocking Information **/   						
/**************** Blocking Information ****************/
SELECT @TableHTML = @TableHTML +
'<p style="margin-top: 5; margin-bottom: 5">&nbsp;</p>
<font face="Verdana" size="4"><b>Blocked Queries Report in Last 24 Hours</b></font>';

IF EXISTS (SELECT 1 FROM #HeadBlockerSummary)
BEGIN
    /* ===== Table Header ===== */
    SELECT @TableHTML = @TableHTML +
    '<table width="933" cellpadding="0" cellspacing="0" border="0">
        <tr><td height="6">&nbsp;</td></tr>
     </table>

     <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse"
            borderColor="#111111" cellPadding="3"
            width="933" border="1">
        <tr>
            <th bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Head Blocker SPID</font></th>
            <th bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Head Blocker Query</font></th>
            <th bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Blocked Count</font></th>
            <th bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Duration (HH:MM:SS)</font></th>
            <th bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Duration (Minutes)</font></th>
            <th bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Log Date</font></th>
            <th bgColor="001F3D"><font face="Verdana" size="1" color="#FFFFFF">Status</font></th>
        </tr>';

    /* ===== Table Rows ===== */
    SELECT
        @TableHTML = @TableHTML +
        '<tr>
            <td align="center"><font face="Verdana" size="1">' +
                ISNULL(CONVERT(VARCHAR(10), head_blocker_session_id), '') + '</font></td>

            <td><font face="Verdana" size="1">' +
                ISNULL(head_blocker_query, '') + '</font></td>

            <td align="center"><font face="Verdana" size="1">' +
                ISNULL(CONVERT(VARCHAR(10), blocking_queries_count), '') + '</font></td>

            <td align="center"><font face="Verdana" size="1">' +
                ISNULL(BlockingDuration_HHMMSS, '') + '</font></td>

            <td align="center"><font face="Verdana" size="1">' +
                ISNULL(CONVERT(VARCHAR(10), BlockingDuration_Minutes), '') + '</font></td>

            <td align="center"><font face="Verdana" size="1">' +
                ISNULL(CONVERT(VARCHAR(19), logdate, 120), '') + '</font></td>

            <td align="center" style="font-weight:bold;">
                <font face="Verdana" size="1" color="' +

                CASE Status
                    WHEN 'ACTION REQUIRED' THEN '#FF0000'
                    WHEN 'WATCH'         THEN '#FFCC00'
                    WHEN 'OK'             THEN  '#008000'
                    ELSE '#000000'
                END +

                '">' + Status + '</font>
            </td>
        </tr>'
    FROM #HeadBlockerSummary
    ORDER BY logdate DESC;
-- CLOSE THE TABLE HERE
SELECT @TableHTML = @TableHTML + '</table>';

END
ELSE
BEGIN
    /* ===== No data message ===== */
    SELECT @TableHTML = @TableHTML +
    '<p style="margin-top:10px; margin-bottom:10px">
        <font face="Verdana" size="3" color="#008000">
            No Head Blocker queries found in the last 24 hours
        </font>
     </p>';
END
-- CLOSE THE TABLE HERE
SELECT @TableHTML = @TableHTML + '</table>';


/**Index Maintenance in Last 24Hrs****/
 IF EXISTS (SELECT 1 FROM #HealthCheck_IndexMaintenance)
BEGIN

SELECT                                   
 @TableHTML = @TableHTML +                                   
 '</table>                          
 <p style="margin-top: 0; margin-bottom: 0">&nbsp;</p>                                  
 <font face="Verdana" size="4"><b>Index Maintenance in Last 24Hrs</b></font><br><br>' +
   
 '<table style="BORDER-COLLAPSE: collapse" borderColor="#111111" cellPadding="0" width="1500" bgColor="#ffffff" borderColorLight="#000000" border="1"> 
 
 <tr>                                    
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Category</font></th>   
 <th align="Center" width="300" bgColor="001F3D">                                   
 <font face="Verdana" size="1" color="#FFFFFF">Status</font></th>                                    
 <th align="Center" width="300" bgColor="001F3D">                                    
 <font face="Verdana" size="1" color="#FFFFFF">Start Time</font></th>                                   
 <th align="Center" width="300" bgColor="001F3D">                                  
 <font face="Verdana" size="1" color="#FFFFFF">End Time</font></th>    
 </tr>'                                    
END

SELECT                                   
 @TableHTML = @TableHTML +                                      
'<tr><td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), HealthCheckItem),'') + '</font></td>' +                       
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(10), Status),'') + '</font></td>' +                                  
 '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), FirstRunTime),'NOT OCCURED') +'</font></td>' +  
  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(50), LastRunTime),'NOT OCCURED') +'</font></td></tr>'      
FROM #HealthCheck_IndexMaintenance


SELECT @TableHTML = @TableHTML + '</table>';


		
 
 /** Error Log Report Last 24 Hours***/  
-- SELECT                                   
-- @TableHTML =  @TableHTML +                              
-- '</table>                                  
-- <p style="margin-top: 1; margin-bottom: 0">&nbsp;</p>                                  
-- <font face="Verdana" size="4">Error Log Report in Last 24 Hours</font>
--   <table width="933" cellpadding="0" cellspacing="0" border="0">
--    <tr><td height="6">&nbsp;</td></tr>
--</table>
-- <table id="AutoNumber1" style="BORDER-COLLAPSE: collapse" borderColor="#111111" height="40" cellSpacing="0" cellPadding="0" width="933" border="1">                                  
--   <tr>    
-- <th align="Center" width="300" bgColor="001F3D">                                    
-- <font face="Verdana" size="1" color="#FFFFFF">ErrorMessage</font></th> 
-- <th align="Center" width="300" bgColor="001F3D">                                    
-- <font face="Verdana" size="1" color="#FFFFFF">ErrorCount</font></th>                              
--  <th align="Center" width="300" bgColor="001F3D">               
-- <font face="Verdana" size="1" color="#FFFFFF">FirstOccurrence</font></th> 
-- <th align="Center" width="300" bgColor="001F3D">               
-- <font face="Verdana" size="1" color="#FFFFFF">LastOccurrence</font></th>
--   </tr>'                                  
--SELECT      
-- @TableHTML =  @TableHTML +                                       
-- '<tr>    
-- <td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(MAX),  ErrorMessage), '')  +'</font></td>' +  
--  '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(VARCHAR(100),  ErrorCount), 'NULL')  +'</font></td>' + 
-- '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(varchar, FirstOccurrence, 120), '')  +'</font></td>' +  
-- '<td align="Center"><font face="Verdana" size="1">' + ISNULL(CONVERT(varchar, LastOccurrence, 120), '')  +'</font></td>' + 
   
--  '</tr>'                                  
--FROM             
-- #ErrorLogSummary order by ErrorCount desc

SET @TableHTML = @TableHTML +
'<br><br>
<font face="Verdana" size="2">
Thanks &amp; Regards,<br>
SQL Server<br>
' + @SERVERNAME + ' 
</font>';



    
EXEC msdb.dbo.sp_send_dbmail                                    
 @profile_name = @MailProfile,                       
 @recipients=@MailID,                                   
 @subject = @strSubject,                                   
 @body = @TableHTML,                                      
 @body_format = 'HTML' ;                               
  
  
DROP TABLE  #RebootDetails;    
DROP TABLE  #CPU; 
DROP TABLE #PLE;
DROP TABLE  #Backup_Report;   
DROP TABLE  #tempdbfileusage; 
DROP TABLE  #UserDBFileUsage;
DROP TABLE  #JobFailureSummary;
Drop TABLE #LongRunningSummary;
Drop TABLE #HeadBlockerSummary
Drop TABLE #driveinfo;
Drop TABLE #output;
DROP TABLE #WaitStatsHourly;
  
SET NOCOUNT OFF;  
SET ARITHABORT OFF;  
END  
 

GO

/****** Object:  StoredProcedure [dbo].[TEMPFILEALERT]    Script Date: 2/9/2026 8:31:44 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[TEMPFILEALERT] 
AS
BEGIN

SET NOCOUNT ON
DECLARE @DBName NVARCHAR(100) = 'tempdb', --Provide DBName if looking for a specific database or leave to get all databases details
        @Drive NVARCHAR(2) = NULL --Mention drive letter if you are concerned of only a single drive where you are running out of space
 
DECLARE @cmd NVARCHAR(4000)
IF (SELECT OBJECT_ID('tempdb.dbo.#tempDBName')) IS NOT NULL
DROP TABLE #tempDBName
CREATE TABLE #tempDBName (Name NVARCHAR(100))
 
IF @DBName IS NOT NULL
INSERT INTO #tempDBName SELECT @DBName
ELSE
INSERT INTO #tempDBName SELECT Name FROM sys.databases WHERE state_desc = 'ONLINE'
 
IF (SELECT OBJECT_ID('tempdb.dbo.##TempFileStats')) IS NOT NULL
DROP TABLE ##TempFileStats
CREATE TABLE ##TempFileStats (ServerName NVARCHAR(100), DBName NVARCHAR(100), DiskDrive varchar(10), DiskFreeSpace varchar(20),FileType NVARCHAR(100), 
FileName NVARCHAR(100), CurrentSizeMB FLOAT, FreeSpaceMB FLOAT, PercentMBFree FLOAT, FileLocation NVARCHAR(1000),AutoGrowthGB varchar(60))
 
WHILE (SELECT TOP 1 * FROM #tempDBName) IS NOT NULL
BEGIN
 
    SELECT @DBName = MIN(Name) FROM #tempDBName
 
    SET @cmd = 'USE [' + @DBName + ']
    INSERT INTO ##TempFileStats
    SELECT @@ServerName AS ServerName, DB_NAME() AS DbName, 
REPLACE(vs.volume_mount_point,'':'', '''') AS Drive,
    ROUND(vs.available_bytes / 1073741824.0, 2) AS FreeSpaceGB,
    CASE WHEN type = 0 THEN ''DATA'' ELSE ''LOG'' END AS FileType,
    name AS FileName, 
    size/128.0 AS CurrentSizeMB,  
    size/128.0 - CAST(FILEPROPERTY(name, ''SpaceUsed'') AS INT)/128.0 AS FreeSpaceMB,
    100*(1 - ((CAST(FILEPROPERTY(name, ''SpaceUsed'') AS INT)/128.0)/(size/128.0))) AS PercentMBFree,
    physical_name AS FileLocation,
	CASE WHEN mf.max_size = -1 THEN ''Unlimited'' ELSE CAST(ROUND(CAST(max_size*8.0/1024.0/1024.0 AS DECIMAL(18, 2)), 2) AS VARCHAR(20)) END AS AutoGrowthGB
    FROM sys.database_files mf
	CROSS APPLY sys.dm_os_volume_stats(DB_ID(), mf.file_id) vs'
     
    IF @Drive IS NOT NULL
    SET @cmd = @cmd + ' WHERE physical_name LIKE ''' + @Drive + ':\%'''
 
    EXEC sp_executesql @cmd
     
    DELETE FROM #tempDBName WHERE Name = @DBName
     
END
 
SELECT * FROM ##TempFileStats
ORDER BY FreeSpaceMB DESC

DROP TABLE #tempDBName
DROP TABLE ##TempFileStats
END
GO

/****** Object:  StoredProcedure [dbo].[TrackServerConfigurationChanges]    Script Date: 2/9/2026 8:31:44 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [dbo].[TrackServerConfigurationChanges]
AS
BEGIN
SET NOCOUNT ON
DECLARE @tracepath NVARCHAR(260);

-- Specify the default trace directory path
SET @tracepath = (SELECT TOP 1 [path] FROM sys.traces WHERE is_default = 1);
SELECT 
    TE.name AS EventName,
    CONVERT(datetimeoffset, StartTime) AS EventTime,
    DB_NAME(t.DatabaseID) AS DatabaseName,
	LTRIM(REPLACE(SUBSTRING(t.TEXTdata,31,250),'. Run the RECONFIGURE statement to install.', '')),
    t.ObjectName AS ObjectName,
    t.ObjectType AS ObjectType,
    t.ObjectType AS ObjectTypeCode,
    t.ObjectType AS ObjectTypeDesc,
    t.HostName,
    t.ApplicationName,
    t.LoginName,
        t.Error
FROM    sys.fn_trace_gettable(@tracepath, default) T
INNER JOIN sys.trace_events TE ON T.EventClass = TE.trace_event_id
WHERE
--te.trace_event_id IN (46, 47)
--and t.DatabaseID > 4
--t.ObjectName NOT LIKE '#%'
--and t.ObjectType NOT IN (83, 88)
tE.category_id = 3 and te.trace_event_id = 22
--and t.IndexID is NULL
AND StartTime >= DATEADD(HOUR, -1, GETDATE()); 
SET NOCOUNT OFF
END
GO

/****** Object:  StoredProcedure [dbo].[usp_Monitor_LongRunning_Jobs]    Script Date: 2/9/2026 8:31:44 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO



--IF OBJECT_ID('[dbo].[usp_Monitor_LongRunning_Jobs]', 'P') IS NOT NULL
--    DROP PROCEDURE [dbo].[usp_Monitor_LongRunning_Jobs];
--GO

CREATE PROCEDURE [dbo].[usp_Monitor_LongRunning_Jobs]
    @Threshold INT = 180,                          -- ⏱ Threshold in minutes before auto-stop
    @JobName NVARCHAR(200) = NULL,                -- 🔍 Optional specific job name (NULL = all)
    @MailProfile NVARCHAR(200) = N'DBA',  -- 📧 Database Mail profile name
    @Recipients NVARCHAR(500) = N'aswin.kumarvpkothuru@thyrocare.com'  -- 👥 Recipients
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE 
        @JobID UNIQUEIDENTIFIER,
        @Duration_mins INT,
        @Subject NVARCHAR(200),
        @Message NVARCHAR(MAX),
        @ErrorMsg NVARCHAR(4000),
        @CurrentSessionID INT;

    -- ✅ Identify current SQL Agent session
    SELECT @CurrentSessionID = MAX(session_id)
    FROM msdb.dbo.syssessions;

    -- 🎯 Select job(s) to process
    DECLARE job_cursor CURSOR FOR
    SELECT j.name, j.job_id
    FROM msdb.dbo.sysjobs AS j
    INNER JOIN msdb.dbo.sysjobactivity AS ja ON j.job_id = ja.job_id
    LEFT JOIN msdb.dbo.syscategories AS c ON j.category_id = c.category_id
    WHERE ja.start_execution_date IS NOT NULL
      AND ja.stop_execution_date IS NULL
      AND ja.session_id = @CurrentSessionID
      AND j.enabled = 1
      AND (
            c.name NOT IN (
				N'REPL-Alert Response',
                N'Database Maintenance',
                N'REPL-Distribution',
				N'REPL-Distribution Cleanup',
                N'REPL-LogReader',
                N'REPL-Merge',
                N'REPL-Snapshot',
                N'REPL-QueueReader',
				N'Replication',
                N'REPL-Replication Monitoring',
                N'CDC Capture',
                N'CDC Cleanup',
				N'TTL - Database Maintenance'
            )
            OR c.name IS NULL
        )
      AND j.name NOT LIKE '%DatabaseIntegrityCheck%'
      AND j.name NOT LIKE '%IndexOptimize%'
      AND j.name NOT LIKE '%CommandLog%'
      AND j.name NOT LIKE '%Output File Cleanup%'
      AND j.name NOT LIKE '%Backup%'
      AND j.name NOT LIKE '%Distribution%'
      AND j.name NOT LIKE '%LogReader%'
      AND j.name NOT LIKE '%Replication%'
      AND j.name NOT LIKE '%CDC%'
      AND j.name NOT LIKE '%IntegrityCheck%'
      AND j.name NOT LIKE '%Repl-%'
      AND (@JobName IS NULL OR j.name = @JobName);  -- ✅ Optional filter for specific job

    OPEN job_cursor;
    FETCH NEXT FROM job_cursor INTO @JobName, @JobID;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @ErrorMsg = NULL;

        -- Calculate duration
        SELECT @Duration_mins = DATEDIFF(MINUTE, ja.start_execution_date, GETDATE())
        FROM msdb.dbo.sysjobactivity AS ja
        WHERE ja.job_id = @JobID
          AND ja.stop_execution_date IS NULL
          AND ja.session_id = @CurrentSessionID;

        IF @Duration_mins IS NOT NULL
        BEGIN
            PRINT CONCAT('Job "', @JobName, '" has been running for ', @Duration_mins, ' minutes.');

            IF @Duration_mins > @Threshold
            BEGIN
                -- Double check before stopping
                IF EXISTS (
                    SELECT 1
                    FROM msdb.dbo.sysjobactivity
                    WHERE job_id = @JobID
                      AND start_execution_date IS NOT NULL
                      AND stop_execution_date IS NULL
                      AND session_id = @CurrentSessionID
                )
                BEGIN
                    BEGIN TRY
                        EXEC msdb.dbo.sp_stop_job @job_name = @JobName;
                        PRINT CONCAT('Stopped job "', @JobName, '" due to long execution time.');

                        INSERT INTO dbo.DBA_JobMonitorLog (JobName, DurationMinutes, ActionTaken)
                        VALUES (@JobName, @Duration_mins, 'Stopped due to long run');

                        SET @Subject = CONCAT('CHARBI Server SQL Job Stopped: ', @JobName);
                        SET @Message = CONCAT(
                            'The SQL Agent job "', @JobName, '" was stopped automatically because it exceeded the threshold of ',
                            @Threshold, ' minutes.', CHAR(13), CHAR(10),
                            'Actual run time: ', @Duration_mins, ' minutes.', CHAR(13), CHAR(10),
                            'Server: ', @@SERVERNAME, CHAR(13), CHAR(10),
                            'Timestamp: ', CONVERT(VARCHAR(30), GETDATE(), 120)
                        );

                        BEGIN TRY
                            EXEC msdb.dbo.sp_send_dbmail
                                @profile_name = @MailProfile,
                                @recipients = @Recipients,
                                @subject = @Subject,
                                @body = @Message;
                            PRINT CONCAT('Notification sent for job "', @JobName, '".');
                        END TRY
                        BEGIN CATCH
                            SET @ErrorMsg = CONCAT('Email not sent for "', @JobName, '" (', ERROR_MESSAGE(), ')');
                            PRINT @ErrorMsg;

                            UPDATE dbo.DBA_JobMonitorLog
                            SET ErrorMessage = @ErrorMsg
                            WHERE LogID = SCOPE_IDENTITY();
                        END CATCH
                    END TRY
                    BEGIN CATCH
                        SET @ErrorMsg = ERROR_MESSAGE();
                        PRINT CONCAT('Error stopping job "', @JobName, '": ', @ErrorMsg);

                        INSERT INTO dbo.DBA_JobMonitorLog (JobName, DurationMinutes, ActionTaken, ErrorMessage)
                        VALUES (@JobName, @Duration_mins, 'Error while stopping', @ErrorMsg);
                    END CATCH
                END
                ELSE
                BEGIN
                    PRINT CONCAT('Job "', @JobName, '" finished before stop attempt — skipping stop.');
                    INSERT INTO dbo.DBA_JobMonitorLog (JobName, DurationMinutes, ActionTaken)
                    VALUES (@JobName, @Duration_mins, 'Skipped - job finished before stop');
                END
            END
            ELSE
            BEGIN
                PRINT CONCAT('Job "', @JobName, '" is within allowed duration.');
                INSERT INTO dbo.DBA_JobMonitorLog (JobName, DurationMinutes, ActionTaken)
                VALUES (@JobName, @Duration_mins, 'Within allowed duration');
            END
        END

        FETCH NEXT FROM job_cursor INTO @JobName, @JobID;
    END

    CLOSE job_cursor;
    DEALLOCATE job_cursor;

    PRINT 'Job monitoring completed safely (All actions logged; Replication/Maintenance/CDC excluded).';
END
GO


